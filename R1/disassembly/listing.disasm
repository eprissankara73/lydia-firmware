Disassembly Listing for LIT_R1
Generated From:
C:/Users/pvan002/Box Sync/low_income_thermostats/lita_sw/R1/dist/default/debug/R1.debug.elf
Mar 27, 2019 5:30:12 PM

---  C:/Users/pvan002/Box Sync/low_income_thermostats/lita_sw/R1/system.c  ------------------------------
1:                 /*
2:                  * File:   system.c
3:                  * Author: Madhu
4:                  *
5:                  * Created on January 17, 2019, 8:05 AM
6:                  */
7:                 
8:                 
9:                 #include <xc.h>
10:                #include "main.h"
11:                #include "hal.h"
12:                #include "bme680.h"
13:                #include "memory.h"
14:                #include "system.h"
15:                #include "FRAM.h"
16:                #include "rtcc.h"
17:                
18:                
19:                /******************************************************************************
20:                 *          BME680 related
21:                 ******************************************************************************/
22:                struct bme680_dev gas_sensor;
23:                uint16_t meas_period;    
24:                struct bme680_field_data data;
25:                
26:                void ConfigureBME680(void)
27:                {
009416  FA0002     LNK #0x2
28:                    uint8_t set_required_settings;
29:                    int8_t rslt = BME680_OK;
009418  EB4000     CLR.B W0
00941A  784F00     MOV.B W0, [W14]
30:                    
31:                    gas_sensor.dev_id = 0;
00941C  224D10     MOV #0x24D1, W0
00941E  EB4080     CLR.B W1
009420  784801     MOV.B W1, [W0]
32:                    gas_sensor.intf = BME680_SPI_INTF;
009422  EB0000     CLR W0
009424  892690     MOV W0, .L102
33:                    gas_sensor.read = BME680_spi_read;
009426  294A80     MOV #0x94A8, W0
009428  8928A0     MOV W0, 0x2514
34:                    gas_sensor.write = BME680_spi_write;
00942A  294F20     MOV #0x94F2, W0
00942C  8928B0     MOV W0, 0x2516
35:                    gas_sensor.delay_ms = BME680_delay_ms;
00942E  294880     MOV #0x9488, W0
009430  8928C0     MOV W0, 0x2518
36:                    gas_sensor.amb_temp = 25; //can also be set after getting a few readings
009432  224D50     MOV #0x24D5, W0
009434  B3C191     MOV.B #0x19, W1
009436  784801     MOV.B W1, [W0]
37:                    
38:                    rslt = bme680_init(&gas_sensor);
009438  224D00     MOV #0x24D0, W0
00943A  07E0D4     RCALL bme680_init
00943C  784F00     MOV.B W0, [W14]
39:                    
40:                    //Setting up the TPHG configuration registers:
41:                    /* Set the temperature, pressure and humidity settings */
42:                    gas_sensor.tph_sett.os_hum = BME680_OS_2X;
00943E  225040     MOV #0x2504, W0
009440  B3C021     MOV.B #0x2, W1
009442  784801     MOV.B W1, [W0]
43:                    gas_sensor.tph_sett.os_pres = BME680_OS_4X;
009444  225060     MOV #0x2506, W0
009446  B3C031     MOV.B #0x3, W1
009448  784801     MOV.B W1, [W0]
44:                    gas_sensor.tph_sett.os_temp = BME680_OS_8X;
00944A  225050     MOV #0x2505, W0
00944C  B3C041     MOV.B #0x4, W1
00944E  784801     MOV.B W1, [W0]
45:                    gas_sensor.tph_sett.filter = BME680_FILTER_SIZE_3;
009450  225070     MOV #0x2507, W0
009452  B3C021     MOV.B #0x2, W1
009454  784801     MOV.B W1, [W0]
46:                
47:                    /* Set the remaining gas sensor settings and link the heating profile */
48:                    gas_sensor.gas_sett.run_gas = BME680_DISABLE_GAS_MEAS; //BME680_ENABLE_GAS_MEAS;
009456  2250A0     MOV #0x250A, W0
009458  EB4080     CLR.B W1
00945A  784801     MOV.B W1, [W0]
49:                    /* Create a ramp heat waveform in 3 steps */
50:                    gas_sensor.gas_sett.heatr_temp = 320; /* degree Celsius */
00945C  201400     MOV #0x140, W0
00945E  892860     MOV W0, 0x250C
51:                    gas_sensor.gas_sett.heatr_dur = 150; /* milliseconds */
009460  200960     MOV #0x96, W0
009462  892870     MOV W0, 0x250E
52:                
53:                    /* Select the power mode */
54:                    /* Must be set before writing the sensor configuration */
55:                    gas_sensor.power_mode = BME680_FORCED_MODE; 
009464  225100     MOV #0x2510, W0
009466  B3C011     MOV.B #0x1, W1
009468  784801     MOV.B W1, [W0]
56:                
57:                    /* Set the required sensor settings needed */
58:                    set_required_settings = BME680_OST_SEL | BME680_OSP_SEL | BME680_OSH_SEL | BME680_FILTER_SEL 
00946A  B3CDF0     MOV.B #0xDF, W0
00946C  984710     MOV.B W0, [W14+1]
59:                        | BME680_GAS_SENSOR_SEL;
60:                
61:                    
62:                    /* Set the desired sensor configuration */
63:                    rslt = bme680_set_sensor_settings(set_required_settings,&gas_sensor);
00946E  90401E     MOV.B [W14+1], W0
009470  FB8000     ZE W0, W0
009472  224D01     MOV #0x24D0, W1
009474  07E19C     RCALL bme680_set_sensor_settings
009476  784F00     MOV.B W0, [W14]
64:                
65:                    /* Set the power mode */
66:                    rslt = bme680_set_sensor_mode(&gas_sensor);
009478  224D00     MOV #0x24D0, W0
00947A  07E34D     RCALL bme680_set_sensor_mode
00947C  784F00     MOV.B W0, [W14]
67:                    
68:                    bme680_get_profile_dur(&meas_period, &gas_sensor);
00947E  224D01     MOV #0x24D0, W1
009480  2090E0     MOV #0x90E, W0
009482  07E402     RCALL bme680_get_profile_dur
69:                }
009484  FA8000     ULNK
009486  060000     RETURN
70:                
71:                void BME680_delay_ms(uint32_t period)
72:                {
009488  FA0004     LNK #0x4
00948A  BE8F00     MOV.D W0, [W14]
73:                    __delay_ms(period);
00948C  BE001E     MOV.D [W14], W0
00948E  B81160     MUL.UU W2, #0, W2
009490  224004     MOV #0x2400, W4
009492  200F45     MOV #0xF4, W5
009494  B83360     MUL.UU W6, #0, W6
009496  07BA95     RCALL ___muldi3
009498  203E84     MOV #0x3E8, W4
00949A  200005     MOV #0x0, W5
00949C  B83360     MUL.UU W6, #0, W6
00949E  07BA28     RCALL ___udivdi3
0094A0  BE0000     MOV.D W0, W0
0094A2  071D97     RCALL ___delay32, .Letext0, .LFE18
74:                }
0094A4  FA8000     ULNK
0094A6  060000     RETURN
75:                
76:                int8_t BME680_spi_read(uint8_t dev_id, uint8_t reg_addr, uint8_t *reg_data, uint16_t len)
77:                {
0094A8  FA000A     LNK #0xA
0094AA  781F88     MOV W8, [W15++]
0094AC  984740     MOV.B W0, [W14+4]
0094AE  984751     MOV.B W1, [W14+5]
0094B0  980732     MOV W2, [W14+6]
0094B2  980743     MOV W3, [W14+8]
78:                    int8_t rslt = 0; /* Return 0 for Success, non-zero for failure */
0094B4  EB4000     CLR.B W0
0094B6  984720     MOV.B W0, [W14+2]
79:                    uint16_t i = 0;
0094B8  EB0000     CLR W0
0094BA  780F00     MOV W0, [W14]
80:                   
81:                    /*
82:                     * Data on the bus should be like
83:                     * |----------------+---------------------+-------------|
84:                     * | MOSI           | MISO                | Chip Select |
85:                     * |----------------+---------------------|-------------|
86:                     * | (don't care)   | (don't care)        | HIGH        |
87:                     * | (reg_addr)     | (don't care)        | LOW         |
88:                     * | (don't care)   | (reg_data[0])       | LOW         |
89:                     * | (....)         | (....)              | LOW         |
90:                     * | (don't care)   | (reg_data[len - 1]) | LOW         |
91:                     * | (don't care)   | (don't care)        | HIGH        |
92:                     * |----------------+---------------------|-------------|
93:                     */
94:                
95:                    if (dev_id == 0) //if we have more than one BME680, the CS line will be selected here
0094BC  90404E     MOV.B [W14+4], W0
0094BE  E00400     CP0.B W0
0094C0  3A0001     BRA NZ, .L4
96:                    {
97:                        CS_BME680_SetLow();
0094C2  A9C6B2     BCLR LATE, #6
98:                    }
99:                    
100:                   SPI1_Write8bit(reg_addr);
0094C4  90405E     MOV.B [W14+5], W0
0094C6  071254     RCALL SPI1_Write8bit
101:                   
102:                   for (i=0;i<len;i++)
0094C8  EB0000     CLR W0
0094CA  780F00     MOV W0, [W14]
0094CC  370006     BRA .L5
0094D8  E80F1E     INC [W14], [W14]
0094DA  90004E     MOV [W14+8], W0
0094DC  78009E     MOV [W14], W1
0094DE  508F80     SUB W1, W0, [W15]
0094E0  39FFF6     BRA NC, .L6
103:                   {
104:                       reg_data[i] = SPI1_Exchange8bit(0);
0094CE  90003E     MOV [W14+6], W0
0094D0  40041E     ADD W0, [W14], W8
0094D2  EB4000     CLR.B W0
0094D4  071263     RCALL SPI1_Exchange8bit
0094D6  784C00     MOV.B W0, [W8]
105:                   }
106:                   
107:                   if (dev_id == 0) //if we have more than one BME680, the CS line will be selected here
0094E2  90404E     MOV.B [W14+4], W0
0094E4  E00400     CP0.B W0
0094E6  3A0001     BRA NZ, .L7
108:                   {
109:                       CS_BME680_SetHigh();
0094E8  A8C6B2     BSET LATE, #6
110:                   }
111:                   return rslt;
0094EA  90402E     MOV.B [W14+2], W0
112:               }
0094EC  78044F     MOV [--W15], W8
0094EE  FA8000     ULNK
0094F0  060000     RETURN
113:               
114:               int8_t BME680_spi_write(uint8_t dev_id, uint8_t reg_addr, uint8_t *reg_data, uint16_t len)
115:               {
0094F2  FA000A     LNK #0xA
0094F4  984740     MOV.B W0, [W14+4]
0094F6  984751     MOV.B W1, [W14+5]
0094F8  980732     MOV W2, [W14+6]
0094FA  980743     MOV W3, [W14+8]
116:                    int8_t rslt = 0; /* Return 0 for Success, non-zero for failure */
0094FC  EB4000     CLR.B W0
0094FE  984720     MOV.B W0, [W14+2]
117:                    uint16_t i = 0;
009500  EB0000     CLR W0
009502  780F00     MOV W0, [W14]
118:                    
119:                   /*
120:                    * Data on the bus should be like
121:                    * |---------------------+--------------+-------------|
122:                    * | MOSI                | MISO         | Chip Select |
123:                    * |---------------------+--------------|-------------|
124:                    * | (don't care)        | (don't care) | HIGH        |
125:                    * | (reg_addr)          | (don't care) | LOW         |
126:                    * | (reg_data[0])       | (don't care) | LOW         |
127:                    * | (....)              | (....)       | LOW         |
128:                    * | (reg_data[len - 1]) | (don't care) | LOW         |
129:                    * | (don't care)        | (don't care) | HIGH        |
130:                    * |---------------------+--------------|-------------|
131:                    */
132:                   if (dev_id == 0) //if we have more than one BME680, the CS line will be selected here
009504  90404E     MOV.B [W14+4], W0
009506  E00400     CP0.B W0
009508  3A0001     BRA NZ, .L9
133:                   {
134:                       CS_BME680_SetLow();
00950A  A9C6B2     BCLR LATE, #6
135:                   }
136:                   
137:                   SPI1_Write8bit(reg_addr);
00950C  90405E     MOV.B [W14+5], W0
00950E  071230     RCALL SPI1_Write8bit
138:                   
139:                   for (i=0;i<len;i++)
009510  EB0000     CLR W0
009512  780F00     MOV W0, [W14]
009514  370005     BRA .L10
00951E  E80F1E     INC [W14], [W14]
009520  90004E     MOV [W14+8], W0
009522  78009E     MOV [W14], W1
009524  508F80     SUB W1, W0, [W15]
009526  39FFF7     BRA NC, .L11
140:                   {
141:                       SPI1_Write8bit(reg_data[i]);
009516  90003E     MOV [W14+6], W0
009518  40001E     ADD W0, [W14], W0
00951A  784010     MOV.B [W0], W0
00951C  071229     RCALL SPI1_Write8bit
142:                   }
143:                   
144:                   if (dev_id == 0) //if we have more than one BME680, the CS line will be selected here
009528  90404E     MOV.B [W14+4], W0
00952A  E00400     CP0.B W0
00952C  3A0001     BRA NZ, .L12
145:                   {
146:                       CS_BME680_SetHigh();
00952E  A8C6B2     BSET LATE, #6
147:                   }
148:                   return rslt;
009530  90402E     MOV.B [W14+2], W0
149:                   
150:               }
009532  FA8000     ULNK
009534  060000     RETURN
151:                  
152:                   
153:               /**
154:                * Reads Temperature from U4 : AN10 OR U6: AN11
155:                * Board edge is location 0x0A, board center is 0x0B
156:                * @return 
157:                */
158:               uint8_t ReadBoardTemperature(uint8_t location)
159:               {
009536  FA000E     LNK #0xE
009538  BE9F88     MOV.D W8, [W15++]
00953A  984F40     MOV.B W0, [W14+12]
160:                   uint16_t adcData = 0;
00953C  EB0000     CLR W0
00953E  780F00     MOV W0, [W14]
161:                   float voltage = 0;
009540  B80060     MUL.UU W0, #0, W0
009542  980720     MOV W0, [W14+4]
009544  980731     MOV W1, [W14+6]
162:                   float temperature = 0;
009546  B80060     MUL.UU W0, #0, W0
009548  980740     MOV W0, [W14+8]
00954A  980751     MOV W1, [W14+10]
163:                   uint8_t i = 0;
00954C  EB4000     CLR.B W0
00954E  984720     MOV.B W0, [W14+2]
164:                   //Turning on LMT70 power and enabling ADC:
165:                   // AD1CON1bits.ADON=1;
166:                   // _LATC15 = 1;
167:                   // __delay_us(500); //for LMT70 power to stabilize
168:                   //0x0A is T1ADC - board edge, 0x0B is T2ADC 
169:                   for (i=0; i<= 9; i++) 
009550  EB4000     CLR.B W0
009552  984720     MOV.B W0, [W14+2]
009554  370006     BRA .L14
00955C  90402E     MOV.B [W14+2], W0
00955E  E84000     INC.B W0, W0
009560  984720     MOV.B W0, [W14+2]
009562  90402E     MOV.B [W14+2], W0
009564  504FE9     SUB.B W0, #0x9, [W15]
009566  36FFF7     BRA LEU, .L15
170:                   {
171:                       adcData = adcData + ADC1_ReadChannel(location);
009556  90484E     MOV.B [W14+12], W0
009558  0713E6     RCALL ADC1_ReadChannel
00955A  400F1E     ADD W0, [W14], [W14]
172:                   }
173:                   adcData = adcData / 10;
009568  78009E     MOV [W14], W1
00956A  2CCCD0     MOV #0xCCCD, W0
00956C  B80800     MUL.UU W1, W0, W0
00956E  DE0843     LSR W1, #3, W0
009570  780F00     MOV W0, [W14]
174:                   
175:                   //converting to voltage:
176:                   voltage = ( (float)adcData / 4096.0 ) * 3300; //in mv
009572  78001E     MOV [W14], W0
009574  EB0080     CLR W1
009576  07B823     RCALL ___floatunsisf
009578  200002     MOV #0x0, W2
00957A  245803     MOV #0x4580, W3
00957C  07B78C     RCALL ___divsf3
00957E  240002     MOV #0x4000, W2
009580  2454E3     MOV #0x454E, W3
009582  07B87A     RCALL ___mulsf3
009584  980720     MOV W0, [W14+4]
009586  980731     MOV W1, [W14+6]
177:                   
178:                   //Using the third order equation (d.s page # 13)
179:                   
180:                   temperature = -0.000007857923 * voltage * voltage -
009588  2D5862     MOV #0xD586, W2
00958A  2B7033     MOV #0xB703, W3
00958C  90002E     MOV [W14+4], W0
00958E  9000BE     MOV [W14+6], W1
009590  07B873     RCALL ___mulsf3
009592  90012E     MOV [W14+4], W2
009594  9001BE     MOV [W14+6], W3
009596  07B870     RCALL ___mulsf3
009598  BE0400     MOV.D W0, W8
0095A4  BE0100     MOV.D W0, W2
0095A6  BE0008     MOV.D W8, W0
0095A8  07B718     RCALL ___subsf3
0095AA  2A3CA2     MOV #0xA3CA, W2
0095AC  2434C3     MOV #0x434C, W3
0095AE  07B716     RCALL ___addsf3
0095B0  980740     MOV W0, [W14+8]
0095B2  980751     MOV W1, [W14+10]
181:                                 0.1777501 * voltage + 
00959A  2041F2     MOV #0x41F, W2
00959C  23E363     MOV #0x3E36, W3
00959E  90002E     MOV [W14+4], W0
0095A0  9000BE     MOV [W14+6], W1
0095A2  07B86A     RCALL ___mulsf3
182:                                 204.6398;
183:                   //getting rid of the decimal
184:                   temperature = floor(temperature);
0095B4  90004E     MOV [W14+8], W0
0095B6  9000DE     MOV [W14+10], W1
0095B8  07B804     RCALL _floorf
0095BA  980740     MOV W0, [W14+8]
0095BC  980751     MOV W1, [W14+10]
185:                   //converting Centigrade to deg F:
186:                   temperature = (temperature * 9 / 5.0) + 32;
0095BE  200002     MOV #0x0, W2
0095C0  241103     MOV #0x4110, W3
0095C2  90004E     MOV [W14+8], W0
0095C4  9000DE     MOV [W14+10], W1
0095C6  07B858     RCALL ___mulsf3
0095C8  200002     MOV #0x0, W2
0095CA  240A03     MOV #0x40A0, W3
0095CC  07B764     RCALL ___divsf3
0095CE  200002     MOV #0x0, W2
0095D0  242003     MOV #0x4200, W3
0095D2  07B704     RCALL ___addsf3
0095D4  980740     MOV W0, [W14+8]
0095D6  980751     MOV W1, [W14+10]
187:                   
188:                   //turning off  ADC and LMT70:
189:                   //AD1CON1bits.ADON = 0;
190:                   // _LATC15 = 0;
191:                   return floor(temperature);    
0095D8  90004E     MOV [W14+8], W0
0095DA  9000DE     MOV [W14+10], W1
0095DC  07B7F2     RCALL _floorf
0095DE  07B7D1     RCALL ___fixunssfsi
0095E0  784000     MOV.B W0, W0
192:               }
0095E2  BE044F     MOV.D [--W15], W8
0095E4  FA8000     ULNK
0095E6  060000     RETURN
193:               
194:               /**
195:                * Reads battery voltage sensed on AN13
196:                * 
197:                * @return voltage in mv
198:                */
199:               uint16_t ReadBatteryVoltage (void)
200:               {
0095E8  FA0008     LNK #0x8
201:                   uint16_t adcData = 0;
0095EA  EB0000     CLR W0
0095EC  780F00     MOV W0, [W14]
202:                   uint8_t i = 0;
0095EE  EB4000     CLR.B W0
0095F0  984720     MOV.B W0, [W14+2]
203:                   float battVoltage = 0;
0095F2  B80060     MUL.UU W0, #0, W0
0095F4  980720     MOV W0, [W14+4]
0095F6  980731     MOV W1, [W14+6]
204:                   __delay_ms(1); //for voltage to stabilize after wakeup
0095F8  23E800     MOV #0x3E80, W0
0095FA  200001     MOV #0x0, W1
0095FC  071CEA     RCALL ___delay32, .Letext0, .LFE18
205:                   //AD1CON1bits.ADON=1;
206:                   for (i=0; i<= 9; i++) 
0095FE  EB4000     CLR.B W0
009600  984720     MOV.B W0, [W14+2]
009602  370006     BRA .L17
00960A  90402E     MOV.B [W14+2], W0
00960C  E84000     INC.B W0, W0
00960E  984720     MOV.B W0, [W14+2]
009610  90402E     MOV.B [W14+2], W0
009612  504FE9     SUB.B W0, #0x9, [W15]
009614  36FFF7     BRA LEU, .L18
207:                   {
208:                       adcData = adcData + ADC1_ReadChannel(0x0D);
009604  B3C0D0     MOV.B #0xD, W0
009606  07138F     RCALL ADC1_ReadChannel
009608  400F1E     ADD W0, [W14], [W14]
209:                   }
210:                   adcData = adcData / 10;
009616  78009E     MOV [W14], W1
009618  2CCCD0     MOV #0xCCCD, W0
00961A  B80800     MUL.UU W1, W0, W0
00961C  DE0843     LSR W1, #3, W0
00961E  780F00     MOV W0, [W14]
211:               
212:                   //AD1CON1bits.ADON=0;
213:                   battVoltage = ((float)adcData / 4096.0 ) * 3300 ; //in mv
009620  78001E     MOV [W14], W0
009622  EB0080     CLR W1
009624  07B7CC     RCALL ___floatunsisf
009626  200002     MOV #0x0, W2
009628  245803     MOV #0x4580, W3
00962A  07B735     RCALL ___divsf3
00962C  240002     MOV #0x4000, W2
00962E  2454E3     MOV #0x454E, W3
009630  07B823     RCALL ___mulsf3
009632  980720     MOV W0, [W14+4]
009634  980731     MOV W1, [W14+6]
214:                   
215:                   return (uint16_t)battVoltage;    
009636  90002E     MOV [W14+4], W0
009638  9000BE     MOV [W14+6], W1
00963A  07B7A3     RCALL ___fixunssfsi
00963C  780000     MOV W0, W0
216:               }
00963E  FA8000     ULNK
009640  060000     RETURN
217:               
218:               /**
219:                * This function reads the current time from RTCC 
220:                * and populates the u8NewHeatSetpoint and u8NewCoolSetpoint based on schedule
221:                * and sets the i32DurationMins variable based on time remaining from now to next schedule
222:                * This function assumes that schedules are available and does not check
223:                * The calling function must check that before calling this function
224:                */
225:               void SetScheduleForNow()
226:               {
009642  FA0026     LNK #0x26
227:                   struct tm curr_time;
228:                   int ii;
229:                   int tmpi;
230:                   int tmpj;
231:                   int tmpk;
232:                   int tmpl;
233:                   int start_idx;
234:                   int last_idx;
235:                   int32_t tmpi32;
236:                   bool done = false;
009644  EB4000     CLR.B W0
009646  984720     MOV.B W0, [W14+2]
237:                   RTCC_TimeGet(&curr_time);
009648  470074     ADD W14, #0x14, W0
00964A  071A9E     RCALL RTCC_TimeGet
238:                   //ReadSchedule(curr_time.tm_wday);
239:                   start_idx = curr_time.tm_wday*20;
00964C  90100E     MOV [W14+32], W0
00964E  B90074     MUL.SU W0, #20, W0
009650  780000     MOV W0, W0
009652  980720     MOV W0, [W14+4]
240:                   ii = CountSchedulesInWday(curr_time.tm_wday*20);
009654  90100E     MOV [W14+32], W0
009656  B90074     MUL.SU W0, #20, W0
009658  780000     MOV W0, W0
00965A  070330     RCALL CountSchedulesInWday
00965C  980730     MOV W0, [W14+6]
241:                   if (ii == 0)
00965E  90003E     MOV [W14+6], W0
009660  E00000     CP0 W0
009662  3A0030     BRA NZ, .L20
242:                   {
243:                       // Set CSP and HSP from an available previous schedule
244:                       // Set duration from now to next available schedule
245:                       tmpi = FindPreviousSchedule(start_idx);
009664  90002E     MOV [W14+4], W0
009666  070289     RCALL FindPreviousSchedule
009668  980740     MOV W0, [W14+8]
246:                       if (tmpi > 0) // found valid schedule
00966A  90004E     MOV [W14+8], W0
00966C  E00000     CP0 W0
00966E  34000A     BRA LE, .L21
247:                       {
248:                           u8NewCoolSetpoint = u8arrSchedule[tmpi+2];
009670  90004E     MOV [W14+8], W0
009672  E88000     INC2 W0, W0
009674  21C231     MOV #0x1C23, W1
009676  784061     MOV.B [W1+W0], W0
009678  B7E8B6     MOV.B WREG, u8NewCoolSetpoint
249:                           u8NewHeatSetpoint = u8arrSchedule[tmpi+3];
00967A  90004E     MOV [W14+8], W0
00967C  400063     ADD W0, #0x3, W0
00967E  21C231     MOV #0x1C23, W1
009680  784061     MOV.B [W1+W0], W0
009682  B7E8B9     MOV.B WREG, u8NewHeatSetpoint
250:                       }
251:                       tmpi = (24-curr_time.tm_hour)*60 + (60-curr_time.tm_min);
009684  9008CE     MOV [W14+24], W1
009686  2FFC40     MOV #0xFFC4, W0
009688  B98800     MUL.SS W1, W0, W0
00968A  780080     MOV W0, W1
00968C  205A00     MOV #0x5A0, W0
00968E  408080     ADD W1, W0, W1
009690  90083E     MOV [W14+22], W0
009692  2003C2     MOV #0x3C, W2
009694  510000     SUB W2, W0, W0
009696  408000     ADD W1, W0, W0
009698  980740     MOV W0, [W14+8]
252:                       tmpi32 = ComputeDurationNextDaySchedule(tmpi, start_idx);
00969A  90004E     MOV [W14+8], W0
00969C  DE80CF     ASR W0, #15, W1
00969E  90012E     MOV [W14+4], W2
0096A0  0702A7     RCALL ComputeDurationNextDaySchedule
0096A2  980750     MOV W0, [W14+10]
0096A4  980761     MOV W1, [W14+12]
253:                       if (tmpi32 > 0)
0096A6  90005E     MOV [W14+10], W0
0096A8  9000EE     MOV [W14+12], W1
0096AA  500FE0     SUB W0, #0x0, [W15]
0096AC  588FE0     SUBB W1, #0x0, [W15]
0096AE  340005     BRA LE, .L22
254:                       {
255:                           i32DurationMins = tmpi32;
0096B0  90015E     MOV [W14+10], W2
0096B2  9001EE     MOV [W14+12], W3
0096B4  8846D2     MOV W2, i32DurationMins
0096B6  8846E3     MOV W3, 0x8DC
0096B8  37011C     BRA .L19
256:                       }
257:                       else 
258:                       {
259:                           // this should never happen with valid schedules, it it happens, wierd case, set it to 3 hours
260:                           i32DurationMins = 3 * 60;
0096BA  200B40     MOV #0xB4, W0
0096BC  200001     MOV #0x0, W1
0096BE  8846D0     MOV W0, i32DurationMins
0096C0  8846E1     MOV W1, 0x8DC
0096C2  370117     BRA .L19
261:                       }
262:                   }
263:                   else if (ii == 1)
0096C4  90003E     MOV [W14+6], W0
0096C6  500FE1     SUB W0, #0x1, [W15]
0096C8  3A0058     BRA NZ, .L24
264:                   {
265:                       /*
266:                       If current time is before schedule begins, then 
267:                           set CSP and HSP from an available previous schedule
268:                           set duration is from now to the only existing schedule
269:                       Else // implies current time is after or at the current schedule
270:                           set CSP and HSP from only existing schedule
271:                           set duration from now to next available schedule
272:                        */
273:                       tmpi = (curr_time.tm_hour * 60) + curr_time.tm_min;
0096CA  9008CE     MOV [W14+24], W1
0096CC  2003C0     MOV #0x3C, W0
0096CE  B98800     MUL.SS W1, W0, W0
0096D0  780080     MOV W0, W1
0096D2  90083E     MOV [W14+22], W0
0096D4  408000     ADD W1, W0, W0
0096D6  980740     MOV W0, [W14+8]
274:                       tmpj = (u8arrSchedule[start_idx]*60) + u8arrSchedule[start_idx + 1];
0096D8  21C231     MOV #0x1C23, W1
0096DA  90002E     MOV [W14+4], W0
0096DC  408000     ADD W1, W0, W0
0096DE  784010     MOV.B [W0], W0
0096E0  FB8080     ZE W0, W1
0096E2  2003C0     MOV #0x3C, W0
0096E4  B98800     MUL.SS W1, W0, W0
0096E6  780080     MOV W0, W1
0096E8  90002E     MOV [W14+4], W0
0096EA  E80000     INC W0, W0
0096EC  21C232     MOV #0x1C23, W2
0096EE  784062     MOV.B [W2+W0], W0
0096F0  FB8000     ZE W0, W0
0096F2  408F00     ADD W1, W0, [W14]
275:                       if (tmpi < tmpj)
0096F4  90004E     MOV [W14+8], W0
0096F6  500F9E     SUB W0, [W14], [W15]
0096F8  3D0016     BRA GE, .L25
276:                       {
277:                           tmpi = FindPreviousSchedule(start_idx);
0096FA  90002E     MOV [W14+4], W0
0096FC  07023E     RCALL FindPreviousSchedule
0096FE  980740     MOV W0, [W14+8]
278:                           if (tmpi > 0) // found valid schedule
009700  90004E     MOV [W14+8], W0
009702  E00000     CP0 W0
009704  34000A     BRA LE, .L26
279:                           {
280:                               u8NewCoolSetpoint = u8arrSchedule[tmpi+2];
009706  90004E     MOV [W14+8], W0
009708  E88000     INC2 W0, W0
00970A  21C231     MOV #0x1C23, W1
00970C  784061     MOV.B [W1+W0], W0
00970E  B7E8B6     MOV.B WREG, u8NewCoolSetpoint
281:                               u8NewHeatSetpoint = u8arrSchedule[tmpi+3];
009710  90004E     MOV [W14+8], W0
009712  400063     ADD W0, #0x3, W0
009714  21C231     MOV #0x1C23, W1
009716  784061     MOV.B [W1+W0], W0
009718  B7E8B9     MOV.B WREG, u8NewHeatSetpoint
282:                           }
283:                           i32DurationMins = tmpj - tmpi;
00971A  90004E     MOV [W14+8], W0
00971C  10001E     SUBR W0, [W14], W0
00971E  DE80CF     ASR W0, #15, W1
009720  8846D0     MOV W0, i32DurationMins
009722  8846E1     MOV W1, 0x8DC
009724  3700E6     BRA .L19
284:                       }
285:                       else
286:                       {
287:                           u8NewCoolSetpoint = u8arrSchedule[tmpi+2];
009726  90004E     MOV [W14+8], W0
009728  E88000     INC2 W0, W0
00972A  21C231     MOV #0x1C23, W1
00972C  784061     MOV.B [W1+W0], W0
00972E  B7E8B6     MOV.B WREG, u8NewCoolSetpoint
288:                           u8NewHeatSetpoint = u8arrSchedule[tmpi+3];
009730  90004E     MOV [W14+8], W0
009732  400063     ADD W0, #0x3, W0
009734  21C231     MOV #0x1C23, W1
009736  784061     MOV.B [W1+W0], W0
009738  B7E8B9     MOV.B WREG, u8NewHeatSetpoint
289:                           tmpi = (24-curr_time.tm_hour)*60 + (60-curr_time.tm_min);
00973A  9008CE     MOV [W14+24], W1
00973C  2FFC40     MOV #0xFFC4, W0
00973E  B98800     MUL.SS W1, W0, W0
009740  780080     MOV W0, W1
009742  205A00     MOV #0x5A0, W0
009744  408080     ADD W1, W0, W1
009746  90083E     MOV [W14+22], W0
009748  2003C2     MOV #0x3C, W2
00974A  510000     SUB W2, W0, W0
00974C  408000     ADD W1, W0, W0
00974E  980740     MOV W0, [W14+8]
290:                           tmpi32 = ComputeDurationNextDaySchedule(tmpi, start_idx);
009750  90004E     MOV [W14+8], W0
009752  DE80CF     ASR W0, #15, W1
009754  90012E     MOV [W14+4], W2
009756  07024C     RCALL ComputeDurationNextDaySchedule
009758  980750     MOV W0, [W14+10]
00975A  980761     MOV W1, [W14+12]
291:                           if (tmpi32 > 0)
00975C  90005E     MOV [W14+10], W0
00975E  9000EE     MOV [W14+12], W1
009760  500FE0     SUB W0, #0x0, [W15]
009762  588FE0     SUBB W1, #0x0, [W15]
009764  340005     BRA LE, .L27
292:                           {
293:                               i32DurationMins = tmpi32;
009766  90015E     MOV [W14+10], W2
009768  9001EE     MOV [W14+12], W3
00976A  8846D2     MOV W2, i32DurationMins
00976C  8846E3     MOV W3, 0x8DC
00976E  3700C1     BRA .L19
294:                           }
295:                           else 
296:                           {
297:                               // this should never happen with valid schedules, if it happens, wierd case, set it to 3 hours
298:                               i32DurationMins = 3 * 60;
009770  200B40     MOV #0xB4, W0
009772  200001     MOV #0x0, W1
009774  8846D0     MOV W0, i32DurationMins
009776  8846E1     MOV W1, 0x8DC
009778  3700BC     BRA .L19
299:                           }
300:                       }
301:                       
302:                   }
303:                   else 
304:                   {
305:                       // there can be 2 to 5 schedules
306:                       tmpi = (curr_time.tm_hour * 60) + curr_time.tm_min;
00977A  9008CE     MOV [W14+24], W1
00977C  2003C0     MOV #0x3C, W0
00977E  B98800     MUL.SS W1, W0, W0
009780  780080     MOV W0, W1
009782  90083E     MOV [W14+22], W0
009784  408000     ADD W1, W0, W0
009786  980740     MOV W0, [W14+8]
307:                       tmpj = (u8arrSchedule[start_idx]*60) + u8arrSchedule[start_idx + 1];
009788  21C231     MOV #0x1C23, W1
00978A  90002E     MOV [W14+4], W0
00978C  408000     ADD W1, W0, W0
00978E  784010     MOV.B [W0], W0
009790  FB8080     ZE W0, W1
009792  2003C0     MOV #0x3C, W0
009794  B98800     MUL.SS W1, W0, W0
009796  780080     MOV W0, W1
009798  90002E     MOV [W14+4], W0
00979A  E80000     INC W0, W0
00979C  21C232     MOV #0x1C23, W2
00979E  784062     MOV.B [W2+W0], W0
0097A0  FB8000     ZE W0, W0
0097A2  408F00     ADD W1, W0, [W14]
308:                       last_idx = start_idx + (ii-1) * 4;
0097A4  90003E     MOV [W14+6], W0
0097A6  E90000     DEC W0, W0
0097A8  DD00C2     SL W0, #2, W1
0097AA  90002E     MOV [W14+4], W0
0097AC  408000     ADD W1, W0, W0
0097AE  980770     MOV W0, [W14+14]
309:                       tmpk = (u8arrSchedule[last_idx]*60) + u8arrSchedule[last_idx + 1];
0097B0  21C231     MOV #0x1C23, W1
0097B2  90007E     MOV [W14+14], W0
0097B4  408000     ADD W1, W0, W0
0097B6  784010     MOV.B [W0], W0
0097B8  FB8080     ZE W0, W1
0097BA  2003C0     MOV #0x3C, W0
0097BC  B98800     MUL.SS W1, W0, W0
0097BE  780080     MOV W0, W1
0097C0  90007E     MOV [W14+14], W0
0097C2  E80000     INC W0, W0
0097C4  21C232     MOV #0x1C23, W2
0097C6  784062     MOV.B [W2+W0], W0
0097C8  FB8000     ZE W0, W0
0097CA  408000     ADD W1, W0, W0
0097CC  980F00     MOV W0, [W14+16]
310:                       if (tmpi < tmpj)
0097CE  90004E     MOV [W14+8], W0
0097D0  500F9E     SUB W0, [W14], [W15]
0097D2  3D0016     BRA GE, .L28
311:                       {
312:                           tmpi = FindPreviousSchedule(start_idx);
0097D4  90002E     MOV [W14+4], W0
0097D6  0701D1     RCALL FindPreviousSchedule
0097D8  980740     MOV W0, [W14+8]
313:                           if (tmpi > 0) // found valid schedule
0097DA  90004E     MOV [W14+8], W0
0097DC  E00000     CP0 W0
0097DE  34000A     BRA LE, .L29
314:                           {
315:                               u8NewCoolSetpoint = u8arrSchedule[tmpi+2];
0097E0  90004E     MOV [W14+8], W0
0097E2  E88000     INC2 W0, W0
0097E4  21C231     MOV #0x1C23, W1
0097E6  784061     MOV.B [W1+W0], W0
0097E8  B7E8B6     MOV.B WREG, u8NewCoolSetpoint
316:                               u8NewHeatSetpoint = u8arrSchedule[tmpi+3];
0097EA  90004E     MOV [W14+8], W0
0097EC  400063     ADD W0, #0x3, W0
0097EE  21C231     MOV #0x1C23, W1
0097F0  784061     MOV.B [W1+W0], W0
0097F2  B7E8B9     MOV.B WREG, u8NewHeatSetpoint
317:                           }
318:                           i32DurationMins = tmpj - tmpi;
0097F4  90004E     MOV [W14+8], W0
0097F6  10001E     SUBR W0, [W14], W0
0097F8  DE80CF     ASR W0, #15, W1
0097FA  8846D0     MOV W0, i32DurationMins
0097FC  8846E1     MOV W1, 0x8DC
0097FE  370079     BRA .L19
319:                       }
320:                       else if (tmpi >= tmpk)
009800  9000CE     MOV [W14+8], W1
009802  90080E     MOV [W14+16], W0
009804  508F80     SUB W1, W0, [W15]
009806  35002A     BRA LT, .L30
321:                       {
322:                           u8NewCoolSetpoint = u8arrSchedule[last_idx+2];
009808  90007E     MOV [W14+14], W0
00980A  E88000     INC2 W0, W0
00980C  21C231     MOV #0x1C23, W1
00980E  784061     MOV.B [W1+W0], W0
009810  B7E8B6     MOV.B WREG, u8NewCoolSetpoint
323:                           u8NewHeatSetpoint = u8arrSchedule[last_idx+3];
009812  90007E     MOV [W14+14], W0
009814  400063     ADD W0, #0x3, W0
009816  21C231     MOV #0x1C23, W1
009818  784061     MOV.B [W1+W0], W0
00981A  B7E8B9     MOV.B WREG, u8NewHeatSetpoint
324:                           tmpi = (24-curr_time.tm_hour)*60 + (60-curr_time.tm_min);
00981C  9008CE     MOV [W14+24], W1
00981E  2FFC40     MOV #0xFFC4, W0
009820  B98800     MUL.SS W1, W0, W0
009822  780080     MOV W0, W1
009824  205A00     MOV #0x5A0, W0
009826  408080     ADD W1, W0, W1
009828  90083E     MOV [W14+22], W0
00982A  2003C2     MOV #0x3C, W2
00982C  510000     SUB W2, W0, W0
00982E  408000     ADD W1, W0, W0
009830  980740     MOV W0, [W14+8]
325:                           tmpi32 = ComputeDurationNextDaySchedule(tmpi, start_idx);
009832  90004E     MOV [W14+8], W0
009834  DE80CF     ASR W0, #15, W1
009836  90012E     MOV [W14+4], W2
009838  0701DB     RCALL ComputeDurationNextDaySchedule
00983A  980750     MOV W0, [W14+10]
00983C  980761     MOV W1, [W14+12]
326:                           if (tmpi32 > 0)
00983E  90005E     MOV [W14+10], W0
009840  9000EE     MOV [W14+12], W1
009842  500FE0     SUB W0, #0x0, [W15]
009844  588FE0     SUBB W1, #0x0, [W15]
009846  340005     BRA LE, .L31
327:                           {
328:                               i32DurationMins = tmpi32;
009848  90015E     MOV [W14+10], W2
00984A  9001EE     MOV [W14+12], W3
00984C  8846D2     MOV W2, i32DurationMins
00984E  8846E3     MOV W3, 0x8DC
009850  370050     BRA .L19
329:                           }
330:                           else 
331:                           {
332:                               // this should never happen with valid schedules, if it happens, wierd case, set it to 2 hours
333:                               i32DurationMins = 3 * 60;
009852  200B40     MOV #0xB4, W0
009854  200001     MOV #0x0, W1
009856  8846D0     MOV W0, i32DurationMins
009858  8846E1     MOV W1, 0x8DC
00985A  37004B     BRA .L19
334:                           }
335:                           
336:                       }
337:                       else 
338:                       {
339:                           tmpj = start_idx;
00985C  9001AE     MOV [W14+4], W3
00985E  780F03     MOV W3, [W14]
340:                           while ( (tmpj < last_idx) && (!done) )
009860  370038     BRA .L32
0098D2  90007E     MOV [W14+14], W0
0098D4  78009E     MOV [W14], W1
0098D6  508F80     SUB W1, W0, [W15]
0098D8  3D0004     BRA GE, .L34
0098DA  90402E     MOV.B [W14+2], W0
0098DC  A20400     BTG.B W0, #0
0098DE  E00400     CP0.B W0
0098E0  3AFFC0     BRA NZ, .L35
341:                           {
342:                               tmpk = u8arrSchedule[tmpj]*60 + u8arrSchedule[tmpj+1]; // time for tmpj index (schedule)
009862  21C230     MOV #0x1C23, W0
009864  40001E     ADD W0, [W14], W0
009866  784010     MOV.B [W0], W0
009868  FB8080     ZE W0, W1
00986A  2003C0     MOV #0x3C, W0
00986C  B98800     MUL.SS W1, W0, W0
00986E  780080     MOV W0, W1
009870  E8001E     INC [W14], W0
009872  21C232     MOV #0x1C23, W2
009874  784062     MOV.B [W2+W0], W0
009876  FB8000     ZE W0, W0
009878  408000     ADD W1, W0, W0
00987A  980F00     MOV W0, [W14+16]
343:                               tmpl = u8arrSchedule[tmpj+4]*60 + u8arrSchedule[tmpj+4+1]; // time for next tmpj index (schedule))
00987C  78009E     MOV [W14], W1
00987E  408064     ADD W1, #0x4, W0
009880  21C231     MOV #0x1C23, W1
009882  784061     MOV.B [W1+W0], W0
009884  FB8080     ZE W0, W1
009886  2003C0     MOV #0x3C, W0
009888  B98800     MUL.SS W1, W0, W0
00988A  780080     MOV W0, W1
00988C  78011E     MOV [W14], W2
00988E  410065     ADD W2, #0x5, W0
009890  21C232     MOV #0x1C23, W2
009892  784062     MOV.B [W2+W0], W0
009894  FB8000     ZE W0, W0
009896  408000     ADD W1, W0, W0
009898  980F10     MOV W0, [W14+18]
344:                               if ( (tmpi >= tmpk) && (tmpi < tmpl) )
00989A  9000CE     MOV [W14+8], W1
00989C  90080E     MOV [W14+16], W0
00989E  508F80     SUB W1, W0, [W15]
0098A0  350016     BRA LT, .L33
0098A2  9000CE     MOV [W14+8], W1
0098A4  90081E     MOV [W14+18], W0
0098A6  508F80     SUB W1, W0, [W15]
0098A8  3D0012     BRA GE, .L33
345:                               {
346:                                   u8NewCoolSetpoint = u8arrSchedule[tmpk+2];
0098AA  90080E     MOV [W14+16], W0
0098AC  E88000     INC2 W0, W0
0098AE  21C231     MOV #0x1C23, W1
0098B0  784061     MOV.B [W1+W0], W0
0098B2  B7E8B6     MOV.B WREG, u8NewCoolSetpoint
347:                                   u8NewHeatSetpoint = u8arrSchedule[tmpk+3];
0098B4  90080E     MOV [W14+16], W0
0098B6  400063     ADD W0, #0x3, W0
0098B8  21C231     MOV #0x1C23, W1
0098BA  784061     MOV.B [W1+W0], W0
0098BC  B7E8B9     MOV.B WREG, u8NewHeatSetpoint
348:                                   i32DurationMins = tmpl - tmpi;
0098BE  90089E     MOV [W14+18], W1
0098C0  90004E     MOV [W14+8], W0
0098C2  508000     SUB W1, W0, W0
0098C4  DE80CF     ASR W0, #15, W1
0098C6  8846D0     MOV W0, i32DurationMins
0098C8  8846E1     MOV W1, 0x8DC
349:                                   done = true;
0098CA  B3C010     MOV.B #0x1, W0
0098CC  984720     MOV.B W0, [W14+2]
350:                               }
351:                               tmpj += 4;
0098CE  78019E     MOV [W14], W3
0098D0  418F64     ADD W3, #0x4, [W14]
352:                           }
353:                           if (done == false)
0098E2  90402E     MOV.B [W14+2], W0
0098E4  A20400     BTG.B W0, #0
0098E6  E00400     CP0.B W0
0098E8  320004     BRA Z, .L19
354:                           {
355:                               // data in schedule could be wrong
356:                               // keep the current set points
357:                               // set the duration to 3 hours
358:                               i32DurationMins = 60*3;
0098EA  200B40     MOV #0xB4, W0
0098EC  200001     MOV #0x0, W1
0098EE  8846D0     MOV W0, i32DurationMins
0098F0  8846E1     MOV W1, 0x8DC
359:                           }
360:                       }
361:                   }
362:                   
363:               }
0098F2  FA8000     ULNK
0098F4  060000     RETURN
364:               
365:               void ReadParametersFromFRAM()
366:               {
0098F6  FA0002     LNK #0x2
367:                   // TODO: Implement the perameters that need to be read from FRAM on power up/ battery change
368:                   // if RTCC is set, 
369:                   //      if u8Schedule is home, read the schedule from FRAM, else use default values
370:                   //      else u8Schedule is Away, read the setpoints from FRAM, and set them up
371:                   // if setpoints are not in range, check and set them up appropriately
372:                   uint8_t tmpu8;
373:                   ReadRTCInitializedMemory();
0098F8  07E9E1     RCALL ReadRTCInitializedMemory
374:                   if (rtccTimeInitialized == true)
0098FA  BFC90C     MOV.B rtccTimeInitialized, WREG
0098FC  E00400     CP0.B W0
0098FE  32000E     BRA Z, .L36
375:                   {
376:                       // if schedule is SCHEDULE_AWAY, the u8CoolSetpoint and u8HeatSetpoint 
377:                       //  are already set by the ReadSchedule() function as it is 
378:                       //  read from FRAM
379:                       if (u8Schedule == SCHEDULE_HOME)
009900  BFC8D6     MOV.B u8Schedule, WREG
009902  504FE1     SUB.B W0, #0x1, [W15]
009904  3A0007     BRA NZ, .L38
380:                       {
381:                           // need to read and populate 
382:                           tmpu8 = ScheduleAvailable();
009906  07F4D6     RCALL ScheduleAvailable
009908  784F00     MOV.B W0, [W14]
383:                           if (tmpu8 == 1)
00990A  78401E     MOV.B [W14], W0
00990C  504FE1     SUB.B W0, #0x1, [W15]
00990E  3A0006     BRA NZ, .L36
384:                           {
385:                               // schedule is available in FRAM, read and populate it based on 
386:                               // current time
387:                               SetScheduleForNow();
009910  07FE98     RCALL SetScheduleForNow
009912  370004     BRA .L36
388:                           }
389:                       }
390:                       else if (u8Schedule == SCHEDULE_DREVENT)
009914  BFC8D6     MOV.B u8Schedule, WREG
009916  504FE3     SUB.B W0, #0x3, [W15]
009918  3A0001     BRA NZ, .L36
391:                       {
392:                           ReadDRSchedule();
00991A  07EC91     RCALL ReadDRSchedule
393:                       }
394:                   }
395:               }
00991C  FA8000     ULNK
00991E  060000     RETURN
396:               
397:               
398:               /**
399:                * Initialize variables for first time initialization
400:                * 
401:                */
402:               void Application_Initialize(void) 
403:               {
009920  FA0002     LNK #0x2
404:                   uint8_t data;
405:                   data = ReadBuffersInitialized();
009922  07ED8A     RCALL ReadBuffersInitialized
009924  784F00     MOV.B W0, [W14]
406:                   if (data == (uint8_t)BufferInitializedWriteValue)
009926  B3C6D0     MOV.B #0x6D, W0
009928  78409E     MOV.B [W14], W1
00992A  50CF80     SUB.B W1, W0, [W15]
00992C  3A0014     BRA NZ, .L40
407:                   {
408:                       ReadThermostatMode();
00992E  07EABC     RCALL ReadThermostatMode
409:                       if ( (u8ThermostatMode < (uint8_t)MODE_HEAT_ONLY ) || ( u8ThermostatMode > (uint8_t)MODE_HEATCOOL ) )
009930  BFC8BE     MOV.B u8ThermostatMode, WREG
009932  E00400     CP0.B W0
009934  320003     BRA Z, .L41
009936  BFC8BE     MOV.B u8ThermostatMode, WREG
009938  504FE3     SUB.B W0, #0x3, [W15]
00993A  360002     BRA LEU, .L42
410:                       {
411:                           // default value is heat and cool
412:                           u8ThermostatMode = (uint8_t) MODE_HEATCOOL;
00993C  B3C030     MOV.B #0x3, W0
00993E  B7E8BE     MOV.B WREG, u8ThermostatMode
413:                       }
414:                       
415:                       
416:                       ReadHysteresis();
009940  07EA9B     RCALL ReadHysteresis
417:                       if ( (u8Hysteresis > 4) || (u8Hysteresis < 1) ) {
009942  BFC8BB     MOV.B u8Hysteresis, WREG
009944  504FE4     SUB.B W0, #0x4, [W15]
009946  3E0003     BRA GTU, .L43
009948  BFC8BB     MOV.B u8Hysteresis, WREG
00994A  E00400     CP0.B W0
00994C  3A0002     BRA NZ, .L44
418:                           u8Hysteresis = 1;
00994E  B3C010     MOV.B #0x1, W0
009950  B7E8BB     MOV.B WREG, u8Hysteresis
419:                       }
420:                       u8TimerMinutesToOff = 0;
009952  EF68C3     CLR.B u8TimerMinutesToOff
009954  370004     BRA .L45
421:                   }
422:                   else
423:                   {
424:                       // default values
425:                       u8ThermostatMode = (uint8_t) MODE_HEATCOOL;
009956  B3C030     MOV.B #0x3, W0
009958  B7E8BE     MOV.B WREG, u8ThermostatMode
426:                       u8Hysteresis = 1;
00995A  B3C010     MOV.B #0x1, W0
00995C  B7E8BB     MOV.B WREG, u8Hysteresis
427:                   }
428:                   u8TimerMinutesToOff = 0;
00995E  EF68C3     CLR.B u8TimerMinutesToOff
429:                   u8CoolSetpoint = (uint8_t) COOL_SETPOINT_DEFAULT_DEGF;
009960  B3C4E0     MOV.B #0x4E, W0
009962  B7E8B5     MOV.B WREG, u8CoolSetpoint
430:                   u8NewCoolSetpoint = COOL_SETPOINT_DEFAULT_DEGF;
009964  B3C4E0     MOV.B #0x4E, W0
009966  B7E8B6     MOV.B WREG, u8NewCoolSetpoint
431:                   u8SchNoneCoolSetpoint = COOL_SETPOINT_DEFAULT_DEGF;
009968  B3C4E0     MOV.B #0x4E, W0
00996A  B7E8B7     MOV.B WREG, u8SchNoneCoolSetpoint
432:                   u8HeatSetpoint = (uint8_t) HEAT_SETPOINT_DEFAULT_DEGF;
00996C  B3C440     MOV.B #0x44, W0
00996E  B7E8B8     MOV.B WREG, u8HeatSetpoint
433:                   u8NewHeatSetpoint = HEAT_SETPOINT_DEFAULT_DEGF;
009970  B3C440     MOV.B #0x44, W0
009972  B7E8B9     MOV.B WREG, u8NewHeatSetpoint
434:                   u8SchNoneHeatSetpoint = HEAT_SETPOINT_DEFAULT_DEGF;
009974  B3C440     MOV.B #0x44, W0
009976  B7E8BA     MOV.B WREG, u8SchNoneHeatSetpoint
435:                   // default in none
436:                   // algorithm will set it up to heat/ cool
437:                   u8CurrentThermostatAction = (uint8_t) ACTION_NONE;
009978  B3C030     MOV.B #0x3, W0
00997A  B7E8C2     MOV.B WREG, u8CurrentThermostatAction
438:                   u8ApplicationState = (uint8_t)APP_STATE_ON;
00997C  B3C010     MOV.B #0x1, W0
00997E  B7E8B4     MOV.B WREG, u8ApplicationState
439:                   u16PartialScreenUpdateCount = 0;
009980  EF28BC     CLR u16PartialScreenUpdateCount
440:                   u8TimerOnScreen = 0;
009982  EF68C8     CLR.B u8TimerOnScreen
441:                   u8TempArr[0]=0;
009984  21CB70     MOV #0x1CB7, W0
009986  EB4080     CLR.B W1
009988  784801     MOV.B W1, [W0]
442:                   u8TempArr[1]=0;
00998A  21CB80     MOV #0x1CB8, W0
00998C  EB4080     CLR.B W1
00998E  784801     MOV.B W1, [W0]
443:                   u8TempArr[2]=0;
009990  21CB90     MOV #0x1CB9, W0
009992  EB4080     CLR.B W1
009994  784801     MOV.B W1, [W0]
444:                   u8TempArr[3]=0;
009996  21CBA0     MOV #0x1CBA, W0
009998  EB4080     CLR.B W1
00999A  784801     MOV.B W1, [W0]
445:                   u8TempArr[4]=0;
00999C  21CBB0     MOV #0x1CBB, W0
00999E  EB4080     CLR.B W1
0099A0  784801     MOV.B W1, [W0]
446:                   u8TempSum = 0;
0099A2  EF28CA     CLR u8TempSum
447:                   u8TempAvg = 0.0;
0099A4  B80060     MUL.UU W0, #0, W0
0099A6  884660     MOV W0, u8TempAvg
0099A8  884671     MOV W1, 0x8CE
448:                   u8TempArrIndex = 0;
0099AA  EF28D0     CLR u8TempArrIndex
449:                   u8TempArrCount = 0;
0099AC  EF28D2     CLR u8TempArrCount
450:                   u8RelativeHumidity = 0;
0099AE  EF68D4     CLR.B u8RelativeHumidity
451:                   u8Schedule = SCHEDULE_NONE;
0099B0  B3C040     MOV.B #0x4, W0
0099B2  B7E8D6     MOV.B WREG, u8Schedule
452:                   u8GotoSchedule = 0xFF;
0099B4  EBC000     SETM.B W0
0099B6  B7E8D8     MOV.B WREG, u8GotoSchedule
453:                   
454:               }
0099B8  FA8000     ULNK
0099BA  060000     RETURN
455:               
456:               void Heat_off(void)
457:               {
0099BC  FA0000     LNK #0x0
458:                   HEAT_RESET_SetHigh();
0099BE  A8669E     BSET LATD, #3
459:                   __delay_ms(100);
0099C0  26A000     MOV #0x6A00, W0
0099C2  200181     MOV #0x18, W1
0099C4  071B06     RCALL ___delay32, .Letext0, .LFE18
460:                   HEAT_RESET_SetLow();
0099C6  A9669E     BCLR LATD, #3
461:               }
0099C8  FA8000     ULNK
0099CA  060000     RETURN
462:               
463:               void Heat_on(void)
464:               {
0099CC  FA0000     LNK #0x0
465:                   HEAT_SET_SetHigh();
0099CE  A8E677     BSET 0x677, #7
466:                   __delay_ms(100);
0099D0  26A000     MOV #0x6A00, W0
0099D2  200181     MOV #0x18, W1
0099D4  071AFE     RCALL ___delay32, .Letext0, .LFE18
467:                   HEAT_SET_SetLow();
0099D6  A9E677     BCLR 0x677, #7
468:               }
0099D8  FA8000     ULNK
0099DA  060000     RETURN
469:               
470:               void Cool_off(void) 
471:               {
0099DC  FA0000     LNK #0x0
472:                   COOL_RESET_SetHigh();
0099DE  A8C69E     BSET LATD, #6
473:                   __delay_ms(100);
0099E0  26A000     MOV #0x6A00, W0
0099E2  200181     MOV #0x18, W1
0099E4  071AF6     RCALL ___delay32, .Letext0, .LFE18
474:                   COOL_RESET_SetLow();
0099E6  A9C69E     BCLR LATD, #6
475:               }
0099E8  FA8000     ULNK
0099EA  060000     RETURN
476:               
477:               void Cool_on(void)
478:               {
0099EC  FA0000     LNK #0x0
479:                   COOL_SET_SetHigh();
0099EE  A8869E     BSET LATD, #4
480:                   __delay_ms(100);
0099F0  26A000     MOV #0x6A00, W0
0099F2  200181     MOV #0x18, W1
0099F4  071AEE     RCALL ___delay32, .Letext0, .LFE18
481:                   COOL_SET_SetLow();
0099F6  A9869E     BCLR LATD, #4
482:               }
0099F8  FA8000     ULNK
0099FA  060000     RETURN
483:               
484:               void Fan_off(void)
485:               {
0099FC  FA0000     LNK #0x0
486:                   FAN_RESET_SetHigh();
0099FE  A8069F     BSET 0x69F, #0
487:                   __delay_ms(100);
009A00  26A000     MOV #0x6A00, W0
009A02  200181     MOV #0x18, W1
009A04  071AE6     RCALL ___delay32, .Letext0, .LFE18
488:                   FAN_RESET_SetLow();
009A06  A9069F     BCLR 0x69F, #0
489:               }
009A08  FA8000     ULNK
009A0A  060000     RETURN
490:               
491:               void Fan_on(void)
492:               {
009A0C  FA0000     LNK #0x0
493:                   FAN_SET_SetHigh();
009A0E  A8E69E     BSET LATD, #7
494:                   __delay_ms(100);
009A10  26A000     MOV #0x6A00, W0
009A12  200181     MOV #0x18, W1
009A14  071ADE     RCALL ___delay32, .Letext0, .LFE18
495:                   FAN_SET_SetLow();
009A16  A9E69E     BCLR LATD, #7
496:               }
009A18  FA8000     ULNK
009A1A  060000     RETURN
497:               
498:               uint8_t Temperature_average(uint8_t current_read_temperature)
499:               {
009A1C  FA0004     LNK #0x4
009A1E  BE9F88     MOV.D W8, [W15++]
009A20  984720     MOV.B W0, [W14+2]
500:                   uint8_t tmpu8;
501:                   u8TempSum = u8TempSum - u8TempArr[u8TempArrIndex];
009A22  804651     MOV u8TempSum, W1
009A24  804680     MOV u8TempArrIndex, W0
009A26  21CB72     MOV #0x1CB7, W2
009A28  784062     MOV.B [W2+W0], W0
009A2A  FB8000     ZE W0, W0
009A2C  508000     SUB W1, W0, W0
009A2E  884650     MOV W0, u8TempSum
502:                   
503:                   u8TempArr[u8TempArrIndex] = current_read_temperature;
009A30  804680     MOV u8TempArrIndex, W0
009A32  21CB71     MOV #0x1CB7, W1
009A34  90412E     MOV.B [W14+2], W2
009A36  787082     MOV.B W2, [W1+W0]
504:                   u8TempSum = u8TempSum + current_read_temperature;
009A38  90402E     MOV.B [W14+2], W0
009A3A  FB8080     ZE W0, W1
009A3C  804650     MOV u8TempSum, W0
009A3E  408000     ADD W1, W0, W0
009A40  884650     MOV W0, u8TempSum
505:                   u8TempArrIndex ++;
009A42  804680     MOV u8TempArrIndex, W0
009A44  E80000     INC W0, W0
009A46  884680     MOV W0, u8TempArrIndex
506:                   if (u8TempArrIndex >= TEMPERATURE_AVERAGE_MAX_ELEMENTS)
009A48  804680     MOV u8TempArrIndex, W0
009A4A  500FE4     SUB W0, #0x4, [W15]
009A4C  340001     BRA LE, .L53
507:                   {
508:                       u8TempArrIndex = 0;
009A4E  EF28D0     CLR u8TempArrIndex
509:                   }
510:                   if (u8TempArrCount < TEMPERATURE_AVERAGE_MAX_ELEMENTS)
009A50  804690     MOV u8TempArrCount, W0
009A52  500FE4     SUB W0, #0x4, [W15]
009A54  3C0003     BRA GT, .L54
511:                   {
512:                       u8TempArrCount++;
009A56  804690     MOV u8TempArrCount, W0
009A58  E80000     INC W0, W0
009A5A  884690     MOV W0, u8TempArrCount
513:                   }
514:                   u8TempAvg = (float) ( (1.0 * u8TempSum) / u8TempArrCount);
009A5C  804650     MOV u8TempSum, W0
009A5E  DE80CF     ASR W0, #15, W1
009A60  07B5AB     RCALL ___floatsisf
009A62  BE0400     MOV.D W0, W8
009A64  804690     MOV u8TempArrCount, W0
009A66  DE80CF     ASR W0, #15, W1
009A68  07B5A7     RCALL ___floatsisf
009A6A  BE0100     MOV.D W0, W2
009A6C  BE0008     MOV.D W8, W0
009A6E  07B513     RCALL ___divsf3
009A70  884660     MOV W0, u8TempAvg
009A72  884671     MOV W1, 0x8CE
515:                   tmpu8 = (uint8_t)(u8TempAvg);
009A74  804660     MOV u8TempAvg, W0
009A76  804671     MOV 0x8CE, W1
009A78  07B584     RCALL ___fixunssfsi
009A7A  784F00     MOV.B W0, [W14]
516:                   return tmpu8;
009A7C  78401E     MOV.B [W14], W0
517:               }
009A7E  BE044F     MOV.D [--W15], W8
009A80  FA8000     ULNK
009A82  060000     RETURN
518:               
519:               /**
520:                * Actions to be taken on entry to SCHEDULE_NONE state
521:                */
522:               void OnEntryScheduleNone()
523:               {
009A84  FA0000     LNK #0x0
524:                   u8NewCoolSetpoint = u8SchNoneCoolSetpoint;
009A86  BFC8B7     MOV.B u8SchNoneCoolSetpoint, WREG
009A88  B7E8B6     MOV.B WREG, u8NewCoolSetpoint
525:                   u8NewHeatSetpoint = u8SchNoneHeatSetpoint;
009A8A  BFC8BA     MOV.B u8SchNoneHeatSetpoint, WREG
009A8C  B7E8B9     MOV.B WREG, u8NewHeatSetpoint
526:               }
009A8E  FA8000     ULNK
009A90  060000     RETURN
527:               
528:               /**
529:                * Actions to be taken on exiting the SCHEDULE_NONE state
530:                */
531:               void OnExitScheduleNone()
532:               {
009A92  FA0000     LNK #0x0
533:                   u8SchNoneCoolSetpoint = u8CoolSetpoint;
009A94  BFC8B5     MOV.B u8CoolSetpoint, WREG
009A96  B7E8B7     MOV.B WREG, u8SchNoneCoolSetpoint
534:                   u8SchNoneHeatSetpoint = u8HeatSetpoint;
009A98  BFC8B8     MOV.B u8HeatSetpoint, WREG
009A9A  B7E8BA     MOV.B WREG, u8SchNoneHeatSetpoint
535:               }
009A9C  FA8000     ULNK
009A9E  060000     RETURN
536:               
537:               void DuringScheduleNone()
538:               {
009AA0  FA0000     LNK #0x0
539:                   
540:               }
009AA2  FA8000     ULNK
009AA4  060000     RETURN
541:               
542:               /**
543:                * Actions to be taken on entering the SCHEDULE_HOME state
544:                */
545:               void OnEntryScheduleHome()
546:               {
009AA6  FA0000     LNK #0x0
547:                   i32DurationMins = -1;
009AA8  EB8000     SETM W0
009AAA  EB8080     SETM W1
009AAC  8846D0     MOV W0, i32DurationMins
009AAE  8846E1     MOV W1, 0x8DC
548:               }
009AB0  FA8000     ULNK
009AB2  060000     RETURN
549:               
550:               void OnExitScheduleHome()
551:               {
009AB4  FA0000     LNK #0x0
552:                   // nothing needs to be done here
553:               }
009AB6  FA8000     ULNK
009AB8  060000     RETURN
554:               
555:               void DuringScheduleHome()
556:               {
009ABA  FA0000     LNK #0x0
557:                   if (i32DurationMins == -1)
009ABC  8046D2     MOV i32DurationMins, W2
009ABE  8046E3     MOV 0x8DC, W3
009AC0  EB8000     SETM W0
009AC2  EB8080     SETM W1
009AC4  510F80     SUB W2, W0, [W15]
009AC6  598F81     SUBB W3, W1, [W15]
009AC8  3A0001     BRA NZ, .L60
558:                   {
559:                       SetScheduleForNow();
009ACA  07FDBB     RCALL SetScheduleForNow
560:                   }
561:               }
009ACC  FA8000     ULNK
009ACE  060000     RETURN
562:               
563:               
564:               void OnEntryScheduleDREvent()
565:               {
009AD0  FA0002     LNK #0x2
566:                   uint8_t tmpu8;
567:                   u8PrevSchedule = u8Schedule;
009AD2  BFC8D6     MOV.B u8Schedule, WREG
009AD4  B7E8D7     MOV.B WREG, u8PrevSchedule
568:                   u8NewCoolSetpoint = FRAMReadByte(memLocScheduleStart + 5 + 7*20 + 7, 0);
009AD6  EB4100     CLR.B W2
009AD8  200B10     MOV #0xB1, W0
009ADA  200001     MOV #0x0, W1
009ADC  0716D8     RCALL FRAMReadByte
009ADE  B7E8B6     MOV.B WREG, u8NewCoolSetpoint
569:                   u8NewHeatSetpoint = FRAMReadByte(memLocScheduleStart + 5 + 7 * 20 + 6, 0);
009AE0  EB4100     CLR.B W2
009AE2  200B00     MOV #0xB0, W0
009AE4  200001     MOV #0x0, W1
009AE6  0716D3     RCALL FRAMReadByte
009AE8  B7E8B9     MOV.B WREG, u8NewHeatSetpoint
570:                   tmpu8 = FRAMReadByte(memLocScheduleStart + 5 + 7 * 20 + 4, 0);
009AEA  EB4100     CLR.B W2
009AEC  200AE0     MOV #0xAE, W0
009AEE  200001     MOV #0x0, W1
009AF0  0716CE     RCALL FRAMReadByte
009AF2  784F00     MOV.B W0, [W14]
571:                   i32DurationMins = tmpu8*60;
009AF4  FB809E     ZE [W14], W1
009AF6  2003C0     MOV #0x3C, W0
009AF8  B98800     MUL.SS W1, W0, W0
009AFA  780000     MOV W0, W0
009AFC  DE80CF     ASR W0, #15, W1
009AFE  8846D0     MOV W0, i32DurationMins
009B00  8846E1     MOV W1, 0x8DC
572:                   tmpu8 = FRAMReadByte(memLocScheduleStart + 5 + 7 * 20 + 5, 0);
009B02  EB4100     CLR.B W2
009B04  200AF0     MOV #0xAF, W0
009B06  200001     MOV #0x0, W1
009B08  0716C2     RCALL FRAMReadByte
009B0A  784F00     MOV.B W0, [W14]
573:                   i32DurationMins += tmpu8;
009B0C  FB811E     ZE [W14], W2
009B0E  EB0180     CLR W3
009B10  8046D0     MOV i32DurationMins, W0
009B12  8046E1     MOV 0x8DC, W1
009B14  400002     ADD W0, W2, W0
009B16  488083     ADDC W1, W3, W1
009B18  8846D0     MOV W0, i32DurationMins
009B1A  8846E1     MOV W1, 0x8DC
574:               }
009B1C  FA8000     ULNK
009B1E  060000     RETURN
575:               
576:               void OnExitScheduleDREvent()
577:               {
009B20  FA0000     LNK #0x0
578:                   u8GotoSchedule = u8PrevSchedule;
009B22  BFC8D7     MOV.B u8PrevSchedule, WREG
009B24  B7E8D8     MOV.B WREG, u8GotoSchedule
579:                   ClearDRSchedule();
009B26  07EBC8     RCALL ClearDRSchedule
580:               }
009B28  FA8000     ULNK
009B2A  060000     RETURN
581:               
582:               
583:               void DuringScheduleDREvent()
584:               {
009B2C  FA0000     LNK #0x0
585:                   if (i32DurationMins > 0)
009B2E  8046D0     MOV i32DurationMins, W0
009B30  8046E1     MOV 0x8DC, W1
009B32  500FE0     SUB W0, #0x0, [W15]
009B34  588FE0     SUBB W1, #0x0, [W15]
009B36  34000C     BRA LE, .L64
586:                   {
587:                       i32DurationMins -= 1;
009B38  8046D0     MOV i32DurationMins, W0
009B3A  8046E1     MOV 0x8DC, W1
009B3C  500061     SUB W0, #0x1, W0
009B3E  5880E0     SUBB W1, #0x0, W1
009B40  8846D0     MOV W0, i32DurationMins
009B42  8846E1     MOV W1, 0x8DC
588:                       if (i32DurationMins < 0)
009B44  8046D0     MOV i32DurationMins, W0
009B46  8046E1     MOV 0x8DC, W1
009B48  500FE0     SUB W0, #0x0, [W15]
009B4A  588FE0     SUBB W1, #0x0, [W15]
009B4C  3D0001     BRA GE, .L64
589:                       {
590:                           OnExitScheduleDREvent();
009B4E  07FFE8     RCALL OnExitScheduleDREvent
591:                       }
592:                   }
593:               }
009B50  FA8000     ULNK
009B52  060000     RETURN
594:               
595:               void OnEntryScheduleAway()
596:               {
009B54  FA0000     LNK #0x0
597:                   u8PrevThermostatMode = u8ThermostatMode;
009B56  BFC8BE     MOV.B u8ThermostatMode, WREG
009B58  B7E8BF     MOV.B WREG, u8PrevThermostatMode
598:                   u8ThermostatMode = u8AwayThermostatMode;
009B5A  BFC8DE     MOV.B u8AwayThermostatMode, WREG
009B5C  B7E8BE     MOV.B WREG, u8ThermostatMode
599:                   u8NewHeatSetpoint = u8AwayHeatSetpoint;
009B5E  BFC8DF     MOV.B u8AwayHeatSetpoint, WREG
009B60  B7E8B9     MOV.B WREG, u8NewHeatSetpoint
600:                   u8NewCoolSetpoint = u8AwayCoolSetpoint;
009B62  BFC8E0     MOV.B u8AwayCoolSetpoint, WREG
009B64  B7E8B6     MOV.B WREG, u8NewCoolSetpoint
601:               }
009B66  FA8000     ULNK
009B68  060000     RETURN
602:               
603:               void OnExitScheduleAway()
604:               {
009B6A  FA0000     LNK #0x0
605:                   u8ThermostatMode = u8PrevThermostatMode;
009B6C  BFC8BF     MOV.B u8PrevThermostatMode, WREG
009B6E  B7E8BE     MOV.B WREG, u8ThermostatMode
606:               }
009B70  FA8000     ULNK
009B72  060000     RETURN
607:               
608:               void DuringScheduleAway()
609:               {
009B74  FA0000     LNK #0x0
610:                   // nothing needs to be done for now
611:               }
009B76  FA8000     ULNK
009B78  060000     RETURN
612:               
613:               /**
614:                * 
615:                * @param start_idx: start search backwards at this point
616:                * @return index of a valid prevous schedule, or
617:                *        -1 if no valid schedule
618:                */
619:               int FindPreviousSchedule(int start_idx)
620:               {
009B7A  FA0006     LNK #0x6
009B7C  980720     MOV W0, [W14+4]
621:                   int tmpi, tmpj;
622:                   tmpj = 0;
009B7E  EB0000     CLR W0
009B80  980710     MOV W0, [W14+2]
623:                   tmpi = start_idx;
009B82  9000AE     MOV [W14+4], W1
009B84  780F01     MOV W1, [W14]
624:                   while (tmpj == 0)
009B86  370026     BRA .L70
009BD4  90001E     MOV [W14+2], W0
009BD6  E00000     CP0 W0
009BD8  32FFD7     BRA Z, .L74
009BDA  370001     BRA .L73
625:                   {
626:                       tmpi = tmpi - 4;
009B88  78009E     MOV [W14], W1
009B8A  508F64     SUB W1, #0x4, [W14]
627:                       if (tmpi < 0)
009B8C  78001E     MOV [W14], W0
009B8E  E00000     CP0 W0
009B90  3D0002     BRA GE, .L71
628:                       {
629:                           tmpi = tmpi + 140;
009B92  2008C1     MOV #0x8C, W1
009B94  408F1E     ADD W1, [W14], [W14]
630:                       }
631:                       if (tmpi != start_idx)
009B96  90002E     MOV [W14+4], W0
009B98  78009E     MOV [W14], W1
009B9A  508F80     SUB W1, W0, [W15]
009B9C  32001F     BRA Z, .L77
632:                       {
633:                           tmpj = u8arrSchedule[tmpi];
009B9E  21C230     MOV #0x1C23, W0
009BA0  40001E     ADD W0, [W14], W0
009BA2  784010     MOV.B [W0], W0
009BA4  FB8000     ZE W0, W0
009BA6  980710     MOV W0, [W14+2]
634:                           tmpj += u8arrSchedule[tmpi+1];
009BA8  E8001E     INC [W14], W0
009BAA  21C231     MOV #0x1C23, W1
009BAC  784061     MOV.B [W1+W0], W0
009BAE  FB8000     ZE W0, W0
009BB0  90009E     MOV [W14+2], W1
009BB2  408000     ADD W1, W0, W0
009BB4  980710     MOV W0, [W14+2]
635:                           tmpj += u8arrSchedule[tmpi+2];
009BB6  E8801E     INC2 [W14], W0
009BB8  21C231     MOV #0x1C23, W1
009BBA  784061     MOV.B [W1+W0], W0
009BBC  FB8000     ZE W0, W0
009BBE  90009E     MOV [W14+2], W1
009BC0  408000     ADD W1, W0, W0
009BC2  980710     MOV W0, [W14+2]
636:                           tmpj += u8arrSchedule[tmpi+3];
009BC4  78009E     MOV [W14], W1
009BC6  408063     ADD W1, #0x3, W0
009BC8  21C231     MOV #0x1C23, W1
009BCA  784061     MOV.B [W1+W0], W0
009BCC  FB8000     ZE W0, W0
009BCE  90009E     MOV [W14+2], W1
009BD0  408000     ADD W1, W0, W0
009BD2  980710     MOV W0, [W14+2]
637:                       }
638:                       else
639:                       {
640:                           break;
009BDC  000000     NOP
641:                       }
642:                   }
643:                   if (tmpi == start_idx)
009BDE  90002E     MOV [W14+4], W0
009BE0  78009E     MOV [W14], W1
009BE2  508F80     SUB W1, W0, [W15]
009BE4  3A0002     BRA NZ, .L75
644:                   {
645:                       return -1;
009BE6  EB8000     SETM W0
009BE8  370001     BRA .L76
646:                   }
647:                   else 
648:                   {
649:                       return tmpi;
009BEA  78001E     MOV [W14], W0
650:                   }
651:               }
009BEC  FA8000     ULNK
009BEE  060000     RETURN
652:               
653:               /**
654:                * Find the duration to the next valid schedule which happens to be
655:                *    on the next day(s)
656:                * @param partial_mins : amount of minutes left in today's time
657:                * @param start_idx : index of wday(0-6) in the schedule array where 
658:                *      the current processing is happening. So start searching for the next 
659:                *      schedule starting at start_idx + 20, and ending at start_idx - 4
660:                * @return duration in minutes that include the value of partial_mins if a valid schedule is found
661:                *      return -1 if no valid schedule is found
662:                */
663:               int32_t ComputeDurationNextDaySchedule(int32_t partial_mins, int start_idx)
664:               {
009BF0  FA000E     LNK #0xE
009BF2  980740     MOV W0, [W14+8]
009BF4  980751     MOV W1, [W14+10]
009BF6  980762     MOV W2, [W14+12]
665:                   int32_t tmpi32;
666:                   int tmpi, tmpj;
667:                   tmpi32 = partial_mins;
009BF8  90014E     MOV [W14+8], W2
009BFA  9001DE     MOV [W14+10], W3
009BFC  BE8F02     MOV.D W2, [W14]
668:                   tmpi = (start_idx + 20 ) % 140; 
009BFE  90006E     MOV [W14+12], W0
009C00  4000F4     ADD W0, #0x14, W1
009C02  2008C0     MOV #0x8C, W0
009C04  780180     MOV W0, W3
009C06  090011     REPEAT #0x11
009C08  D80083     DIV.SW W1, W3
009C0A  FD0080     EXCH W0, W1
009C0C  980720     MOV W0, [W14+4]
669:                   
670:                   while (tmpj == 0)
009C0E  370036     BRA .L79
009C7C  90003E     MOV [W14+6], W0
009C7E  E00000     CP0 W0
009C80  32FFC7     BRA Z, .L83
009C82  370001     BRA .L82
671:                   {
672:                       tmpi = (tmpi + 4) % 140;
009C10  90002E     MOV [W14+4], W0
009C12  4000E4     ADD W0, #0x4, W1
009C14  2008C0     MOV #0x8C, W0
009C16  780100     MOV W0, W2
009C18  090011     REPEAT #0x11
009C1A  D80082     DIV.SW W1, W2
009C1C  FD0080     EXCH W0, W1
009C1E  980720     MOV W0, [W14+4]
673:                       if (tmpi % 20 == 0)
009C20  9000AE     MOV [W14+4], W1
009C22  200140     MOV #0x14, W0
009C24  780180     MOV W0, W3
009C26  090011     REPEAT #0x11
009C28  D80083     DIV.SW W1, W3
009C2A  FD0080     EXCH W0, W1
009C2C  E00000     CP0 W0
009C2E  3A0004     BRA NZ, .L80
674:                       {
675:                           tmpi32 += (24*60);
009C30  205A00     MOV #0x5A0, W0
009C32  200001     MOV #0x0, W1
009C34  400F1E     ADD W0, [W14], [W14]
009C36  48975E     ADDC W1, [++W14], [W14--]
676:                       }
677:                       if (tmpi != start_idx)
009C38  9000AE     MOV [W14+4], W1
009C3A  90006E     MOV [W14+12], W0
009C3C  508F80     SUB W1, W0, [W15]
009C3E  320022     BRA Z, .L86
678:                       {
679:                           tmpj = u8arrSchedule[tmpi];
009C40  21C231     MOV #0x1C23, W1
009C42  90002E     MOV [W14+4], W0
009C44  408000     ADD W1, W0, W0
009C46  784010     MOV.B [W0], W0
009C48  FB8000     ZE W0, W0
009C4A  980730     MOV W0, [W14+6]
680:                           tmpj += u8arrSchedule[tmpi+1];
009C4C  90002E     MOV [W14+4], W0
009C4E  E80000     INC W0, W0
009C50  21C231     MOV #0x1C23, W1
009C52  784061     MOV.B [W1+W0], W0
009C54  FB8000     ZE W0, W0
009C56  9000BE     MOV [W14+6], W1
009C58  408000     ADD W1, W0, W0
009C5A  980730     MOV W0, [W14+6]
681:                           tmpj += u8arrSchedule[tmpi+2];
009C5C  90002E     MOV [W14+4], W0
009C5E  E88000     INC2 W0, W0
009C60  21C231     MOV #0x1C23, W1
009C62  784061     MOV.B [W1+W0], W0
009C64  FB8000     ZE W0, W0
009C66  9000BE     MOV [W14+6], W1
009C68  408000     ADD W1, W0, W0
009C6A  980730     MOV W0, [W14+6]
682:                           tmpj += u8arrSchedule[tmpi+3];
009C6C  90002E     MOV [W14+4], W0
009C6E  400063     ADD W0, #0x3, W0
009C70  21C231     MOV #0x1C23, W1
009C72  784061     MOV.B [W1+W0], W0
009C74  FB8000     ZE W0, W0
009C76  9000BE     MOV [W14+6], W1
009C78  408000     ADD W1, W0, W0
009C7A  980730     MOV W0, [W14+6]
683:                       }
684:                       else
685:                       {
686:                           break;
009C84  000000     NOP
687:                       }
688:                   }
689:                   if (tmpi == start_idx)
009C86  9000AE     MOV [W14+4], W1
009C88  90006E     MOV [W14+12], W0
009C8A  508F80     SUB W1, W0, [W15]
009C8C  3A0003     BRA NZ, .L84
690:                   {
691:                       return -1;
009C8E  EB8000     SETM W0
009C90  EB8080     SETM W1
009C92  370012     BRA .L85
692:                   }
693:                   else 
694:                   {
695:                       tmpi32 += (u8arrSchedule[tmpi]*60 + u8arrSchedule[tmpi+1]);
009C94  21C231     MOV #0x1C23, W1
009C96  90002E     MOV [W14+4], W0
009C98  408000     ADD W1, W0, W0
009C9A  784010     MOV.B [W0], W0
009C9C  FB8080     ZE W0, W1
009C9E  2003C0     MOV #0x3C, W0
009CA0  B98800     MUL.SS W1, W0, W0
009CA2  780080     MOV W0, W1
009CA4  90002E     MOV [W14+4], W0
009CA6  E80000     INC W0, W0
009CA8  21C232     MOV #0x1C23, W2
009CAA  784062     MOV.B [W2+W0], W0
009CAC  FB8000     ZE W0, W0
009CAE  408000     ADD W1, W0, W0
009CB0  DE80CF     ASR W0, #15, W1
009CB2  400F1E     ADD W0, [W14], [W14]
009CB4  48975E     ADDC W1, [++W14], [W14--]
696:                       return tmpi32;
009CB6  BE001E     MOV.D [W14], W0
697:                   }
698:               }
009CB8  FA8000     ULNK
009CBA  060000     RETURN
699:               
700:               /**
701:                * Search the set of 5 schedules (4 bytes each) starting at start_idx
702:                * @param start_idx
703:                * @return the number of non-zero schedules
704:                */
705:               int CountSchedulesInWday(int start_idx)
706:               {
009CBC  FA000A     LNK #0xA
009CBE  980740     MOV W0, [W14+8]
707:                   int tmpi, tmpj;
708:                   int count;
709:                   bool done = false;
009CC0  EB4000     CLR.B W0
009CC2  984740     MOV.B W0, [W14+4]
710:                   count = 0;
009CC4  EB0000     CLR W0
009CC6  980710     MOV W0, [W14+2]
711:                   
712:                   tmpi = 0;
009CC8  EB0000     CLR W0
009CCA  780F00     MOV W0, [W14]
713:                   while (  ( (start_idx + tmpi ) < 20) && (!done) )
009CCC  37002C     BRA .L88
009D26  90004E     MOV [W14+8], W0
009D28  40001E     ADD W0, [W14], W0
009D2A  500FF3     SUB W0, #0x13, [W15]
009D2C  3C0004     BRA GT, .L91
009D2E  90404E     MOV.B [W14+4], W0
009D30  A20400     BTG.B W0, #0
009D32  E00400     CP0.B W0
009D34  3AFFCC     BRA NZ, .L92
714:                   {
715:                       tmpj = u8arrSchedule[start_idx+tmpi];
009CCE  90004E     MOV [W14+8], W0
009CD0  40001E     ADD W0, [W14], W0
009CD2  21C231     MOV #0x1C23, W1
009CD4  784061     MOV.B [W1+W0], W0
009CD6  FB8000     ZE W0, W0
009CD8  980730     MOV W0, [W14+6]
716:                       tmpj += u8arrSchedule[start_idx+tmpi+1];
009CDA  90004E     MOV [W14+8], W0
009CDC  40001E     ADD W0, [W14], W0
009CDE  E80000     INC W0, W0
009CE0  21C231     MOV #0x1C23, W1
009CE2  784061     MOV.B [W1+W0], W0
009CE4  FB8000     ZE W0, W0
009CE6  9000BE     MOV [W14+6], W1
009CE8  408000     ADD W1, W0, W0
009CEA  980730     MOV W0, [W14+6]
717:                       tmpj += u8arrSchedule[start_idx+tmpi+2];
009CEC  90004E     MOV [W14+8], W0
009CEE  40001E     ADD W0, [W14], W0
009CF0  E88000     INC2 W0, W0
009CF2  21C231     MOV #0x1C23, W1
009CF4  784061     MOV.B [W1+W0], W0
009CF6  FB8000     ZE W0, W0
009CF8  9000BE     MOV [W14+6], W1
009CFA  408000     ADD W1, W0, W0
009CFC  980730     MOV W0, [W14+6]
718:                       tmpj += u8arrSchedule[start_idx+tmpi+3];
009CFE  90004E     MOV [W14+8], W0
009D00  40001E     ADD W0, [W14], W0
009D02  400063     ADD W0, #0x3, W0
009D04  21C231     MOV #0x1C23, W1
009D06  784061     MOV.B [W1+W0], W0
009D08  FB8000     ZE W0, W0
009D0A  9000BE     MOV [W14+6], W1
009D0C  408000     ADD W1, W0, W0
009D0E  980730     MOV W0, [W14+6]
719:                       if (tmpj > 0)
009D10  90003E     MOV [W14+6], W0
009D12  E00000     CP0 W0
009D14  340004     BRA LE, .L89
720:                       {
721:                           count ++;
009D16  90001E     MOV [W14+2], W0
009D18  E80000     INC W0, W0
009D1A  980710     MOV W0, [W14+2]
009D1C  370002     BRA .L90
722:                       }
723:                       else 
724:                       {
725:                           done = true;
009D1E  B3C010     MOV.B #0x1, W0
009D20  984740     MOV.B W0, [W14+4]
726:                       }
727:                       tmpi += 4;
009D22  78009E     MOV [W14], W1
009D24  408F64     ADD W1, #0x4, [W14]
728:                   }
729:                   return count;
009D36  90001E     MOV [W14+2], W0
730:               }
009D38  FA8000     ULNK
009D3A  060000     RETURN
731:               
732:               void ExecuteSchedule() 
733:               {
009D3C  FA0000     LNK #0x0
734:                   if (u8GotoSchedule != 0xFF)
009D3E  BFC8D8     MOV.B u8GotoSchedule, WREG
009D40  404FE1     ADD.B W0, #0x1, [W15]
009D42  320025     BRA Z, .L94
735:                   {
736:                       // need to change schedule
737:                       if (u8Schedule == SCHEDULE_NONE)
009D44  BFC8D6     MOV.B u8Schedule, WREG
009D46  504FE4     SUB.B W0, #0x4, [W15]
009D48  3A0002     BRA NZ, .L95
738:                       {
739:                           OnExitScheduleNone();
009D4A  07FEA3     RCALL OnExitScheduleNone
009D4C  370009     BRA .L96
740:                       } 
741:                       else if (u8Schedule == SCHEDULE_AWAY)
009D4E  BFC8D6     MOV.B u8Schedule, WREG
009D50  504FE2     SUB.B W0, #0x2, [W15]
009D52  3A0002     BRA NZ, .L97
742:                       {
743:                           OnExitScheduleAway();
009D54  07FF0A     RCALL OnExitScheduleAway
009D56  370004     BRA .L96
744:                       }
745:                       else if (u8Schedule == SCHEDULE_HOME)
009D58  BFC8D6     MOV.B u8Schedule, WREG
009D5A  504FE1     SUB.B W0, #0x1, [W15]
009D5C  3A0001     BRA NZ, .L96
746:                       {
747:                           OnExitScheduleHome();
009D5E  07FEAA     RCALL OnExitScheduleHome
748:                       }
749:                       else if (u8Schedule == SCHEDULE_DREVENT)
750:                       {
751:                           // OnExitSchduleDREvent has already been called, so need not call again
752:                       }
753:                       
754:                       if (u8GotoSchedule == SCHEDULE_NONE)
009D60  BFC8D8     MOV.B u8GotoSchedule, WREG
009D62  504FE4     SUB.B W0, #0x4, [W15]
009D64  3A0002     BRA NZ, .L99
755:                       {
756:                           OnEntryScheduleNone();
009D66  07FE8E     RCALL OnEntryScheduleNone
009D68  37000E     BRA .L100
757:                       }
758:                       else if (u8GotoSchedule == SCHEDULE_AWAY)
009D6A  BFC8D8     MOV.B u8GotoSchedule, WREG
009D6C  504FE2     SUB.B W0, #0x2, [W15]
009D6E  3A0002     BRA NZ, .L101
759:                       {
760:                           OnEntryScheduleAway();
009D70  07FEF1     RCALL OnEntryScheduleAway
009D72  370009     BRA .L100
761:                       }
762:                       else if (u8GotoSchedule == SCHEDULE_HOME)
009D74  BFC8D8     MOV.B u8GotoSchedule, WREG
009D76  504FE1     SUB.B W0, #0x1, [W15]
009D78  3A0002     BRA NZ, .L102
763:                       {
764:                           OnEntryScheduleHome();
009D7A  07FE95     RCALL OnEntryScheduleHome
009D7C  370004     BRA .L100
765:                       }
766:                       else if (u8GotoSchedule == SCHEDULE_DREVENT)
009D7E  BFC8D8     MOV.B u8GotoSchedule, WREG
009D80  504FE3     SUB.B W0, #0x3, [W15]
009D82  3A0001     BRA NZ, .L100
767:                       {
768:                           OnEntryScheduleDREvent();
009D84  07FEA5     RCALL OnEntryScheduleDREvent
769:                       }
770:                       u8Schedule = u8GotoSchedule;
009D86  BFC8D8     MOV.B u8GotoSchedule, WREG
009D88  B7E8D6     MOV.B WREG, u8Schedule
771:                       u8GotoSchedule = 0xFF;
009D8A  EBC000     SETM.B W0
009D8C  B7E8D8     MOV.B WREG, u8GotoSchedule
772:                   }
773:                   if (u8Schedule == SCHEDULE_NONE)
009D8E  BFC8D6     MOV.B u8Schedule, WREG
009D90  504FE4     SUB.B W0, #0x4, [W15]
009D92  3A0002     BRA NZ, .L103
774:                   {
775:                       DuringScheduleNone();
009D94  07FE85     RCALL DuringScheduleNone
009D96  37000E     BRA .L93
776:                   }
777:                   else if (u8Schedule == SCHEDULE_AWAY)
009D98  BFC8D6     MOV.B u8Schedule, WREG
009D9A  504FE2     SUB.B W0, #0x2, [W15]
009D9C  3A0002     BRA NZ, .L105
778:                   {
779:                       DuringScheduleAway();
009D9E  07FEEA     RCALL DuringScheduleAway
009DA0  370009     BRA .L93
780:                   }
781:                   else if (u8Schedule == SCHEDULE_HOME)
009DA2  BFC8D6     MOV.B u8Schedule, WREG
009DA4  504FE1     SUB.B W0, #0x1, [W15]
009DA6  3A0002     BRA NZ, .L106
782:                   {
783:                       DuringScheduleHome();
009DA8  07FE88     RCALL DuringScheduleHome
009DAA  370004     BRA .L93
784:                   }
785:                   else if (u8Schedule == SCHEDULE_DREVENT)
009DAC  BFC8D6     MOV.B u8Schedule, WREG
009DAE  504FE3     SUB.B W0, #0x3, [W15]
009DB0  3A0001     BRA NZ, .L93
786:                   {
787:                       DuringScheduleDREvent();
009DB2  07FEBC     RCALL DuringScheduleDREvent
788:                   }
789:               }
009DB4  FA8000     ULNK
009DB6  060000     RETURN
790:               
791:               void PopulateDebugBuffers(uint8_t * t_buf, uint8_t * r_buf, uint8_t * s_buf, int buf_len)
792:               {
009DB8  FA001E     LNK #0x1E
009DBA  980F30     MOV W0, [W14+22]
009DBC  980F41     MOV W1, [W14+24]
009DBE  980F52     MOV W2, [W14+26]
009DC0  980F63     MOV W3, [W14+28]
793:                   // max capacity of buffer is buf_len
794:                   // each buffer is transmitted over a characteristic of length 20, so number of transmissions is buf_len/ 20
795:                   int num_trans = buf_len / 20;
009DC2  90096E     MOV [W14+28], W2
009DC4  266670     MOV #0x6667, W0
009DC6  B99000     MUL.SS W2, W0, W0
009DC8  DE88C3     ASR W1, #3, W1
009DCA  DE904F     ASR W2, #15, W0
009DCC  508000     SUB W1, W0, W0
009DCE  980760     MOV W0, [W14+12]
796:                   int ii;
797:                   int tmprand;
798:                   int temp_start  = 10;
009DD0  2000A0     MOV #0xA, W0
009DD2  980710     MOV W0, [W14+2]
799:                   int hum_start = 1;
009DD4  200010     MOV #0x1, W0
009DD6  980720     MOV W0, [W14+4]
800:                   int t_idx, r_idx, s_idx;
801:                   uint8_t tm_yr = 119;
009DD8  B3C770     MOV.B #0x77, W0
009DDA  984F60     MOV.B W0, [W14+14]
802:                   uint8_t tm_mo = 3;
009DDC  B3C030     MOV.B #0x3, W0
009DDE  984F70     MOV.B W0, [W14+15]
803:                   uint8_t tm_dy = 19;
009DE0  B3C130     MOV.B #0x13, W0
009DE2  985700     MOV.B W0, [W14+16]
804:                   uint8_t tm_hr = 16;
009DE4  B3C100     MOV.B #0x10, W0
009DE6  985710     MOV.B W0, [W14+17]
805:                   uint8_t tm_mi = 36;
009DE8  B3C240     MOV.B #0x24, W0
009DEA  985720     MOV.B W0, [W14+18]
806:                   t_idx = 0; 
009DEC  EB0000     CLR W0
009DEE  980730     MOV W0, [W14+6]
807:                   r_idx = 0;
009DF0  EB0000     CLR W0
009DF2  980740     MOV W0, [W14+8]
808:                   s_idx = 0;
009DF4  EB0000     CLR W0
009DF6  980750     MOV W0, [W14+10]
809:                   for (ii=0; ii < num_trans; ii++ ) {
009DF8  EB0000     CLR W0
009DFA  780F00     MOV W0, [W14]
009DFC  37009F     BRA .L108
009F3A  E80F1E     INC [W14], [W14]
009F3C  90006E     MOV [W14+12], W0
009F3E  78009E     MOV [W14], W1
009F40  508F80     SUB W1, W0, [W15]
009F42  35FF5D     BRA LT, .L109
810:                       // fill 20 byte buffer
811:                       tmprand = rand();
009DFE  07B812     RCALL _rand
009E00  980F20     MOV W0, [W14+20]
812:                       t_buf[t_idx] = tm_yr;
009E02  90003E     MOV [W14+6], W0
009E04  9008BE     MOV [W14+22], W1
009E06  408000     ADD W1, W0, W0
009E08  9048EE     MOV.B [W14+14], W1
009E0A  784801     MOV.B W1, [W0]
813:                       t_buf[t_idx+1] = tm_mo;
009E0C  90003E     MOV [W14+6], W0
009E0E  E80000     INC W0, W0
009E10  9008BE     MOV [W14+22], W1
009E12  408000     ADD W1, W0, W0
009E14  9048FE     MOV.B [W14+15], W1
009E16  784801     MOV.B W1, [W0]
814:                       t_buf[t_idx+2] = tm_dy;
009E18  90003E     MOV [W14+6], W0
009E1A  E88000     INC2 W0, W0
009E1C  9008BE     MOV [W14+22], W1
009E1E  408000     ADD W1, W0, W0
009E20  90508E     MOV.B [W14+16], W1
009E22  784801     MOV.B W1, [W0]
815:                       t_buf[t_idx+3] = tm_hr;
009E24  90003E     MOV [W14+6], W0
009E26  400063     ADD W0, #0x3, W0
009E28  9008BE     MOV [W14+22], W1
009E2A  408000     ADD W1, W0, W0
009E2C  90509E     MOV.B [W14+17], W1
009E2E  784801     MOV.B W1, [W0]
816:                       t_buf[t_idx+4] = tm_mi;
009E30  90003E     MOV [W14+6], W0
009E32  400064     ADD W0, #0x4, W0
009E34  9008BE     MOV [W14+22], W1
009E36  408000     ADD W1, W0, W0
009E38  9050AE     MOV.B [W14+18], W1
009E3A  784801     MOV.B W1, [W0]
817:                       t_buf[t_idx+5] = 3; // only three elements
009E3C  90003E     MOV [W14+6], W0
009E3E  400065     ADD W0, #0x5, W0
009E40  9008BE     MOV [W14+22], W1
009E42  408000     ADD W1, W0, W0
009E44  B3C031     MOV.B #0x3, W1
009E46  784801     MOV.B W1, [W0]
818:                       t_buf[t_idx+6] = (uint8_t) (tmprand & 0xFF);
009E48  90003E     MOV [W14+6], W0
009E4A  400066     ADD W0, #0x6, W0
009E4C  9008BE     MOV [W14+22], W1
009E4E  408000     ADD W1, W0, W0
009E50  9008AE     MOV [W14+20], W1
009E52  784081     MOV.B W1, W1
009E54  784801     MOV.B W1, [W0]
819:                       t_buf[t_idx+7] = (uint8_t) ( (tmprand & 0xFF00) >> 8);
009E56  90003E     MOV [W14+6], W0
009E58  400067     ADD W0, #0x7, W0
009E5A  9008BE     MOV [W14+22], W1
009E5C  408000     ADD W1, W0, W0
009E5E  9008AE     MOV [W14+20], W1
009E60  DE08C8     LSR W1, #8, W1
009E62  784081     MOV.B W1, W1
009E64  784801     MOV.B W1, [W0]
820:                       tmprand = tmprand + 1;
009E66  90082E     MOV [W14+20], W0
009E68  E80000     INC W0, W0
009E6A  980F20     MOV W0, [W14+20]
821:                       t_buf[t_idx+8] = (uint8_t) (temp_start);
009E6C  90003E     MOV [W14+6], W0
009E6E  400068     ADD W0, #0x8, W0
009E70  9008BE     MOV [W14+22], W1
009E72  408000     ADD W1, W0, W0
009E74  90009E     MOV [W14+2], W1
009E76  784081     MOV.B W1, W1
009E78  784801     MOV.B W1, [W0]
822:                       t_buf[t_idx+9] = (uint8_t) ( hum_start );
009E7A  90003E     MOV [W14+6], W0
009E7C  400069     ADD W0, #0x9, W0
009E7E  9008BE     MOV [W14+22], W1
009E80  408000     ADD W1, W0, W0
009E82  9000AE     MOV [W14+4], W1
009E84  784081     MOV.B W1, W1
009E86  784801     MOV.B W1, [W0]
823:                       t_buf[t_idx+10] = (uint8_t) (tmprand & 0xFF);
009E88  90003E     MOV [W14+6], W0
009E8A  40006A     ADD W0, #0xA, W0
009E8C  9008BE     MOV [W14+22], W1
009E8E  408000     ADD W1, W0, W0
009E90  9008AE     MOV [W14+20], W1
009E92  784081     MOV.B W1, W1
009E94  784801     MOV.B W1, [W0]
824:                       t_buf[t_idx+11] = (uint8_t) ( (tmprand & 0xFF00) >> 8);
009E96  90003E     MOV [W14+6], W0
009E98  40006B     ADD W0, #0xB, W0
009E9A  9008BE     MOV [W14+22], W1
009E9C  408000     ADD W1, W0, W0
009E9E  9008AE     MOV [W14+20], W1
009EA0  DE08C8     LSR W1, #8, W1
009EA2  784081     MOV.B W1, W1
009EA4  784801     MOV.B W1, [W0]
825:                       tmprand = tmprand + 1;
009EA6  90082E     MOV [W14+20], W0
009EA8  E80000     INC W0, W0
009EAA  980F20     MOV W0, [W14+20]
826:                       t_buf[t_idx+12] = (uint8_t) (temp_start+3);
009EAC  90003E     MOV [W14+6], W0
009EAE  40006C     ADD W0, #0xC, W0
009EB0  9008BE     MOV [W14+22], W1
009EB2  408000     ADD W1, W0, W0
009EB4  90009E     MOV [W14+2], W1
009EB6  784081     MOV.B W1, W1
009EB8  40C0E3     ADD.B W1, #0x3, W1
009EBA  784801     MOV.B W1, [W0]
827:                       t_buf[t_idx+13] = (uint8_t) ( hum_start+1 );
009EBC  90003E     MOV [W14+6], W0
009EBE  40006D     ADD W0, #0xD, W0
009EC0  9008BE     MOV [W14+22], W1
009EC2  408000     ADD W1, W0, W0
009EC4  9000AE     MOV [W14+4], W1
009EC6  784081     MOV.B W1, W1
009EC8  E84081     INC.B W1, W1
009ECA  784801     MOV.B W1, [W0]
828:                       t_buf[t_idx+14] = (uint8_t) (tmprand & 0xFF);
009ECC  90003E     MOV [W14+6], W0
009ECE  40006E     ADD W0, #0xE, W0
009ED0  9008BE     MOV [W14+22], W1
009ED2  408000     ADD W1, W0, W0
009ED4  9008AE     MOV [W14+20], W1
009ED6  784081     MOV.B W1, W1
009ED8  784801     MOV.B W1, [W0]
829:                       t_buf[t_idx+15] = (uint8_t) ( (tmprand & 0xFF00) >> 8);
009EDA  90003E     MOV [W14+6], W0
009EDC  40006F     ADD W0, #0xF, W0
009EDE  9008BE     MOV [W14+22], W1
009EE0  408000     ADD W1, W0, W0
009EE2  9008AE     MOV [W14+20], W1
009EE4  DE08C8     LSR W1, #8, W1
009EE6  784081     MOV.B W1, W1
009EE8  784801     MOV.B W1, [W0]
830:                       tmprand = tmprand + 1;
009EEA  90082E     MOV [W14+20], W0
009EEC  E80000     INC W0, W0
009EEE  980F20     MOV W0, [W14+20]
831:                       t_buf[t_idx+16] = (uint8_t) (temp_start+6);
009EF0  90003E     MOV [W14+6], W0
009EF2  400070     ADD W0, #0x10, W0
009EF4  9008BE     MOV [W14+22], W1
009EF6  408000     ADD W1, W0, W0
009EF8  90009E     MOV [W14+2], W1
009EFA  784081     MOV.B W1, W1
009EFC  40C0E6     ADD.B W1, #0x6, W1
009EFE  784801     MOV.B W1, [W0]
832:                       t_buf[t_idx+17] = (uint8_t) ( hum_start+2 );
009F00  90003E     MOV [W14+6], W0
009F02  400071     ADD W0, #0x11, W0
009F04  9008BE     MOV [W14+22], W1
009F06  408000     ADD W1, W0, W0
009F08  9000AE     MOV [W14+4], W1
009F0A  784081     MOV.B W1, W1
009F0C  E8C081     INC2.B W1, W1
009F0E  784801     MOV.B W1, [W0]
833:                       t_buf[t_idx+18] = 0;
009F10  90003E     MOV [W14+6], W0
009F12  400072     ADD W0, #0x12, W0
009F14  9008BE     MOV [W14+22], W1
009F16  408000     ADD W1, W0, W0
009F18  EB4080     CLR.B W1
009F1A  784801     MOV.B W1, [W0]
834:                       t_buf[t_idx+19] = 0;
009F1C  90003E     MOV [W14+6], W0
009F1E  400073     ADD W0, #0x13, W0
009F20  9008BE     MOV [W14+22], W1
009F22  408000     ADD W1, W0, W0
009F24  EB4080     CLR.B W1
009F26  784801     MOV.B W1, [W0]
835:                       temp_start += 6;
009F28  90001E     MOV [W14+2], W0
009F2A  400066     ADD W0, #0x6, W0
009F2C  980710     MOV W0, [W14+2]
836:                       hum_start += 2;
009F2E  90002E     MOV [W14+4], W0
009F30  E88000     INC2 W0, W0
009F32  980720     MOV W0, [W14+4]
837:                       t_idx += 20;
009F34  90003E     MOV [W14+6], W0
009F36  400074     ADD W0, #0x14, W0
009F38  980730     MOV W0, [W14+6]
838:                   }
839:                   temp_start = 12;
009F44  2000C0     MOV #0xC, W0
009F46  980710     MOV W0, [W14+2]
840:                   hum_start = 1;
009F48  200010     MOV #0x1, W0
009F4A  980720     MOV W0, [W14+4]
841:                   for (ii=0; ii < num_trans; ii++ ) {
009F4C  EB0000     CLR W0
009F4E  780F00     MOV W0, [W14]
009F50  3700A0     BRA .L110
00A090  E80F1E     INC [W14], [W14]
00A092  90006E     MOV [W14+12], W0
00A094  78009E     MOV [W14], W1
00A096  508F80     SUB W1, W0, [W15]
00A098  35FF5C     BRA LT, .L111
842:                       // fill 20 byte buffer
843:                       tmprand = rand();
009F52  07B768     RCALL _rand
009F54  980F20     MOV W0, [W14+20]
844:                       r_buf[r_idx] = tm_yr;
009F56  90004E     MOV [W14+8], W0
009F58  9008CE     MOV [W14+24], W1
009F5A  408000     ADD W1, W0, W0
009F5C  9048EE     MOV.B [W14+14], W1
009F5E  784801     MOV.B W1, [W0]
845:                       r_buf[r_idx+1] = tm_mo;
009F60  90004E     MOV [W14+8], W0
009F62  E80000     INC W0, W0
009F64  9008CE     MOV [W14+24], W1
009F66  408000     ADD W1, W0, W0
009F68  9048FE     MOV.B [W14+15], W1
009F6A  784801     MOV.B W1, [W0]
846:                       r_buf[r_idx+2] = tm_dy+1;
009F6C  90004E     MOV [W14+8], W0
009F6E  E88000     INC2 W0, W0
009F70  9008CE     MOV [W14+24], W1
009F72  408000     ADD W1, W0, W0
009F74  90508E     MOV.B [W14+16], W1
009F76  E84081     INC.B W1, W1
009F78  784801     MOV.B W1, [W0]
847:                       r_buf[r_idx+3] = tm_hr;
009F7A  90004E     MOV [W14+8], W0
009F7C  400063     ADD W0, #0x3, W0
009F7E  9008CE     MOV [W14+24], W1
009F80  408000     ADD W1, W0, W0
009F82  90509E     MOV.B [W14+17], W1
009F84  784801     MOV.B W1, [W0]
848:                       r_buf[r_idx+4] = tm_mi;
009F86  90004E     MOV [W14+8], W0
009F88  400064     ADD W0, #0x4, W0
009F8A  9008CE     MOV [W14+24], W1
009F8C  408000     ADD W1, W0, W0
009F8E  9050AE     MOV.B [W14+18], W1
009F90  784801     MOV.B W1, [W0]
849:                       r_buf[r_idx+5] = 3; // only three elements
009F92  90004E     MOV [W14+8], W0
009F94  400065     ADD W0, #0x5, W0
009F96  9008CE     MOV [W14+24], W1
009F98  408000     ADD W1, W0, W0
009F9A  B3C031     MOV.B #0x3, W1
009F9C  784801     MOV.B W1, [W0]
850:                       r_buf[r_idx+6] = (uint8_t) (tmprand & 0xFF);
009F9E  90004E     MOV [W14+8], W0
009FA0  400066     ADD W0, #0x6, W0
009FA2  9008CE     MOV [W14+24], W1
009FA4  408000     ADD W1, W0, W0
009FA6  9008AE     MOV [W14+20], W1
009FA8  784081     MOV.B W1, W1
009FAA  784801     MOV.B W1, [W0]
851:                       r_buf[r_idx+7] = (uint8_t) ( (tmprand & 0xFF00) >> 8);
009FAC  90004E     MOV [W14+8], W0
009FAE  400067     ADD W0, #0x7, W0
009FB0  9008CE     MOV [W14+24], W1
009FB2  408000     ADD W1, W0, W0
009FB4  9008AE     MOV [W14+20], W1
009FB6  DE08C8     LSR W1, #8, W1
009FB8  784081     MOV.B W1, W1
009FBA  784801     MOV.B W1, [W0]
852:                       tmprand = tmprand + 1;
009FBC  90082E     MOV [W14+20], W0
009FBE  E80000     INC W0, W0
009FC0  980F20     MOV W0, [W14+20]
853:                       r_buf[r_idx+8] = (uint8_t) (temp_start);
009FC2  90004E     MOV [W14+8], W0
009FC4  400068     ADD W0, #0x8, W0
009FC6  9008CE     MOV [W14+24], W1
009FC8  408000     ADD W1, W0, W0
009FCA  90009E     MOV [W14+2], W1
009FCC  784081     MOV.B W1, W1
009FCE  784801     MOV.B W1, [W0]
854:                       r_buf[r_idx+9] = (uint8_t) ( hum_start );
009FD0  90004E     MOV [W14+8], W0
009FD2  400069     ADD W0, #0x9, W0
009FD4  9008CE     MOV [W14+24], W1
009FD6  408000     ADD W1, W0, W0
009FD8  9000AE     MOV [W14+4], W1
009FDA  784081     MOV.B W1, W1
009FDC  784801     MOV.B W1, [W0]
855:                       r_buf[r_idx+10] = (uint8_t) (tmprand & 0xFF);
009FDE  90004E     MOV [W14+8], W0
009FE0  40006A     ADD W0, #0xA, W0
009FE2  9008CE     MOV [W14+24], W1
009FE4  408000     ADD W1, W0, W0
009FE6  9008AE     MOV [W14+20], W1
009FE8  784081     MOV.B W1, W1
009FEA  784801     MOV.B W1, [W0]
856:                       r_buf[r_idx+11] = (uint8_t) ( (tmprand & 0xFF00) >> 8);
009FEC  90004E     MOV [W14+8], W0
009FEE  40006B     ADD W0, #0xB, W0
009FF0  9008CE     MOV [W14+24], W1
009FF2  408000     ADD W1, W0, W0
009FF4  9008AE     MOV [W14+20], W1
009FF6  DE08C8     LSR W1, #8, W1
009FF8  784081     MOV.B W1, W1
009FFA  784801     MOV.B W1, [W0]
857:                       tmprand = tmprand + 1;
009FFC  90082E     MOV [W14+20], W0
009FFE  E80000     INC W0, W0
00A000  980F20     MOV W0, [W14+20]
858:                       r_buf[r_idx+12] = (uint8_t) (temp_start+3);
00A002  90004E     MOV [W14+8], W0
00A004  40006C     ADD W0, #0xC, W0
00A006  9008CE     MOV [W14+24], W1
00A008  408000     ADD W1, W0, W0
00A00A  90009E     MOV [W14+2], W1
00A00C  784081     MOV.B W1, W1
00A00E  40C0E3     ADD.B W1, #0x3, W1
00A010  784801     MOV.B W1, [W0]
859:                       r_buf[r_idx+13] = (uint8_t) ( hum_start+1 );
00A012  90004E     MOV [W14+8], W0
00A014  40006D     ADD W0, #0xD, W0
00A016  9008CE     MOV [W14+24], W1
00A018  408000     ADD W1, W0, W0
00A01A  9000AE     MOV [W14+4], W1
00A01C  784081     MOV.B W1, W1
00A01E  E84081     INC.B W1, W1
00A020  784801     MOV.B W1, [W0]
860:                       r_buf[r_idx+14] = (uint8_t) (tmprand & 0xFF);
00A022  90004E     MOV [W14+8], W0
00A024  40006E     ADD W0, #0xE, W0
00A026  9008CE     MOV [W14+24], W1
00A028  408000     ADD W1, W0, W0
00A02A  9008AE     MOV [W14+20], W1
00A02C  784081     MOV.B W1, W1
00A02E  784801     MOV.B W1, [W0]
861:                       r_buf[r_idx+15] = (uint8_t) ( (tmprand & 0xFF00) >> 8);
00A030  90004E     MOV [W14+8], W0
00A032  40006F     ADD W0, #0xF, W0
00A034  9008CE     MOV [W14+24], W1
00A036  408000     ADD W1, W0, W0
00A038  9008AE     MOV [W14+20], W1
00A03A  DE08C8     LSR W1, #8, W1
00A03C  784081     MOV.B W1, W1
00A03E  784801     MOV.B W1, [W0]
862:                       tmprand = tmprand + 1;
00A040  90082E     MOV [W14+20], W0
00A042  E80000     INC W0, W0
00A044  980F20     MOV W0, [W14+20]
863:                       r_buf[r_idx+16] = (uint8_t) (temp_start+6);
00A046  90004E     MOV [W14+8], W0
00A048  400070     ADD W0, #0x10, W0
00A04A  9008CE     MOV [W14+24], W1
00A04C  408000     ADD W1, W0, W0
00A04E  90009E     MOV [W14+2], W1
00A050  784081     MOV.B W1, W1
00A052  40C0E6     ADD.B W1, #0x6, W1
00A054  784801     MOV.B W1, [W0]
864:                       r_buf[r_idx+17] = (uint8_t) ( hum_start+2 );
00A056  90004E     MOV [W14+8], W0
00A058  400071     ADD W0, #0x11, W0
00A05A  9008CE     MOV [W14+24], W1
00A05C  408000     ADD W1, W0, W0
00A05E  9000AE     MOV [W14+4], W1
00A060  784081     MOV.B W1, W1
00A062  E8C081     INC2.B W1, W1
00A064  784801     MOV.B W1, [W0]
865:                       r_buf[r_idx+18] = 0;
00A066  90004E     MOV [W14+8], W0
00A068  400072     ADD W0, #0x12, W0
00A06A  9008CE     MOV [W14+24], W1
00A06C  408000     ADD W1, W0, W0
00A06E  EB4080     CLR.B W1
00A070  784801     MOV.B W1, [W0]
866:                       r_buf[r_idx+19] = 0;
00A072  90004E     MOV [W14+8], W0
00A074  400073     ADD W0, #0x13, W0
00A076  9008CE     MOV [W14+24], W1
00A078  408000     ADD W1, W0, W0
00A07A  EB4080     CLR.B W1
00A07C  784801     MOV.B W1, [W0]
867:                       temp_start += 6;
00A07E  90001E     MOV [W14+2], W0
00A080  400066     ADD W0, #0x6, W0
00A082  980710     MOV W0, [W14+2]
868:                       hum_start += 2;
00A084  90002E     MOV [W14+4], W0
00A086  E88000     INC2 W0, W0
00A088  980720     MOV W0, [W14+4]
869:                       r_idx += 20;
00A08A  90004E     MOV [W14+8], W0
00A08C  400074     ADD W0, #0x14, W0
00A08E  980740     MOV W0, [W14+8]
870:                   }
871:                   temp_start = 15;
00A09A  2000F0     MOV #0xF, W0
00A09C  980710     MOV W0, [W14+2]
872:                   hum_start = 1;
00A09E  200010     MOV #0x1, W0
00A0A0  980720     MOV W0, [W14+4]
873:                   for (ii=0; ii < num_trans; ii++ ) {
00A0A2  EB0000     CLR W0
00A0A4  780F00     MOV W0, [W14]
00A0A6  3700A0     BRA .L112
00A1E6  E80F1E     INC [W14], [W14]
00A1E8  90006E     MOV [W14+12], W0
00A1EA  78009E     MOV [W14], W1
00A1EC  508F80     SUB W1, W0, [W15]
00A1EE  35FF5C     BRA LT, .L113
874:                       // fill 20 byte buffer
875:                       tmprand = rand();
00A0A8  07B6BD     RCALL _rand
00A0AA  980F20     MOV W0, [W14+20]
876:                       s_buf[s_idx] = tm_yr;
00A0AC  90005E     MOV [W14+10], W0
00A0AE  9008DE     MOV [W14+26], W1
00A0B0  408000     ADD W1, W0, W0
00A0B2  9048EE     MOV.B [W14+14], W1
00A0B4  784801     MOV.B W1, [W0]
877:                       s_buf[s_idx+1] = tm_mo;
00A0B6  90005E     MOV [W14+10], W0
00A0B8  E80000     INC W0, W0
00A0BA  9008DE     MOV [W14+26], W1
00A0BC  408000     ADD W1, W0, W0
00A0BE  9048FE     MOV.B [W14+15], W1
00A0C0  784801     MOV.B W1, [W0]
878:                       s_buf[s_idx+2] = tm_dy+1;
00A0C2  90005E     MOV [W14+10], W0
00A0C4  E88000     INC2 W0, W0
00A0C6  9008DE     MOV [W14+26], W1
00A0C8  408000     ADD W1, W0, W0
00A0CA  90508E     MOV.B [W14+16], W1
00A0CC  E84081     INC.B W1, W1
00A0CE  784801     MOV.B W1, [W0]
879:                       s_buf[s_idx+3] = tm_hr;
00A0D0  90005E     MOV [W14+10], W0
00A0D2  400063     ADD W0, #0x3, W0
00A0D4  9008DE     MOV [W14+26], W1
00A0D6  408000     ADD W1, W0, W0
00A0D8  90509E     MOV.B [W14+17], W1
00A0DA  784801     MOV.B W1, [W0]
880:                       s_buf[s_idx+4] = tm_mi;
00A0DC  90005E     MOV [W14+10], W0
00A0DE  400064     ADD W0, #0x4, W0
00A0E0  9008DE     MOV [W14+26], W1
00A0E2  408000     ADD W1, W0, W0
00A0E4  9050AE     MOV.B [W14+18], W1
00A0E6  784801     MOV.B W1, [W0]
881:                       s_buf[s_idx+5] = 3; // only three elements
00A0E8  90005E     MOV [W14+10], W0
00A0EA  400065     ADD W0, #0x5, W0
00A0EC  9008DE     MOV [W14+26], W1
00A0EE  408000     ADD W1, W0, W0
00A0F0  B3C031     MOV.B #0x3, W1
00A0F2  784801     MOV.B W1, [W0]
882:                       s_buf[s_idx+6] = (uint8_t) (tmprand & 0xFF);
00A0F4  90005E     MOV [W14+10], W0
00A0F6  400066     ADD W0, #0x6, W0
00A0F8  9008DE     MOV [W14+26], W1
00A0FA  408000     ADD W1, W0, W0
00A0FC  9008AE     MOV [W14+20], W1
00A0FE  784081     MOV.B W1, W1
00A100  784801     MOV.B W1, [W0]
883:                       s_buf[s_idx+7] = (uint8_t) ( (tmprand & 0xFF00) >> 8);
00A102  90005E     MOV [W14+10], W0
00A104  400067     ADD W0, #0x7, W0
00A106  9008DE     MOV [W14+26], W1
00A108  408000     ADD W1, W0, W0
00A10A  9008AE     MOV [W14+20], W1
00A10C  DE08C8     LSR W1, #8, W1
00A10E  784081     MOV.B W1, W1
00A110  784801     MOV.B W1, [W0]
884:                       tmprand = tmprand + 1;
00A112  90082E     MOV [W14+20], W0
00A114  E80000     INC W0, W0
00A116  980F20     MOV W0, [W14+20]
885:                       s_buf[s_idx+8] = (uint8_t) (temp_start);
00A118  90005E     MOV [W14+10], W0
00A11A  400068     ADD W0, #0x8, W0
00A11C  9008DE     MOV [W14+26], W1
00A11E  408000     ADD W1, W0, W0
00A120  90009E     MOV [W14+2], W1
00A122  784081     MOV.B W1, W1
00A124  784801     MOV.B W1, [W0]
886:                       s_buf[s_idx+9] = (uint8_t) ( hum_start );
00A126  90005E     MOV [W14+10], W0
00A128  400069     ADD W0, #0x9, W0
00A12A  9008DE     MOV [W14+26], W1
00A12C  408000     ADD W1, W0, W0
00A12E  9000AE     MOV [W14+4], W1
00A130  784081     MOV.B W1, W1
00A132  784801     MOV.B W1, [W0]
887:                       s_buf[s_idx+10] = (uint8_t) (tmprand & 0xFF);
00A134  90005E     MOV [W14+10], W0
00A136  40006A     ADD W0, #0xA, W0
00A138  9008DE     MOV [W14+26], W1
00A13A  408000     ADD W1, W0, W0
00A13C  9008AE     MOV [W14+20], W1
00A13E  784081     MOV.B W1, W1
00A140  784801     MOV.B W1, [W0]
888:                       s_buf[s_idx+11] = (uint8_t) ( (tmprand & 0xFF00) >> 8);
00A142  90005E     MOV [W14+10], W0
00A144  40006B     ADD W0, #0xB, W0
00A146  9008DE     MOV [W14+26], W1
00A148  408000     ADD W1, W0, W0
00A14A  9008AE     MOV [W14+20], W1
00A14C  DE08C8     LSR W1, #8, W1
00A14E  784081     MOV.B W1, W1
00A150  784801     MOV.B W1, [W0]
889:                       tmprand = tmprand + 1;
00A152  90082E     MOV [W14+20], W0
00A154  E80000     INC W0, W0
00A156  980F20     MOV W0, [W14+20]
890:                       s_buf[s_idx+12] = (uint8_t) (temp_start+3);
00A158  90005E     MOV [W14+10], W0
00A15A  40006C     ADD W0, #0xC, W0
00A15C  9008DE     MOV [W14+26], W1
00A15E  408000     ADD W1, W0, W0
00A160  90009E     MOV [W14+2], W1
00A162  784081     MOV.B W1, W1
00A164  40C0E3     ADD.B W1, #0x3, W1
00A166  784801     MOV.B W1, [W0]
891:                       s_buf[s_idx+13] = (uint8_t) ( hum_start+1 );
00A168  90005E     MOV [W14+10], W0
00A16A  40006D     ADD W0, #0xD, W0
00A16C  9008DE     MOV [W14+26], W1
00A16E  408000     ADD W1, W0, W0
00A170  9000AE     MOV [W14+4], W1
00A172  784081     MOV.B W1, W1
00A174  E84081     INC.B W1, W1
00A176  784801     MOV.B W1, [W0]
892:                       s_buf[s_idx+14] = (uint8_t) (tmprand & 0xFF);
00A178  90005E     MOV [W14+10], W0
00A17A  40006E     ADD W0, #0xE, W0
00A17C  9008DE     MOV [W14+26], W1
00A17E  408000     ADD W1, W0, W0
00A180  9008AE     MOV [W14+20], W1
00A182  784081     MOV.B W1, W1
00A184  784801     MOV.B W1, [W0]
893:                       s_buf[s_idx+15] = (uint8_t) ( (tmprand & 0xFF00) >> 8);
00A186  90005E     MOV [W14+10], W0
00A188  40006F     ADD W0, #0xF, W0
00A18A  9008DE     MOV [W14+26], W1
00A18C  408000     ADD W1, W0, W0
00A18E  9008AE     MOV [W14+20], W1
00A190  DE08C8     LSR W1, #8, W1
00A192  784081     MOV.B W1, W1
00A194  784801     MOV.B W1, [W0]
894:                       tmprand = tmprand + 1;
00A196  90082E     MOV [W14+20], W0
00A198  E80000     INC W0, W0
00A19A  980F20     MOV W0, [W14+20]
895:                       s_buf[s_idx+16] = (uint8_t) (temp_start+6);
00A19C  90005E     MOV [W14+10], W0
00A19E  400070     ADD W0, #0x10, W0
00A1A0  9008DE     MOV [W14+26], W1
00A1A2  408000     ADD W1, W0, W0
00A1A4  90009E     MOV [W14+2], W1
00A1A6  784081     MOV.B W1, W1
00A1A8  40C0E6     ADD.B W1, #0x6, W1
00A1AA  784801     MOV.B W1, [W0]
896:                       s_buf[s_idx+17] = (uint8_t) ( hum_start+2 );
00A1AC  90005E     MOV [W14+10], W0
00A1AE  400071     ADD W0, #0x11, W0
00A1B0  9008DE     MOV [W14+26], W1
00A1B2  408000     ADD W1, W0, W0
00A1B4  9000AE     MOV [W14+4], W1
00A1B6  784081     MOV.B W1, W1
00A1B8  E8C081     INC2.B W1, W1
00A1BA  784801     MOV.B W1, [W0]
897:                       s_buf[s_idx+18] = 0;
00A1BC  90005E     MOV [W14+10], W0
00A1BE  400072     ADD W0, #0x12, W0
00A1C0  9008DE     MOV [W14+26], W1
00A1C2  408000     ADD W1, W0, W0
00A1C4  EB4080     CLR.B W1
00A1C6  784801     MOV.B W1, [W0]
898:                       s_buf[s_idx+19] = 0;
00A1C8  90005E     MOV [W14+10], W0
00A1CA  400073     ADD W0, #0x13, W0
00A1CC  9008DE     MOV [W14+26], W1
00A1CE  408000     ADD W1, W0, W0
00A1D0  EB4080     CLR.B W1
00A1D2  784801     MOV.B W1, [W0]
899:                       temp_start += 6;
00A1D4  90001E     MOV [W14+2], W0
00A1D6  400066     ADD W0, #0x6, W0
00A1D8  980710     MOV W0, [W14+2]
900:                       hum_start += 2;
00A1DA  90002E     MOV [W14+4], W0
00A1DC  E88000     INC2 W0, W0
00A1DE  980720     MOV W0, [W14+4]
901:                       s_idx += 20;
00A1E0  90005E     MOV [W14+10], W0
00A1E2  400074     ADD W0, #0x14, W0
00A1E4  980750     MOV W0, [W14+10]
902:                   }
903:                   
904:               }
00A1F0  FA8000     ULNK
00A1F2  060000     RETURN
---  C:/Users/pvan002/Box Sync/low_income_thermostats/lita_sw/R1/rtcc.c  --------------------------------
1:                 
2:                 /**
3:                   RTCC Generated Driver API Header File
4:                 
5:                   @Company:
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name:
9:                     rtcc.c
10:                
11:                  @Summary:
12:                    This is the generated header file for the RTCC driver using MPLAB(c) Code Configurator
13:                
14:                  @Description:
15:                    This header file provides APIs for driver for RTCC.
16:                    Generation Information :
17:                        Product Revision  :  MPLAB(c) Code Configurator - v3.00
18:                        Device            :  PIC24FJ256GB406
19:                        Driver Version    :  0.5
20:                    The generated drivers are tested against the following:
21:                        Compiler          :  XC16 1.26
22:                        MPLAB 	          :  MPLAB X 3.20
23:                */
24:                
25:                /*
26:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
27:                
28:                Microchip licenses to you the right to use, modify, copy and distribute
29:                Software only when embedded on a Microchip microcontroller or digital signal
30:                controller that is integrated into your product or third party product
31:                (pursuant to the sublicense terms in the accompanying license agreement).
32:                
33:                You should refer to the license agreement accompanying this Software for
34:                additional information regarding your rights and obligations.
35:                
36:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                 */
47:                
48:                
49:                /**
50:                 Section: Included Files
51:                */
52:                
53:                #include <xc.h>
54:                #include "main.h"
55:                #include "rtcc.h"
56:                
57:                /**
58:                // Section: Static function
59:                */
60:                
61:                static void RTCC_Unlock(void);
62:                static void RTCC_Lock(void);
63:                bool rtccTimeInitialized;
64:                static bool RTCCTimeInitialized(void);
65:                static uint8_t ConvertHexToBCD(uint8_t hexvalue);
66:                static uint8_t ConvertBCDToHex(uint8_t bcdvalue);
67:                
68:                /**
69:                // Section: Driver Interface Function Definitions
70:                */
71:                
72:                void RTCC_Initialize(void)
73:                {
00CB16  FA0000     LNK #0x0
74:                  // Turn on the secondary oscillator
75:                  __builtin_write_OSCCONL(0x02);
00CB18  200022     MOV #0x2, W2
00CB1A  200460     MOV #0x46, W0
00CB1C  200571     MOV #0x57, W1
00CB1E  201003     MOV #0x100, W3
00CB20  784980     MOV.B W0, [W3]
00CB22  784981     MOV.B W1, [W3]
00CB24  784982     MOV.B W2, [W3]
76:                
77:                   RTCCON1Lbits.RTCEN = 0;
00CB26  A9E1CD     BCLR 0x1CD, #7
78:                   
79:                   RTCC_Unlock();
00CB28  07001B     RCALL _RTCC_Unlock, .LFE0, .LFB1
80:                   
81:                   if(!RTCCTimeInitialized())
00CB2A  07010F     RCALL _RTCCTimeInitialized, .LFE7, .LFB8
00CB2C  A20400     BTG.B W0, #0
00CB2E  E00400     CP0.B W0
00CB30  32000E     BRA Z, .L2
82:                   {
83:                       // set 2018-01-01 00-00-00
84:                       DATEH = 0x1801;    // Year/Month
00CB32  218010     MOV #0x1801, W0
00CB34  880F10     MOV W0, DATEH
85:                       DATEL = 0x0103;    // Date/Wday
00CB36  201030     MOV #0x103, W0
00CB38  880F00     MOV W0, DATEL
86:                       TIMEH = 0x0000;    // hours/minutes
00CB3A  EF21DE     CLR TIMEH
87:                       TIMEL = 0x0000;    // seconds
00CB3C  EF21DC     CLR TIMEL
88:                       
89:                       //setting up the alarm time
90:                       ALMDATEH = 0x1801;    // Year/Month
00CB3E  218010     MOV #0x1801, W0
00CB40  880F50     MOV W0, ALMDATEH
91:                       ALMDATEL = 0x0101;    // Date/Wday
00CB42  201010     MOV #0x101, W0
00CB44  880F40     MOV W0, ALMDATEL
92:                       ALMTIMEH = 0x0000;    // hours/minutes
00CB46  EF21E6     CLR ALMTIMEH
93:                       ALMTIMEL = 0x0000;    // seconds
00CB48  EF21E4     CLR ALMTIMEL
94:                        
95:                       rtccTimeInitialized = true;
00CB4A  B3C010     MOV.B #0x1, W0
00CB4C  B7E90C     MOV.B WREG, rtccTimeInitialized
96:                   }
97:                   // PWCPS disabled; PS 1:1; CLKSEL SOSC; FDIV 0; 
98:                   RTCCON2L = 0x0000;
00CB4E  EF21D0     CLR RTCCON2L
99:                   // DIV for 32.768KHz crystal; 
100:                  RTCCON2H = 0x3FFF;
00CB50  23FFF0     MOV #0x3FFF, W0
00CB52  880E90     MOV W0, RTCCON2H
101:                  // PWCSTAB 0; PWCSAMP 0; 
102:                  RTCCON3L = 0x0000;
00CB54  EF21D4     CLR RTCCON3L
103:               
104:                  // RTCEN enabled; OUTSEL unused; PWCPOE disabled; TSBEN disabled; 
105:                  // PWCEN disabled; WRLOCK disabled; PWCPOL disabled; TSAEN disabled; RTCOE disabled; 
106:                  RTCCON1L = 0x8000; 
00CB56  280000     MOV #0x8000, W0
00CB58  880E60     MOV W0, RTCCON1L
107:                  
108:                  RTCC_Lock();
00CB5A  07000C     RCALL _RTCC_Lock, .LFE1, .LFB2
109:               
110:               }
00CB5C  FA8000     ULNK
00CB5E  060000     RETURN
111:               
112:               static void RTCC_Unlock(void)
113:               {
00CB60  FA0000     LNK #0x0
114:                   asm volatile("DISI #6");
00CB62  FC0006     DISI #0x6
115:                   asm volatile("MOV #NVMKEY, W1");
00CB64  207661     MOV #0x766, W1
116:                   asm volatile("MOV #0x55, W2");
00CB66  200552     MOV #0x55, W2
117:                   asm volatile("MOV W2, [W1]");
00CB68  780882     MOV W2, [W1]
118:                   asm volatile("MOV #0xAA, W3");
00CB6A  200AA3     MOV #0xAA, W3
119:                   asm volatile("MOV W3, [W1]");
00CB6C  780883     MOV W3, [W1]
120:                   asm volatile("BCLR RTCCON1L, #11");
00CB6E  A961CD     BCLR 0x1CD, #3
121:               }
00CB70  FA8000     ULNK
00CB72  060000     RETURN
122:               
123:               static void RTCC_Lock(void)
124:               {
00CB74  FA0000     LNK #0x0
125:                   asm volatile("DISI #6");
00CB76  FC0006     DISI #0x6
126:                   asm volatile("MOV #NVMKEY, W1");
00CB78  207661     MOV #0x766, W1
127:                   asm volatile("MOV #0x55, W2");
00CB7A  200552     MOV #0x55, W2
128:                   asm volatile("MOV W2, [W1]");
00CB7C  780882     MOV W2, [W1]
129:                   asm volatile("MOV #0xAA, W3");
00CB7E  200AA3     MOV #0xAA, W3
130:                   asm volatile("MOV W3, [W1]");
00CB80  780883     MOV W3, [W1]
131:                   asm volatile("BSET RTCCON1L, #11");
00CB82  A861CD     BSET 0x1CD, #3
132:               }
00CB84  FA8000     ULNK
00CB86  060000     RETURN
133:               
134:               bool RTCC_TimeGet(struct tm *currentTime)
135:               {
00CB88  FA0004     LNK #0x4
00CB8A  980710     MOV W0, [W14+2]
136:                   uint16_t register_value;
137:                   if(RTCSTATLbits.SYNC){
00CB8C  800EC0     MOV RTCSTATL, W0
00CB8E  600064     AND W0, #0x4, W0
00CB90  E00000     CP0 W0
00CB92  320002     BRA Z, .L6
138:                       return false;
00CB94  EB4000     CLR.B W0
00CB96  370039     BRA .L7
139:                   }
140:               
141:                   RTCC_Unlock();
00CB98  07FFE3     RCALL _RTCC_Unlock, .LFE0, .LFB1
142:                  
143:                   register_value = DATEH;
00CB9A  800F11     MOV DATEH, W1
00CB9C  780F01     MOV W1, [W14]
144:                   currentTime->tm_year = ConvertBCDToHex((register_value & 0xFF00) >> 8);
00CB9E  78001E     MOV [W14], W0
00CBA0  DE0048     LSR W0, #8, W0
00CBA2  784000     MOV.B W0, W0
00CBA4  070207     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CBA6  FB8080     ZE W0, W1
00CBA8  90001E     MOV [W14+2], W0
00CBAA  980051     MOV W1, [W0+10]
145:                   currentTime->tm_mon = ConvertBCDToHex(register_value & 0x00FF);
00CBAC  78001E     MOV [W14], W0
00CBAE  784000     MOV.B W0, W0
00CBB0  070201     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CBB2  FB8080     ZE W0, W1
00CBB4  90001E     MOV [W14+2], W0
00CBB6  980041     MOV W1, [W0+8]
146:                   
147:                   register_value = DATEL;
00CBB8  800F01     MOV DATEL, W1
00CBBA  780F01     MOV W1, [W14]
148:                   currentTime->tm_mday = ConvertBCDToHex((register_value & 0xFF00) >> 8);
00CBBC  78001E     MOV [W14], W0
00CBBE  DE0048     LSR W0, #8, W0
00CBC0  784000     MOV.B W0, W0
00CBC2  0701F8     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CBC4  FB8080     ZE W0, W1
00CBC6  90001E     MOV [W14+2], W0
00CBC8  980031     MOV W1, [W0+6]
149:                   currentTime->tm_wday = ConvertBCDToHex(register_value & 0x00FF);
00CBCA  78001E     MOV [W14], W0
00CBCC  784000     MOV.B W0, W0
00CBCE  0701F2     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CBD0  FB8080     ZE W0, W1
00CBD2  90001E     MOV [W14+2], W0
00CBD4  980061     MOV W1, [W0+12]
150:                   
151:                   register_value = TIMEH;
00CBD6  800EF1     MOV TIMEH, W1
00CBD8  780F01     MOV W1, [W14]
152:                   currentTime->tm_hour = ConvertBCDToHex((register_value & 0xFF00) >> 8);
00CBDA  78001E     MOV [W14], W0
00CBDC  DE0048     LSR W0, #8, W0
00CBDE  784000     MOV.B W0, W0
00CBE0  0701E9     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CBE2  FB8080     ZE W0, W1
00CBE4  90001E     MOV [W14+2], W0
00CBE6  980021     MOV W1, [W0+4]
153:                   currentTime->tm_min = ConvertBCDToHex(register_value & 0x00FF);
00CBE8  78001E     MOV [W14], W0
00CBEA  784000     MOV.B W0, W0
00CBEC  0701E3     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CBEE  FB8080     ZE W0, W1
00CBF0  90001E     MOV [W14+2], W0
00CBF2  980011     MOV W1, [W0+2]
154:                   
155:                   register_value = TIMEL;
00CBF4  800EE1     MOV TIMEL, W1
00CBF6  780F01     MOV W1, [W14]
156:                   currentTime->tm_sec = ConvertBCDToHex((register_value & 0xFF00) >> 8);
00CBF8  78001E     MOV [W14], W0
00CBFA  DE0048     LSR W0, #8, W0
00CBFC  784000     MOV.B W0, W0
00CBFE  0701DA     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CC00  FB8080     ZE W0, W1
00CC02  90001E     MOV [W14+2], W0
00CC04  780801     MOV W1, [W0]
157:                  
158:                   RTCC_Lock();
00CC06  07FFB6     RCALL _RTCC_Lock, .LFE1, .LFB2
159:               
160:                   return true;
00CC08  B3C010     MOV.B #0x1, W0
161:               }
00CC0A  FA8000     ULNK
00CC0C  060000     RETURN
162:               
163:               void RTCC_TimeSet(struct tm *initialTime)
164:               {
00CC0E  FA0002     LNK #0x2
00CC10  781F88     MOV W8, [W15++]
00CC12  780F00     MOV W0, [W14]
165:                  RTCC_Unlock();
00CC14  07FFA5     RCALL _RTCC_Unlock, .LFE0, .LFB1
166:               
167:                  RTCCON1Lbits.RTCEN = 0;
00CC16  A9E1CD     BCLR 0x1CD, #7
168:                  
169:                  IFS3bits.RTCIF = false;
00CC18  A9C08F     BCLR 0x8F, #6
170:                  IEC3bits.RTCIE = 0;
00CC1A  A9C09F     BCLR 0x9F, #6
171:               
172:                  // set RTCC initial time
173:                  DATEH = (ConvertHexToBCD(initialTime->tm_year) << 8) | ConvertHexToBCD(initialTime->tm_mon) ;  // YEAR/MONTH-1
00CC1C  78001E     MOV [W14], W0
00CC1E  900050     MOV [W0+10], W0
00CC20  784000     MOV.B W0, W0
00CC22  0701B0     RCALL _ConvertHexToBCD, .LFE16, .LFB17
00CC24  FB8000     ZE W0, W0
00CC26  DD0448     SL W0, #8, W8
00CC28  78001E     MOV [W14], W0
00CC2A  900040     MOV [W0+8], W0
00CC2C  784000     MOV.B W0, W0
00CC2E  0701AA     RCALL _ConvertHexToBCD, .LFE16, .LFB17
00CC30  FB8000     ZE W0, W0
00CC32  700008     IOR W0, W8, W0
00CC34  880F10     MOV W0, DATEH
174:                  DATEL = (ConvertHexToBCD(initialTime->tm_mday) << 8) | ConvertHexToBCD(initialTime->tm_wday) ;  // /DAY-1/WEEKDAY
00CC36  78001E     MOV [W14], W0
00CC38  900030     MOV [W0+6], W0
00CC3A  784000     MOV.B W0, W0
00CC3C  0701A3     RCALL _ConvertHexToBCD, .LFE16, .LFB17
00CC3E  FB8000     ZE W0, W0
00CC40  DD0448     SL W0, #8, W8
00CC42  78001E     MOV [W14], W0
00CC44  900060     MOV [W0+12], W0
00CC46  784000     MOV.B W0, W0
00CC48  07019D     RCALL _ConvertHexToBCD, .LFE16, .LFB17
00CC4A  FB8000     ZE W0, W0
00CC4C  700008     IOR W0, W8, W0
00CC4E  880F00     MOV W0, DATEL
175:                  TIMEH = (ConvertHexToBCD(initialTime->tm_hour) << 8)  | ConvertHexToBCD(initialTime->tm_min); // /HOURS/MINUTES
00CC50  78001E     MOV [W14], W0
00CC52  900020     MOV [W0+4], W0
00CC54  784000     MOV.B W0, W0
00CC56  070196     RCALL _ConvertHexToBCD, .LFE16, .LFB17
00CC58  FB8000     ZE W0, W0
00CC5A  DD0448     SL W0, #8, W8
00CC5C  78001E     MOV [W14], W0
00CC5E  900010     MOV [W0+2], W0
00CC60  784000     MOV.B W0, W0
00CC62  070190     RCALL _ConvertHexToBCD, .LFE16, .LFB17
00CC64  FB8000     ZE W0, W0
00CC66  700008     IOR W0, W8, W0
00CC68  880EF0     MOV W0, TIMEH
176:                  TIMEL = (ConvertHexToBCD(initialTime->tm_sec) << 8) ;   // SECOND
00CC6A  78001E     MOV [W14], W0
00CC6C  780010     MOV [W0], W0
00CC6E  784000     MOV.B W0, W0
00CC70  070189     RCALL _ConvertHexToBCD, .LFE16, .LFB17
00CC72  FB8000     ZE W0, W0
00CC74  DD0048     SL W0, #8, W0
00CC76  880EE0     MOV W0, TIMEL
177:                          
178:                  // Enable RTCC, clear RTCWREN         
179:                  RTCCON1Lbits.RTCEN = 1;  
00CC78  A8E1CD     BSET 0x1CD, #7
180:                  RTCC_Lock();
00CC7A  07FF7C     RCALL _RTCC_Lock, .LFE1, .LFB2
181:               
182:                  //Enable RTCC interrupt
183:                  IEC3bits.RTCIE = 1;
00CC7C  A8C09F     BSET 0x9F, #6
184:               }
00CC7E  78044F     MOV [--W15], W8
00CC80  FA8000     ULNK
00CC82  060000     RETURN
185:               
186:               bool RTCC_BCDTimeGet(bcdTime_t *currentTime)
187:               {
00CC84  FA0004     LNK #0x4
00CC86  980710     MOV W0, [W14+2]
188:                   uint16_t register_value;
189:                   if(RTCSTATLbits.SYNC){
00CC88  800EC0     MOV RTCSTATL, W0
00CC8A  600064     AND W0, #0x4, W0
00CC8C  E00000     CP0 W0
00CC8E  320002     BRA Z, .L10
190:                       return false;
00CC90  EB4000     CLR.B W0
00CC92  37002E     BRA .L11
191:                   }
192:               
193:                   RTCC_Unlock();
00CC94  07FF65     RCALL _RTCC_Unlock, .LFE0, .LFB1
194:                  
195:                   register_value = DATEH;
00CC96  800F11     MOV DATEH, W1
00CC98  780F01     MOV W1, [W14]
196:                   currentTime->tm_year = (register_value & 0xFF00) >> 8;
00CC9A  78001E     MOV [W14], W0
00CC9C  DE0048     LSR W0, #8, W0
00CC9E  780080     MOV W0, W1
00CCA0  90001E     MOV [W14+2], W0
00CCA2  980051     MOV W1, [W0+10]
197:                   currentTime->tm_mon = register_value & 0x00FF;
00CCA4  78009E     MOV [W14], W1
00CCA6  200FF0     MOV #0xFF, W0
00CCA8  608080     AND W1, W0, W1
00CCAA  90001E     MOV [W14+2], W0
00CCAC  980041     MOV W1, [W0+8]
198:                   
199:                   register_value = DATEL;
00CCAE  800F01     MOV DATEL, W1
00CCB0  780F01     MOV W1, [W14]
200:                   currentTime->tm_mday = (register_value & 0xFF00) >> 8;
00CCB2  78001E     MOV [W14], W0
00CCB4  DE0048     LSR W0, #8, W0
00CCB6  780080     MOV W0, W1
00CCB8  90001E     MOV [W14+2], W0
00CCBA  980031     MOV W1, [W0+6]
201:                   currentTime->tm_wday = register_value & 0x00FF;
00CCBC  78009E     MOV [W14], W1
00CCBE  200FF0     MOV #0xFF, W0
00CCC0  608080     AND W1, W0, W1
00CCC2  90001E     MOV [W14+2], W0
00CCC4  980061     MOV W1, [W0+12]
202:                   
203:                   register_value = TIMEH;
00CCC6  800EF1     MOV TIMEH, W1
00CCC8  780F01     MOV W1, [W14]
204:                   currentTime->tm_hour = (register_value & 0xFF00) >> 8;
00CCCA  78001E     MOV [W14], W0
00CCCC  DE0048     LSR W0, #8, W0
00CCCE  780080     MOV W0, W1
00CCD0  90001E     MOV [W14+2], W0
00CCD2  980021     MOV W1, [W0+4]
205:                   currentTime->tm_min = register_value & 0x00FF;
00CCD4  78009E     MOV [W14], W1
00CCD6  200FF0     MOV #0xFF, W0
00CCD8  608080     AND W1, W0, W1
00CCDA  90001E     MOV [W14+2], W0
00CCDC  980011     MOV W1, [W0+2]
206:                  
207:                   register_value = TIMEL;
00CCDE  800EE1     MOV TIMEL, W1
00CCE0  780F01     MOV W1, [W14]
208:                   currentTime->tm_sec = (register_value & 0xFF00) >> 8;
00CCE2  78001E     MOV [W14], W0
00CCE4  DE0048     LSR W0, #8, W0
00CCE6  780080     MOV W0, W1
00CCE8  90001E     MOV [W14+2], W0
00CCEA  780801     MOV W1, [W0]
209:                  
210:                   RTCC_Lock();
00CCEC  07FF43     RCALL _RTCC_Lock, .LFE1, .LFB2
211:               
212:                   return true;
00CCEE  B3C010     MOV.B #0x1, W0
213:               }
00CCF0  FA8000     ULNK
00CCF2  060000     RETURN
214:               
215:               void RTCC_BCDTimeSet(bcdTime_t *initialTime)
216:               {
00CCF4  FA0002     LNK #0x2
00CCF6  780F00     MOV W0, [W14]
217:                  RTCC_Unlock();
00CCF8  07FF33     RCALL _RTCC_Unlock, .LFE0, .LFB1
218:               
219:                  RTCCON1Lbits.RTCEN = 0;
00CCFA  A9E1CD     BCLR 0x1CD, #7
220:                  
221:                  IFS3bits.RTCIF = false;
00CCFC  A9C08F     BCLR 0x8F, #6
222:                  IEC3bits.RTCIE = 0;
00CCFE  A9C09F     BCLR 0x9F, #6
223:               
224:                  // set RTCC initial time
225:                  DATEH = (initialTime->tm_year << 8) | (initialTime->tm_mon) ;  // YEAR/MONTH-1
00CD00  78001E     MOV [W14], W0
00CD02  900050     MOV [W0+10], W0
00CD04  DD00C8     SL W0, #8, W1
00CD06  78001E     MOV [W14], W0
00CD08  900040     MOV [W0+8], W0
00CD0A  700001     IOR W0, W1, W0
00CD0C  880F10     MOV W0, DATEH
226:                  DATEL = (initialTime->tm_mday << 8) | (initialTime->tm_wday) ;  // /DAY-1/WEEKDAY
00CD0E  78001E     MOV [W14], W0
00CD10  900030     MOV [W0+6], W0
00CD12  DD00C8     SL W0, #8, W1
00CD14  78001E     MOV [W14], W0
00CD16  900060     MOV [W0+12], W0
00CD18  700001     IOR W0, W1, W0
00CD1A  880F00     MOV W0, DATEL
227:                  TIMEH = (initialTime->tm_hour << 8) | (initialTime->tm_min); // /HOURS/MINUTES
00CD1C  78001E     MOV [W14], W0
00CD1E  900020     MOV [W0+4], W0
00CD20  DD00C8     SL W0, #8, W1
00CD22  78001E     MOV [W14], W0
00CD24  900010     MOV [W0+2], W0
00CD26  700001     IOR W0, W1, W0
00CD28  880EF0     MOV W0, TIMEH
228:                  TIMEL = (initialTime->tm_sec << 8);   // SECONDS   
00CD2A  78001E     MOV [W14], W0
00CD2C  780010     MOV [W0], W0
00CD2E  DD0048     SL W0, #8, W0
00CD30  880EE0     MOV W0, TIMEL
229:                          
230:                  // Enable RTCC, clear RTCWREN         
231:                  RTCCON1Lbits.RTCEN = 1;  
00CD32  A8E1CD     BSET 0x1CD, #7
232:                  RTCC_Lock();
00CD34  07FF1F     RCALL _RTCC_Lock, .LFE1, .LFB2
233:               
234:                  //Enable RTCC interrupt
235:                  IEC3bits.RTCIE = 1;
00CD36  A8C09F     BSET 0x9F, #6
236:               }
00CD38  FA8000     ULNK
00CD3A  060000     RETURN
237:               
238:               /**
239:                This function implements RTCC_TimeReset.This function is used to
240:                used by application to reset the RTCC value and reinitialize RTCC value.
241:               */
242:               void RTCC_TimeReset(bool reset)
243:               {
00CD3C  FA0002     LNK #0x2
00CD3E  784F00     MOV.B W0, [W14]
244:                   rtccTimeInitialized = reset;
00CD40  78411E     MOV.B [W14], W2
00CD42  2090C1     MOV #0x90C, W1
00CD44  784882     MOV.B W2, [W1]
245:               }
00CD46  FA8000     ULNK
00CD48  060000     RETURN
246:               
247:               static bool RTCCTimeInitialized(void)
248:               {
00CD4A  FA0000     LNK #0x0
249:                   return(rtccTimeInitialized);
00CD4C  BFC90C     MOV.B rtccTimeInitialized, WREG
250:               }
00CD4E  FA8000     ULNK
00CD50  060000     RETURN
251:               
252:               void RTCC_TimestampAEventManualSet(void)
253:               {
00CD52  FA0000     LNK #0x0
254:                   RTCSTATLbits.TSAEVT = 1;
00CD54  A861D8     BSET RTCSTATL, #3
255:               }
00CD56  FA8000     ULNK
00CD58  060000     RETURN
256:               
257:               bool RTCC_TimestampADataGet(struct tm *currentTime)
258:               {
00CD5A  FA0004     LNK #0x4
00CD5C  980710     MOV W0, [W14+2]
259:                   uint16_t register_value;
260:                   if(!RTCSTATLbits.TSAEVT){
00CD5E  800EC0     MOV RTCSTATL, W0
00CD60  600068     AND W0, #0x8, W0
00CD62  E00000     CP0 W0
00CD64  3A0002     BRA NZ, .L17
261:                       return false;
00CD66  EB4000     CLR.B W0
00CD68  370038     BRA .L18
262:                   }
263:                 
264:                   register_value = TSADATEH;
00CD6A  800F91     MOV TSADATEH, W1
00CD6C  780F01     MOV W1, [W14]
265:                   currentTime->tm_year = ConvertBCDToHex((register_value & 0xFF00) >> 8);
00CD6E  78001E     MOV [W14], W0
00CD70  DE0048     LSR W0, #8, W0
00CD72  784000     MOV.B W0, W0
00CD74  07011F     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CD76  FB8080     ZE W0, W1
00CD78  90001E     MOV [W14+2], W0
00CD7A  980051     MOV W1, [W0+10]
266:                   currentTime->tm_mon = ConvertBCDToHex(register_value & 0x00FF);
00CD7C  78001E     MOV [W14], W0
00CD7E  784000     MOV.B W0, W0
00CD80  070119     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CD82  FB8080     ZE W0, W1
00CD84  90001E     MOV [W14+2], W0
00CD86  980041     MOV W1, [W0+8]
267:                   
268:                   register_value = TSADATEL;
00CD88  800F81     MOV TSADATEL, W1
00CD8A  780F01     MOV W1, [W14]
269:                   currentTime->tm_mday = ConvertBCDToHex((register_value & 0xFF00) >> 8);
00CD8C  78001E     MOV [W14], W0
00CD8E  DE0048     LSR W0, #8, W0
00CD90  784000     MOV.B W0, W0
00CD92  070110     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CD94  FB8080     ZE W0, W1
00CD96  90001E     MOV [W14+2], W0
00CD98  980031     MOV W1, [W0+6]
270:                   currentTime->tm_wday = ConvertBCDToHex(register_value & 0x00FF);
00CD9A  78001E     MOV [W14], W0
00CD9C  784000     MOV.B W0, W0
00CD9E  07010A     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CDA0  FB8080     ZE W0, W1
00CDA2  90001E     MOV [W14+2], W0
00CDA4  980061     MOV W1, [W0+12]
271:                   
272:                   register_value = TSATIMEH;
00CDA6  800F71     MOV TSATIMEH, W1
00CDA8  780F01     MOV W1, [W14]
273:                   currentTime->tm_hour = ConvertBCDToHex((register_value & 0xFF00) >> 8);
00CDAA  78001E     MOV [W14], W0
00CDAC  DE0048     LSR W0, #8, W0
00CDAE  784000     MOV.B W0, W0
00CDB0  070101     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CDB2  FB8080     ZE W0, W1
00CDB4  90001E     MOV [W14+2], W0
00CDB6  980021     MOV W1, [W0+4]
274:                   currentTime->tm_min = ConvertBCDToHex(register_value & 0x00FF);
00CDB8  78001E     MOV [W14], W0
00CDBA  784000     MOV.B W0, W0
00CDBC  0700FB     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CDBE  FB8080     ZE W0, W1
00CDC0  90001E     MOV [W14+2], W0
00CDC2  980011     MOV W1, [W0+2]
275:                   
276:                   register_value = TSATIMEL;
00CDC4  800F61     MOV TSATIMEL, W1
00CDC6  780F01     MOV W1, [W14]
277:                   currentTime->tm_sec = ConvertBCDToHex((register_value & 0xFF00) >> 8);
00CDC8  78001E     MOV [W14], W0
00CDCA  DE0048     LSR W0, #8, W0
00CDCC  784000     MOV.B W0, W0
00CDCE  0700F2     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CDD0  FB8080     ZE W0, W1
00CDD2  90001E     MOV [W14+2], W0
00CDD4  780801     MOV W1, [W0]
278:                  
279:                   RTCSTATLbits.TSAEVT = 0;
00CDD6  A961D8     BCLR RTCSTATL, #3
280:               
281:                   return true;
00CDD8  B3C010     MOV.B #0x1, W0
282:               }
00CDDA  FA8000     ULNK
00CDDC  060000     RETURN
283:               
284:               
285:               
286:               bool RTCC_TimestampA_BCDDataGet(bcdTime_t *currentTime)
287:               {
00CDDE  FA0004     LNK #0x4
00CDE0  980710     MOV W0, [W14+2]
288:                   uint16_t register_value;
289:                   if(!RTCSTATLbits.TSAEVT){
00CDE2  800EC0     MOV RTCSTATL, W0
00CDE4  600068     AND W0, #0x8, W0
00CDE6  E00000     CP0 W0
00CDE8  3A0002     BRA NZ, .L20
290:                       return false;
00CDEA  EB4000     CLR.B W0
00CDEC  37002D     BRA .L21
291:                   }
292:                 
293:                   register_value = TSADATEH;
00CDEE  800F91     MOV TSADATEH, W1
00CDF0  780F01     MOV W1, [W14]
294:                   currentTime->tm_year = (register_value & 0xFF00) >> 8;
00CDF2  78001E     MOV [W14], W0
00CDF4  DE0048     LSR W0, #8, W0
00CDF6  780080     MOV W0, W1
00CDF8  90001E     MOV [W14+2], W0
00CDFA  980051     MOV W1, [W0+10]
295:                   currentTime->tm_mon = (register_value & 0x00FF);
00CDFC  78009E     MOV [W14], W1
00CDFE  200FF0     MOV #0xFF, W0
00CE00  608080     AND W1, W0, W1
00CE02  90001E     MOV [W14+2], W0
00CE04  980041     MOV W1, [W0+8]
296:                   
297:                   register_value = TSADATEL;
00CE06  800F81     MOV TSADATEL, W1
00CE08  780F01     MOV W1, [W14]
298:                   currentTime->tm_mday = (register_value & 0xFF00) >> 8;
00CE0A  78001E     MOV [W14], W0
00CE0C  DE0048     LSR W0, #8, W0
00CE0E  780080     MOV W0, W1
00CE10  90001E     MOV [W14+2], W0
00CE12  980031     MOV W1, [W0+6]
299:                   currentTime->tm_wday = (register_value & 0x00FF);
00CE14  78009E     MOV [W14], W1
00CE16  200FF0     MOV #0xFF, W0
00CE18  608080     AND W1, W0, W1
00CE1A  90001E     MOV [W14+2], W0
00CE1C  980061     MOV W1, [W0+12]
300:                   
301:                   register_value = TSATIMEH;
00CE1E  800F71     MOV TSATIMEH, W1
00CE20  780F01     MOV W1, [W14]
302:                   currentTime->tm_hour = (register_value & 0xFF00) >> 8;
00CE22  78001E     MOV [W14], W0
00CE24  DE0048     LSR W0, #8, W0
00CE26  780080     MOV W0, W1
00CE28  90001E     MOV [W14+2], W0
00CE2A  980021     MOV W1, [W0+4]
303:                   currentTime->tm_min = (register_value & 0x00FF);
00CE2C  78009E     MOV [W14], W1
00CE2E  200FF0     MOV #0xFF, W0
00CE30  608080     AND W1, W0, W1
00CE32  90001E     MOV [W14+2], W0
00CE34  980011     MOV W1, [W0+2]
304:                   
305:                   register_value = TSATIMEL;
00CE36  800F61     MOV TSATIMEL, W1
00CE38  780F01     MOV W1, [W14]
306:                   currentTime->tm_sec = (register_value & 0xFF00) >> 8;
00CE3A  78001E     MOV [W14], W0
00CE3C  DE0048     LSR W0, #8, W0
00CE3E  780080     MOV W0, W1
00CE40  90001E     MOV [W14+2], W0
00CE42  780801     MOV W1, [W0]
307:                  
308:                   RTCSTATLbits.TSAEVT = 0;
00CE44  A961D8     BCLR RTCSTATL, #3
309:               
310:                   return true;
00CE46  B3C010     MOV.B #0x1, W0
311:               }
00CE48  FA8000     ULNK
00CE4A  060000     RETURN
312:               
313:               void RTCC_TimestampBEventManualSet(void)
314:               {
00CE4C  FA0000     LNK #0x0
315:                   RTCSTATLbits.TSBEVT = 1;
00CE4E  A881D8     BSET RTCSTATL, #4
316:               }
00CE50  FA8000     ULNK
00CE52  060000     RETURN
317:               
318:               bool RTCC_TimestampBDataGet(struct tm *currentTime)
319:               {
00CE54  FA0004     LNK #0x4
00CE56  980710     MOV W0, [W14+2]
320:                   uint16_t register_value;
321:                   if(!RTCSTATLbits.TSBEVT){
00CE58  800EC0     MOV RTCSTATL, W0
00CE5A  600070     AND W0, #0x10, W0
00CE5C  E00000     CP0 W0
00CE5E  3A0002     BRA NZ, .L24
322:                       return false;
00CE60  EB4000     CLR.B W0
00CE62  370038     BRA .L25
323:                   }
324:                 
325:                   register_value = TSBDATEH;
00CE64  800FD1     MOV TSBDATEH, W1
00CE66  780F01     MOV W1, [W14]
326:                   currentTime->tm_year = ConvertBCDToHex((register_value & 0xFF00) >> 8);
00CE68  78001E     MOV [W14], W0
00CE6A  DE0048     LSR W0, #8, W0
00CE6C  784000     MOV.B W0, W0
00CE6E  0700A2     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CE70  FB8080     ZE W0, W1
00CE72  90001E     MOV [W14+2], W0
00CE74  980051     MOV W1, [W0+10]
327:                   currentTime->tm_mon = ConvertBCDToHex(register_value & 0x00FF);
00CE76  78001E     MOV [W14], W0
00CE78  784000     MOV.B W0, W0
00CE7A  07009C     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CE7C  FB8080     ZE W0, W1
00CE7E  90001E     MOV [W14+2], W0
00CE80  980041     MOV W1, [W0+8]
328:                   
329:                   register_value = TSBDATEL;
00CE82  800FC1     MOV TSBDATEL, W1
00CE84  780F01     MOV W1, [W14]
330:                   currentTime->tm_mday = ConvertBCDToHex((register_value & 0xFF00) >> 8);
00CE86  78001E     MOV [W14], W0
00CE88  DE0048     LSR W0, #8, W0
00CE8A  784000     MOV.B W0, W0
00CE8C  070093     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CE8E  FB8080     ZE W0, W1
00CE90  90001E     MOV [W14+2], W0
00CE92  980031     MOV W1, [W0+6]
331:                   currentTime->tm_wday = ConvertBCDToHex(register_value & 0x00FF);
00CE94  78001E     MOV [W14], W0
00CE96  784000     MOV.B W0, W0
00CE98  07008D     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CE9A  FB8080     ZE W0, W1
00CE9C  90001E     MOV [W14+2], W0
00CE9E  980061     MOV W1, [W0+12]
332:                   
333:                   register_value = TSBTIMEH;
00CEA0  800FB1     MOV TSBTIMEH, W1
00CEA2  780F01     MOV W1, [W14]
334:                   currentTime->tm_hour = ConvertBCDToHex((register_value & 0xFF00) >> 8);
00CEA4  78001E     MOV [W14], W0
00CEA6  DE0048     LSR W0, #8, W0
00CEA8  784000     MOV.B W0, W0
00CEAA  070084     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CEAC  FB8080     ZE W0, W1
00CEAE  90001E     MOV [W14+2], W0
00CEB0  980021     MOV W1, [W0+4]
335:                   currentTime->tm_min = ConvertBCDToHex(register_value & 0x00FF);
00CEB2  78001E     MOV [W14], W0
00CEB4  784000     MOV.B W0, W0
00CEB6  07007E     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CEB8  FB8080     ZE W0, W1
00CEBA  90001E     MOV [W14+2], W0
00CEBC  980011     MOV W1, [W0+2]
336:                   
337:                   register_value = TSBTIMEL;
00CEBE  800FA1     MOV TSBTIMEL, W1
00CEC0  780F01     MOV W1, [W14]
338:                   currentTime->tm_sec = ConvertBCDToHex((register_value & 0xFF00) >> 8);
00CEC2  78001E     MOV [W14], W0
00CEC4  DE0048     LSR W0, #8, W0
00CEC6  784000     MOV.B W0, W0
00CEC8  070075     RCALL _ConvertBCDToHex, .LFE17, .LFB18
00CECA  FB8080     ZE W0, W1
00CECC  90001E     MOV [W14+2], W0
00CECE  780801     MOV W1, [W0]
339:               
340:                   RTCSTATLbits.TSBEVT = 0;
00CED0  A981D8     BCLR RTCSTATL, #4
341:               
342:                   return true;
00CED2  B3C010     MOV.B #0x1, W0
343:               }
00CED4  FA8000     ULNK
00CED6  060000     RETURN
344:               
345:               bool RTCC_TimestampB_BCDDataGet(bcdTime_t *currentTime)
346:               {
00CED8  FA0004     LNK #0x4
00CEDA  980710     MOV W0, [W14+2]
347:                   uint16_t register_value;
348:                   if(!RTCSTATLbits.TSBEVT){
00CEDC  800EC0     MOV RTCSTATL, W0
00CEDE  600070     AND W0, #0x10, W0
00CEE0  E00000     CP0 W0
00CEE2  3A0002     BRA NZ, .L27
349:                       return false;
00CEE4  EB4000     CLR.B W0
00CEE6  37002D     BRA .L28
350:                   }
351:                 
352:                   register_value = TSBDATEH;
00CEE8  800FD1     MOV TSBDATEH, W1
00CEEA  780F01     MOV W1, [W14]
353:                   currentTime->tm_year = (register_value & 0xFF00) >> 8;
00CEEC  78001E     MOV [W14], W0
00CEEE  DE0048     LSR W0, #8, W0
00CEF0  780080     MOV W0, W1
00CEF2  90001E     MOV [W14+2], W0
00CEF4  980051     MOV W1, [W0+10]
354:                   currentTime->tm_mon = (register_value & 0x00FF);
00CEF6  78009E     MOV [W14], W1
00CEF8  200FF0     MOV #0xFF, W0
00CEFA  608080     AND W1, W0, W1
00CEFC  90001E     MOV [W14+2], W0
00CEFE  980041     MOV W1, [W0+8]
355:                   
356:                   register_value = TSBDATEL;
00CF00  800FC1     MOV TSBDATEL, W1
00CF02  780F01     MOV W1, [W14]
357:                   currentTime->tm_mday = (register_value & 0xFF00) >> 8;
00CF04  78001E     MOV [W14], W0
00CF06  DE0048     LSR W0, #8, W0
00CF08  780080     MOV W0, W1
00CF0A  90001E     MOV [W14+2], W0
00CF0C  980031     MOV W1, [W0+6]
358:                   currentTime->tm_wday = (register_value & 0x00FF);
00CF0E  78009E     MOV [W14], W1
00CF10  200FF0     MOV #0xFF, W0
00CF12  608080     AND W1, W0, W1
00CF14  90001E     MOV [W14+2], W0
00CF16  980061     MOV W1, [W0+12]
359:                   
360:                   register_value = TSBTIMEH;
00CF18  800FB1     MOV TSBTIMEH, W1
00CF1A  780F01     MOV W1, [W14]
361:                   currentTime->tm_hour = (register_value & 0xFF00) >> 8;
00CF1C  78001E     MOV [W14], W0
00CF1E  DE0048     LSR W0, #8, W0
00CF20  780080     MOV W0, W1
00CF22  90001E     MOV [W14+2], W0
00CF24  980021     MOV W1, [W0+4]
362:                   currentTime->tm_min = (register_value & 0x00FF);
00CF26  78009E     MOV [W14], W1
00CF28  200FF0     MOV #0xFF, W0
00CF2A  608080     AND W1, W0, W1
00CF2C  90001E     MOV [W14+2], W0
00CF2E  980011     MOV W1, [W0+2]
363:                   
364:                   register_value = TSBTIMEL;
00CF30  800FA1     MOV TSBTIMEL, W1
00CF32  780F01     MOV W1, [W14]
365:                   currentTime->tm_sec = (register_value & 0xFF00) >> 8;
00CF34  78001E     MOV [W14], W0
00CF36  DE0048     LSR W0, #8, W0
00CF38  780080     MOV W0, W1
00CF3A  90001E     MOV [W14+2], W0
00CF3C  780801     MOV W1, [W0]
366:               
367:                   RTCSTATLbits.TSBEVT = 0;
00CF3E  A981D8     BCLR RTCSTATL, #4
368:               
369:                   return true;
00CF40  B3C010     MOV.B #0x1, W0
370:               }
00CF42  FA8000     ULNK
00CF44  060000     RETURN
371:               
372:               void RTCC_AlarmEnable(uint8_t interval)
373:               {
00CF46  FA0002     LNK #0x2
00CF48  784F00     MOV.B W0, [W14]
374:                   //0=0.5s, 1= 1s, 2 = 10s, 3 = 1min, 4=10min, 5=1hr, 6=1day, 7=1week
375:                   //8=1month, 9=1year, 
376:                   if (interval >=0 && interval <= 9)
00CF4A  78401E     MOV.B [W14], W0
00CF4C  504FE9     SUB.B W0, #0x9, [W15]
00CF4E  3E0014     BRA GTU, .L29
377:                   {
378:                       RTCC_Unlock();
00CF50  07FE07     RCALL _RTCC_Unlock, .LFE0, .LFB1
379:                       RTCCON1Lbits.RTCEN = 0;
00CF52  A9E1CD     BCLR 0x1CD, #7
380:                       IFS3bits.RTCIF = false;
00CF54  A9C08F     BCLR 0x8F, #6
381:                       IEC3bits.RTCIE = 0;
00CF56  A9C09F     BCLR 0x9F, #6
382:               
383:                       RTCCON1Hbits.AMASK = interval;
00CF58  78409E     MOV.B [W14], W1
00CF5A  60C06F     AND.B W1, #0xF, W0
00CF5C  FB8000     ZE W0, W0
00CF5E  60006F     AND W0, #0xF, W0
00CF60  DD0048     SL W0, #8, W0
00CF62  800E72     MOV RTCCON1H, W2
00CF64  2F0FF1     MOV #0xF0FF, W1
00CF66  610081     AND W2, W1, W1
00CF68  700001     IOR W0, W1, W0
00CF6A  880E70     MOV W0, RTCCON1H
384:                       RTCCON1Hbits.CHIME = 1; //makes the alarm repeat
00CF6C  A8C1CF     BSET 0x1CF, #6
385:                       RTCCON1Hbits.ALMRPT = 0; //
00CF6E  EF61CE     CLR.B RTCCON1H
386:                       RTCCON1Hbits.ALRMEN = 1;
00CF70  A8E1CF     BSET 0x1CF, #7
387:               
388:                       RTCCON1Lbits.RTCEN = 1;  
00CF72  A8E1CD     BSET 0x1CD, #7
389:                       RTCC_Lock();        
00CF74  07FDFF     RCALL _RTCC_Lock, .LFE1, .LFB2
390:                       IEC3bits.RTCIE = 1;//Enable RTCC interrupt
00CF76  A8C09F     BSET 0x9F, #6
391:                   }    
392:               }
00CF78  FA8000     ULNK
00CF7A  060000     RETURN
393:               
394:               void RTCC_AlarmDisable(void)
395:               {
00CF7C  FA0000     LNK #0x0
396:                   RTCCON1Hbits.ALRMEN = 0;
00CF7E  A9E1CF     BCLR 0x1CF, #7
397:               }
00CF80  FA8000     ULNK
00CF82  060000     RETURN
398:               
399:               static uint8_t ConvertHexToBCD(uint8_t hexvalue)
400:               {
00CF84  FA0004     LNK #0x4
00CF86  984720     MOV.B W0, [W14+2]
401:                   uint8_t bcdvalue;
402:                   bcdvalue = (hexvalue / 10) << 4;
00CF88  90402E     MOV.B [W14+2], W0
00CF8A  FB8080     ZE W0, W1
00CF8C  2CCCD0     MOV #0xCCCD, W0
00CF8E  B80800     MUL.UU W1, W0, W0
00CF90  DE0843     LSR W1, #3, W0
00CF92  784080     MOV.B W0, W1
00CF94  200040     MOV #0x4, W0
00CF96  DD0800     SL W1, W0, W0
00CF98  784F00     MOV.B W0, [W14]
403:                   bcdvalue = bcdvalue | (hexvalue % 10);
00CF9A  90402E     MOV.B [W14+2], W0
00CF9C  FB8100     ZE W0, W2
00CF9E  2CCCD0     MOV #0xCCCD, W0
00CFA0  B81000     MUL.UU W2, W0, W0
00CFA2  DE0843     LSR W1, #3, W0
00CFA4  B9006A     MUL.SU W0, #10, W0
00CFA6  780000     MOV W0, W0
00CFA8  510000     SUB W2, W0, W0
00CFAA  784000     MOV.B W0, W0
00CFAC  704F1E     IOR.B W0, [W14], [W14]
404:                   return (bcdvalue);
00CFAE  78401E     MOV.B [W14], W0
405:               }
00CFB0  FA8000     ULNK
00CFB2  060000     RETURN
406:               
407:               static uint8_t ConvertBCDToHex(uint8_t bcdvalue)
408:               {
00CFB4  FA0004     LNK #0x4
00CFB6  984720     MOV.B W0, [W14+2]
409:                   uint8_t hexvalue;
410:                   hexvalue = (((bcdvalue & 0xF0) >> 4)* 10) + (bcdvalue & 0x0F);
00CFB8  90402E     MOV.B [W14+2], W0
00CFBA  FB8000     ZE W0, W0
00CFBC  DE0044     LSR W0, #4, W0
00CFBE  784000     MOV.B W0, W0
00CFC0  B9006A     MUL.SU W0, #10, W0
00CFC2  780000     MOV W0, W0
00CFC4  784080     MOV.B W0, W1
00CFC6  90402E     MOV.B [W14+2], W0
00CFC8  60406F     AND.B W0, #0xF, W0
00CFCA  40CF00     ADD.B W1, W0, [W14]
411:                   return hexvalue;
00CFCC  78401E     MOV.B [W14], W0
412:               }
00CFCE  FA8000     ULNK
00CFD0  060000     RETURN
413:               
414:               
415:               /* Function:
416:                 void __attribute__ ( ( interrupt, no_auto_psv ) ) _ISR _RTCCInterrupt( void )
417:               
418:                 Summary:
419:                   Interrupt Service Routine for the RTCC Peripheral
420:               
421:                 Description:
422:                   This is the interrupt service routine for the RTCC peripheral. Add in code if 
423:                   required in the ISR. 
424:               */
425:               
426:               /**
427:                End of File
428:               */
---  C:/Users/pvan002/Box Sync/low_income_thermostats/lita_sw/R1/memory.c  ------------------------------
1:                 /* 
2:                  * File:   memory.c
3:                  * Author: Viswanath
4:                  *
5:                  * Created on January 22, 2019, 5:34 AM
6:                  */
7:                 
8:                 
9:                 #include <xc.h>
10:                #include "main.h"
11:                #include "hal.h"
12:                #include "system.h"
13:                #include "rtcc.h"
14:                #include "FRAM.h"
15:                #include "memory.h"
16:                
17:                
18:                /**
19:                 * RTC Initialize bit is used only by 
20:                 * rtcc.h during RTCC initialize. If 
21:                 * the time has already been set, then
22:                 * the rtcc initialize will not overwrite
23:                 * the DATE and TIME registers
24:                 */
25:                void  ReadRTCInitializedMemory(void)
26:                {
006CBC  FA0002     LNK #0x2
27:                    uint8_t data = 0;
006CBE  EB4000     CLR.B W0
006CC0  784F00     MOV.B W0, [W14]
28:                    data = FRAMReadByte(memLocRTCInitialized, 0);
006CC2  EB4100     CLR.B W2
006CC4  B80060     MUL.UU W0, #0, W0
006CC6  072DE3     RCALL FRAMReadByte
006CC8  784F00     MOV.B W0, [W14]
29:                    if (data == 1)
006CCA  78401E     MOV.B [W14], W0
006CCC  504FE1     SUB.B W0, #0x1, [W15]
006CCE  3A0003     BRA NZ, .L2
30:                    {
31:                        rtccTimeInitialized = true;
006CD0  B3C010     MOV.B #0x1, W0
006CD2  B7E90C     MOV.B WREG, rtccTimeInitialized
006CD4  370001     BRA .L1
32:                    }
33:                    else
34:                    {
35:                        rtccTimeInitialized = false;
006CD6  EF690C     CLR.B rtccTimeInitialized
36:                    }    
37:                }
006CD8  FA8000     ULNK
006CDA  060000     RETURN
38:                void WriteRTCInitializedMemory(void)
39:                {
006CDC  FA0002     LNK #0x2
40:                    uint8_t data = 0;
006CDE  EB4000     CLR.B W0
006CE0  784F00     MOV.B W0, [W14]
41:                    data = 1;
006CE2  B3C010     MOV.B #0x1, W0
006CE4  784F00     MOV.B W0, [W14]
42:                    FRAMWriteByte(data,memLocRTCInitialized, 0 );
006CE6  EB4080     CLR.B W1
006CE8  B81160     MUL.UU W2, #0, W2
006CEA  78401E     MOV.B [W14], W0
006CEC  072C62     RCALL FRAMWriteByte
43:                }
006CEE  FA8000     ULNK
006CF0  060000     RETURN
44:                
45:                void ReadRTCSetupTime(struct tm *setupTime) {
006CF2  FA0004     LNK #0x4
006CF4  980710     MOV W0, [W14+2]
46:                    uint8_t tempval;
47:                    //date and time stamp stored in 5 bytes: year, month, day, hour, minutes
48:                    tempval = FRAMReadByte(memLocRTCSetupDate, 0);
006CF6  EB4100     CLR.B W2
006CF8  200010     MOV #0x1, W0
006CFA  200001     MOV #0x0, W1
006CFC  072DC8     RCALL FRAMReadByte
006CFE  784F00     MOV.B W0, [W14]
49:                    setupTime->tm_year = tempval;
006D00  FB809E     ZE [W14], W1
006D02  90001E     MOV [W14+2], W0
006D04  980051     MOV W1, [W0+10]
50:                    tempval = FRAMReadByte(memLocRTCSetupDate+1, 0);
006D06  EB4100     CLR.B W2
006D08  200020     MOV #0x2, W0
006D0A  200001     MOV #0x0, W1
006D0C  072DC0     RCALL FRAMReadByte
006D0E  784F00     MOV.B W0, [W14]
51:                    setupTime->tm_mon = tempval;
006D10  FB809E     ZE [W14], W1
006D12  90001E     MOV [W14+2], W0
006D14  980041     MOV W1, [W0+8]
52:                    tempval = FRAMReadByte(memLocRTCSetupDate+2, 0);
006D16  EB4100     CLR.B W2
006D18  200030     MOV #0x3, W0
006D1A  200001     MOV #0x0, W1
006D1C  072DB8     RCALL FRAMReadByte
006D1E  784F00     MOV.B W0, [W14]
53:                    setupTime->tm_mday = tempval;
006D20  FB809E     ZE [W14], W1
006D22  90001E     MOV [W14+2], W0
006D24  980031     MOV W1, [W0+6]
54:                    tempval = FRAMReadByte(memLocRTCSetupDate+3, 0);
006D26  EB4100     CLR.B W2
006D28  200040     MOV #0x4, W0
006D2A  200001     MOV #0x0, W1
006D2C  072DB0     RCALL FRAMReadByte
006D2E  784F00     MOV.B W0, [W14]
55:                    setupTime->tm_hour = tempval;
006D30  FB809E     ZE [W14], W1
006D32  90001E     MOV [W14+2], W0
006D34  980021     MOV W1, [W0+4]
56:                    tempval = FRAMReadByte(memLocRTCSetupDate+4, 0);
006D36  EB4100     CLR.B W2
006D38  200050     MOV #0x5, W0
006D3A  200001     MOV #0x0, W1
006D3C  072DA8     RCALL FRAMReadByte
006D3E  784F00     MOV.B W0, [W14]
57:                    setupTime->tm_min = tempval;
006D40  FB809E     ZE [W14], W1
006D42  90001E     MOV [W14+2], W0
006D44  980011     MOV W1, [W0+2]
58:                }
006D46  FA8000     ULNK
006D48  060000     RETURN
59:                
60:                void WriteRTCSetupTime(struct tm *setupTime) {
006D4A  FA0004     LNK #0x4
006D4C  980710     MOV W0, [W14+2]
61:                    uint8_t tempval;
62:                    //date and time stamp stored in 5 bytes: year, month, day, hour, minutes
63:                    tempval = (uint8_t)setupTime->tm_year;
006D4E  90001E     MOV [W14+2], W0
006D50  900050     MOV [W0+10], W0
006D52  784F00     MOV.B W0, [W14]
64:                    FRAMWriteByte(tempval,memLocRTCSetupDate,0);
006D54  EB4080     CLR.B W1
006D56  200012     MOV #0x1, W2
006D58  200003     MOV #0x0, W3
006D5A  78401E     MOV.B [W14], W0
006D5C  072C2A     RCALL FRAMWriteByte
65:                    tempval = (uint8_t)setupTime->tm_mon;
006D5E  90001E     MOV [W14+2], W0
006D60  900040     MOV [W0+8], W0
006D62  784F00     MOV.B W0, [W14]
66:                    FRAMWriteByte(tempval,(memLocRTCSetupDate+1),0);
006D64  EB4080     CLR.B W1
006D66  200022     MOV #0x2, W2
006D68  200003     MOV #0x0, W3
006D6A  78401E     MOV.B [W14], W0
006D6C  072C22     RCALL FRAMWriteByte
67:                    tempval = (uint8_t)setupTime->tm_mday;
006D6E  90001E     MOV [W14+2], W0
006D70  900030     MOV [W0+6], W0
006D72  784F00     MOV.B W0, [W14]
68:                    FRAMWriteByte(tempval,(memLocRTCSetupDate+2),0);
006D74  EB4080     CLR.B W1
006D76  200032     MOV #0x3, W2
006D78  200003     MOV #0x0, W3
006D7A  78401E     MOV.B [W14], W0
006D7C  072C1A     RCALL FRAMWriteByte
69:                    tempval = (uint8_t)setupTime->tm_hour;
006D7E  90001E     MOV [W14+2], W0
006D80  900020     MOV [W0+4], W0
006D82  784F00     MOV.B W0, [W14]
70:                    FRAMWriteByte(tempval,(memLocRTCSetupDate+3),0);
006D84  EB4080     CLR.B W1
006D86  200042     MOV #0x4, W2
006D88  200003     MOV #0x0, W3
006D8A  78401E     MOV.B [W14], W0
006D8C  072C12     RCALL FRAMWriteByte
71:                    tempval = (uint8_t)setupTime->tm_min;
006D8E  90001E     MOV [W14+2], W0
006D90  900010     MOV [W0+2], W0
006D92  784F00     MOV.B W0, [W14]
72:                    FRAMWriteByte(tempval,(memLocRTCSetupDate+4),0);     
006D94  EB4080     CLR.B W1
006D96  200052     MOV #0x5, W2
006D98  200003     MOV #0x0, W3
006D9A  78401E     MOV.B [W14], W0
006D9C  072C0A     RCALL FRAMWriteByte
73:                    
74:                }
006D9E  FA8000     ULNK
006DA0  060000     RETURN
75:                
76:                /**
77:                 * u8CoolSetpoint is the cool setpoint for the thermostat
78:                 * this performs the cooling when temperature goes above setpoint 
79:                 * Reads and Writes cool set point from global variable u8CoolSetpoint
80:                 */
81:                void ReadCoolSetpoint(void)
82:                {
006DA2  FA0002     LNK #0x2
83:                    uint8_t data = 0xFF;
006DA4  EBC000     SETM.B W0
006DA6  784F00     MOV.B W0, [W14]
84:                    data = FRAMReadByte(memLocCoolSetpoint, 0);
006DA8  EB4100     CLR.B W2
006DAA  200070     MOV #0x7, W0
006DAC  200001     MOV #0x0, W1
006DAE  072D6F     RCALL FRAMReadByte
006DB0  784F00     MOV.B W0, [W14]
85:                    u8CoolSetpoint = data;
006DB2  78411E     MOV.B [W14], W2
006DB4  208B51     MOV #0x8B5, W1
006DB6  784882     MOV.B W2, [W1]
86:                }
006DB8  FA8000     ULNK
006DBA  060000     RETURN
87:                void WriteCoolSetpoint(void)
88:                {
006DBC  FA0002     LNK #0x2
89:                    uint8_t data = u8CoolSetpoint;
006DBE  208B51     MOV #0x8B5, W1
006DC0  784091     MOV.B [W1], W1
006DC2  784F01     MOV.B W1, [W14]
90:                    FRAMWriteByte(data,memLocCoolSetpoint, 0 );
006DC4  EB4080     CLR.B W1
006DC6  200072     MOV #0x7, W2
006DC8  200003     MOV #0x0, W3
006DCA  78401E     MOV.B [W14], W0
006DCC  072BF2     RCALL FRAMWriteByte
91:                }
006DCE  FA8000     ULNK
006DD0  060000     RETURN
92:                
93:                /**
94:                 * u8HeatSetpoint is the heat setpoint for the thermostat
95:                 * this performs the heat when temperature goes below setpoint 
96:                 * Reads and Writes heat set point from global variable u8HeatSetpoint
97:                 */
98:                void ReadHeatSetpoint(void)
99:                {
006DD2  FA0002     LNK #0x2
100:                   uint8_t data = 0xFF;
006DD4  EBC000     SETM.B W0
006DD6  784F00     MOV.B W0, [W14]
101:                   data = FRAMReadByte(memLocHeatSetpoint, 0);
006DD8  EB4100     CLR.B W2
006DDA  200080     MOV #0x8, W0
006DDC  200001     MOV #0x0, W1
006DDE  072D57     RCALL FRAMReadByte
006DE0  784F00     MOV.B W0, [W14]
102:                   u8HeatSetpoint = data;
006DE2  78411E     MOV.B [W14], W2
006DE4  208B81     MOV #0x8B8, W1
006DE6  784882     MOV.B W2, [W1]
103:               }
006DE8  FA8000     ULNK
006DEA  060000     RETURN
104:               void WriteHeatSetpoint(void)
105:               {
006DEC  FA0002     LNK #0x2
106:                   uint8_t data = u8HeatSetpoint;
006DEE  208B81     MOV #0x8B8, W1
006DF0  784091     MOV.B [W1], W1
006DF2  784F01     MOV.B W1, [W14]
107:                   FRAMWriteByte(data,memLocHeatSetpoint, 0 );
006DF4  EB4080     CLR.B W1
006DF6  200082     MOV #0x8, W2
006DF8  200003     MOV #0x0, W3
006DFA  78401E     MOV.B [W14], W0
006DFC  072BDA     RCALL FRAMWriteByte
108:               }
006DFE  FA8000     ULNK
006E00  060000     RETURN
109:               
110:               /**
111:                * Identifies if the FRAM has been initialized
112:                *    implying the app has run at least once
113:                *    and all initializations are completed
114:                * Reads the first byte at memLocAppInitializedOne, and 
115:                *  second byte at memLocAppInitializedTwo.
116:                *  
117:                * @return 1 if sum of first byte + second byte = 0xFF
118:                *      else return 0
119:                */
120:               uint8_t FRAMInitialized()
121:               {
006E02  FA0002     LNK #0x2
122:                   uint8_t data1, data2;
123:                   data1 = FRAMReadByte(memLocAppInitializedOne, 0);
006E04  EB4100     CLR.B W2
006E06  200090     MOV #0x9, W0
006E08  200001     MOV #0x0, W1
006E0A  072D41     RCALL FRAMReadByte
006E0C  784F00     MOV.B W0, [W14]
124:                   data2 = FRAMReadByte(memLocAppInitializedTwo, 0);
006E0E  EB4100     CLR.B W2
006E10  2000C0     MOV #0xC, W0
006E12  200001     MOV #0x0, W1
006E14  072D3C     RCALL FRAMReadByte
006E16  984710     MOV.B W0, [W14+1]
125:                   if ( ((data1 + data2) == 0xFF) && ( (data1 | data2) == 0xFF) )
006E18  FB809E     ZE [W14], W1
006E1A  90401E     MOV.B [W14+1], W0
006E1C  FB8000     ZE W0, W0
006E1E  408080     ADD W1, W0, W1
006E20  200FF0     MOV #0xFF, W0
006E22  508F80     SUB W1, W0, [W15]
006E24  3A0006     BRA NZ, .L12
006E26  90401E     MOV.B [W14+1], W0
006E28  70401E     IOR.B W0, [W14], W0
006E2A  404FE1     ADD.B W0, #0x1, [W15]
006E2C  3A0002     BRA NZ, .L12
126:                   {
127:                       return 1;
006E2E  B3C010     MOV.B #0x1, W0
006E30  37000B     BRA .L13
128:                   } else
129:                   {
130:                       FRAMWriteByte(0xB5, memLocAppInitializedOne, 0);
006E32  EB4080     CLR.B W1
006E34  200092     MOV #0x9, W2
006E36  200003     MOV #0x0, W3
006E38  B3CB50     MOV.B #0xB5, W0
006E3A  072BBB     RCALL FRAMWriteByte
131:                       FRAMWriteByte(0x4A, memLocAppInitializedTwo, 0);
006E3C  EB4080     CLR.B W1
006E3E  2000C2     MOV #0xC, W2
006E40  200003     MOV #0x0, W3
006E42  B3C4A0     MOV.B #0x4A, W0
006E44  072BB6     RCALL FRAMWriteByte
132:                       return 0;
006E46  EB4000     CLR.B W0
133:                   }
134:               }
006E48  FA8000     ULNK
006E4A  060000     RETURN
135:               
136:               /**
137:                * u16PartialScreenUpdateCount is the count that tracks number of partial updates
138:                * after a certain number of partial updates, a full screen update would be necessary
139:                * Reads and Writes screen update count from global variable u16PartialScreenUpdateCount
140:                */
141:               void ReadPartialScreenUpdateCount(void)
142:               {
006E4C  FA0002     LNK #0x2
143:                   uint16_t data = 0xFF;
006E4E  200FF0     MOV #0xFF, W0
006E50  780F00     MOV W0, [W14]
144:                   data = FRAMReadWord(memLocPartialScreenUpdateCount, 0);
006E52  EB4100     CLR.B W2
006E54  2000A0     MOV #0xA, W0
006E56  200001     MOV #0x0, W1
006E58  072D3F     RCALL FRAMReadWord
006E5A  780F00     MOV W0, [W14]
145:                   u16PartialScreenUpdateCount = data;
006E5C  78009E     MOV [W14], W1
006E5E  8845E1     MOV W1, u16PartialScreenUpdateCount
146:               }
006E60  FA8000     ULNK
006E62  060000     RETURN
147:               void WritePartialScreenUpdateCount(void)
148:               {
006E64  FA0002     LNK #0x2
149:                   uint16_t data = u16PartialScreenUpdateCount;
006E66  8045E1     MOV u16PartialScreenUpdateCount, W1
006E68  780F01     MOV W1, [W14]
150:                   FRAMWriteWord(data,memLocPartialScreenUpdateCount, 0 );
006E6A  EB4080     CLR.B W1
006E6C  2000A2     MOV #0xA, W2
006E6E  200003     MOV #0x0, W3
006E70  78001E     MOV [W14], W0
006E72  072BDF     RCALL FRAMWriteWord
151:               }
006E74  FA8000     ULNK
006E76  060000     RETURN
152:               
153:               
154:               /**
155:                * u8Hysteresis contains the current hysteresis value set
156:                *   allowed values are : 1 to 4
157:                * Reads and Writes mode from global variable u8Hysteresis
158:                */
159:               void ReadHysteresis(void)
160:               {
006E78  FA0002     LNK #0x2
161:                   uint8_t data = 0xFF;
006E7A  EBC000     SETM.B W0
006E7C  784F00     MOV.B W0, [W14]
162:                   data = FRAMReadByte(memLocHysteresis, 0);
006E7E  EB4100     CLR.B W2
006E80  200130     MOV #0x13, W0
006E82  200001     MOV #0x0, W1
006E84  072D04     RCALL FRAMReadByte
006E86  784F00     MOV.B W0, [W14]
163:                   u8Hysteresis = data;
006E88  78411E     MOV.B [W14], W2
006E8A  208BB1     MOV #0x8BB, W1
006E8C  784882     MOV.B W2, [W1]
164:               }
006E8E  FA8000     ULNK
006E90  060000     RETURN
165:               void WriteHysteresis(void)
166:               {
006E92  FA0002     LNK #0x2
167:                   uint8_t data = u8Hysteresis;
006E94  208BB1     MOV #0x8BB, W1
006E96  784091     MOV.B [W1], W1
006E98  784F01     MOV.B W1, [W14]
168:                   FRAMWriteByte(data,memLocHysteresis, 0 );
006E9A  EB4080     CLR.B W1
006E9C  200132     MOV #0x13, W2
006E9E  200003     MOV #0x0, W3
006EA0  78401E     MOV.B [W14], W0
006EA2  072B87     RCALL FRAMWriteByte
169:               }
006EA4  FA8000     ULNK
006EA6  060000     RETURN
170:               
171:               
172:               /**
173:                * u8ThermostatMode has the current mode
174:                *   allowed values are : heat+cool, cool only, heat only
175:                * Reads and Writes mode from global variable u8ThermostatMode
176:                */
177:               void ReadThermostatMode(void)
178:               {
006EA8  FA0002     LNK #0x2
179:                   uint8_t data = 0xFF;
006EAA  EBC000     SETM.B W0
006EAC  784F00     MOV.B W0, [W14]
180:                   data = FRAMReadByte(memLocThermostatMode, 0);
006EAE  EB4100     CLR.B W2
006EB0  200140     MOV #0x14, W0
006EB2  200001     MOV #0x0, W1
006EB4  072CEC     RCALL FRAMReadByte
006EB6  784F00     MOV.B W0, [W14]
181:                   u8ThermostatMode = data;
006EB8  78411E     MOV.B [W14], W2
006EBA  208BE1     MOV #0x8BE, W1
006EBC  784882     MOV.B W2, [W1]
182:               }
006EBE  FA8000     ULNK
006EC0  060000     RETURN
183:               void WriteThermostatMode(void)
184:               {
006EC2  FA0002     LNK #0x2
185:                   uint8_t data = u8ThermostatMode;
006EC4  208BE1     MOV #0x8BE, W1
006EC6  784091     MOV.B [W1], W1
006EC8  784F01     MOV.B W1, [W14]
186:                   FRAMWriteByte(data,memLocThermostatMode, 0 );
006ECA  EB4080     CLR.B W1
006ECC  200142     MOV #0x14, W2
006ECE  200003     MOV #0x0, W3
006ED0  78401E     MOV.B [W14], W0
006ED2  072B6F     RCALL FRAMWriteByte
187:               }
006ED4  FA8000     ULNK
006ED6  060000     RETURN
188:               
189:               /**
190:                * initialzes the schedule bitmap to 0's 
191:                * this is called the first time the app executes
192:                */
193:               void ScheduleInit()
194:               {
006ED8  FA0000     LNK #0x0
195:                   FRAMWriteByte(0x00, memLocScheduleStart, 0);
006EDA  EB4080     CLR.B W1
006EDC  200192     MOV #0x19, W2
006EDE  200003     MOV #0x0, W3
006EE0  EB4000     CLR.B W0
006EE2  072B67     RCALL FRAMWriteByte
196:                   FRAMWriteByte(0x00, memLocScheduleStart+1, 0);
006EE4  EB4080     CLR.B W1
006EE6  2001A2     MOV #0x1A, W2
006EE8  200003     MOV #0x0, W3
006EEA  EB4000     CLR.B W0
006EEC  072B62     RCALL FRAMWriteByte
197:                   FRAMWriteByte(0x00, memLocScheduleStart+2, 0);
006EEE  EB4080     CLR.B W1
006EF0  2001B2     MOV #0x1B, W2
006EF2  200003     MOV #0x0, W3
006EF4  EB4000     CLR.B W0
006EF6  072B5D     RCALL FRAMWriteByte
198:                   FRAMWriteByte(0x00, memLocScheduleStart+3, 0);
006EF8  EB4080     CLR.B W1
006EFA  2001C2     MOV #0x1C, W2
006EFC  200003     MOV #0x0, W3
006EFE  EB4000     CLR.B W0
006F00  072B58     RCALL FRAMWriteByte
199:                   FRAMWriteByte(0x00, memLocScheduleStart+4, 0);
006F02  EB4080     CLR.B W1
006F04  2001D2     MOV #0x1D, W2
006F06  200003     MOV #0x0, W3
006F08  EB4000     CLR.B W0
006F0A  072B53     RCALL FRAMWriteByte
200:                 
201:               }
006F0C  FA8000     ULNK
006F0E  060000     RETURN
202:               
203:               /**
204:                * Read and write schedules from/to FRAM 
205:                * global variable uint8_t u8arrTodaySchedule[16] contains the following
206:                * byte 0: hour
207:                * byte 1: minute
208:                * byte 2: cool setpoint
209:                * byte 3: heat setpoint
210:                * each day consists of 5 schedules, hence array is 20 bytes long
211:                * These functions read/ write a schedule for a given day (5 sections per day)
212:                * Therefore to write the schedules for a week, the 
213:                * variable todaySchedule must be correctly populated, and the Write function called to store it in FRAM
214:                * input: dayOfWeek, 0 represents Sunday, 1 represents Monday, 2 represents Tuesday, .... 6 represents Saturday
215:                */
216:               void ReadSchedule(int dayOfWeek)
217:               {
006F10  FA0006     LNK #0x6
006F12  980720     MOV W0, [W14+4]
218:                   uint8_t data = 0xFF;
006F14  EBC000     SETM.B W0
006F16  784F00     MOV.B W0, [W14]
219:                   int offset = 5 + 20*dayOfWeek; // 5 is the schedule bitmap
006F18  90002E     MOV [W14+4], W0
006F1A  B90074     MUL.SU W0, #20, W0
006F1C  780000     MOV W0, W0
006F1E  400065     ADD W0, #0x5, W0
006F20  980710     MOV W0, [W14+2]
220:                   data = FRAMReadByte(memLocScheduleStart+offset, 0);
006F22  90001E     MOV [W14+2], W0
006F24  400079     ADD W0, #0x19, W0
006F26  DE80CF     ASR W0, #15, W1
006F28  EB4100     CLR.B W2
006F2A  072CB1     RCALL FRAMReadByte
006F2C  784F00     MOV.B W0, [W14]
221:                   u8arrTodaySchedule[0] = data;
006F2E  21C0F0     MOV #0x1C0F, W0
006F30  78481E     MOV.B [W14], [W0]
222:                   data = FRAMReadByte(memLocScheduleStart+offset+1, 0);
006F32  90001E     MOV [W14+2], W0
006F34  40007A     ADD W0, #0x1A, W0
006F36  DE80CF     ASR W0, #15, W1
006F38  EB4100     CLR.B W2
006F3A  072CA9     RCALL FRAMReadByte
006F3C  784F00     MOV.B W0, [W14]
223:                   u8arrTodaySchedule[1] = data;
006F3E  21C100     MOV #0x1C10, W0
006F40  78481E     MOV.B [W14], [W0]
224:                   data = FRAMReadByte(memLocScheduleStart+offset+2, 0);
006F42  90001E     MOV [W14+2], W0
006F44  40007B     ADD W0, #0x1B, W0
006F46  DE80CF     ASR W0, #15, W1
006F48  EB4100     CLR.B W2
006F4A  072CA1     RCALL FRAMReadByte
006F4C  784F00     MOV.B W0, [W14]
225:                   u8arrTodaySchedule[2] = data;
006F4E  21C110     MOV #0x1C11, W0
006F50  78481E     MOV.B [W14], [W0]
226:                   data = FRAMReadByte(memLocScheduleStart+offset+3, 0);
006F52  90001E     MOV [W14+2], W0
006F54  40007C     ADD W0, #0x1C, W0
006F56  DE80CF     ASR W0, #15, W1
006F58  EB4100     CLR.B W2
006F5A  072C99     RCALL FRAMReadByte
006F5C  784F00     MOV.B W0, [W14]
227:                   u8arrTodaySchedule[3] = data;
006F5E  21C120     MOV #0x1C12, W0
006F60  78481E     MOV.B [W14], [W0]
228:                   data = FRAMReadByte(memLocScheduleStart+offset+4, 0);
006F62  90001E     MOV [W14+2], W0
006F64  40007D     ADD W0, #0x1D, W0
006F66  DE80CF     ASR W0, #15, W1
006F68  EB4100     CLR.B W2
006F6A  072C91     RCALL FRAMReadByte
006F6C  784F00     MOV.B W0, [W14]
229:                   u8arrTodaySchedule[4] = data;
006F6E  21C130     MOV #0x1C13, W0
006F70  78481E     MOV.B [W14], [W0]
230:                   data = FRAMReadByte(memLocScheduleStart+offset+5, 0);
006F72  90001E     MOV [W14+2], W0
006F74  40007E     ADD W0, #0x1E, W0
006F76  DE80CF     ASR W0, #15, W1
006F78  EB4100     CLR.B W2
006F7A  072C89     RCALL FRAMReadByte
006F7C  784F00     MOV.B W0, [W14]
231:                   u8arrTodaySchedule[5] = data;
006F7E  21C140     MOV #0x1C14, W0
006F80  78481E     MOV.B [W14], [W0]
232:                   data = FRAMReadByte(memLocScheduleStart+offset+6, 0);
006F82  90001E     MOV [W14+2], W0
006F84  40007F     ADD W0, #0x1F, W0
006F86  DE80CF     ASR W0, #15, W1
006F88  EB4100     CLR.B W2
006F8A  072C81     RCALL FRAMReadByte
006F8C  784F00     MOV.B W0, [W14]
233:                   u8arrTodaySchedule[6] = data;
006F8E  21C150     MOV #0x1C15, W0
006F90  78481E     MOV.B [W14], [W0]
234:                   data = FRAMReadByte(memLocScheduleStart+offset+7, 0);
006F92  90001E     MOV [W14+2], W0
006F94  B00200     ADD #0x20, W0
006F96  DE80CF     ASR W0, #15, W1
006F98  EB4100     CLR.B W2
006F9A  072C79     RCALL FRAMReadByte
006F9C  784F00     MOV.B W0, [W14]
235:                   u8arrTodaySchedule[7] = data;
006F9E  21C160     MOV #0x1C16, W0
006FA0  78481E     MOV.B [W14], [W0]
236:                   data = FRAMReadByte(memLocScheduleStart+offset+8, 0);
006FA2  90001E     MOV [W14+2], W0
006FA4  B00210     ADD #0x21, W0
006FA6  DE80CF     ASR W0, #15, W1
006FA8  EB4100     CLR.B W2
006FAA  072C71     RCALL FRAMReadByte
006FAC  784F00     MOV.B W0, [W14]
237:                   u8arrTodaySchedule[8] = data;
006FAE  21C170     MOV #0x1C17, W0
006FB0  78481E     MOV.B [W14], [W0]
238:                   data = FRAMReadByte(memLocScheduleStart+offset+9, 0);
006FB2  90001E     MOV [W14+2], W0
006FB4  B00220     ADD #0x22, W0
006FB6  DE80CF     ASR W0, #15, W1
006FB8  EB4100     CLR.B W2
006FBA  072C69     RCALL FRAMReadByte
006FBC  784F00     MOV.B W0, [W14]
239:                   u8arrTodaySchedule[9] = data;
006FBE  21C180     MOV #0x1C18, W0
006FC0  78481E     MOV.B [W14], [W0]
240:                   data = FRAMReadByte(memLocScheduleStart+offset+10, 0);
006FC2  90001E     MOV [W14+2], W0
006FC4  B00230     ADD #0x23, W0
006FC6  DE80CF     ASR W0, #15, W1
006FC8  EB4100     CLR.B W2
006FCA  072C61     RCALL FRAMReadByte
006FCC  784F00     MOV.B W0, [W14]
241:                   u8arrTodaySchedule[10] = data;
006FCE  21C190     MOV #0x1C19, W0
006FD0  78481E     MOV.B [W14], [W0]
242:                   data = FRAMReadByte(memLocScheduleStart+offset+11, 0);
006FD2  90001E     MOV [W14+2], W0
006FD4  B00240     ADD #0x24, W0
006FD6  DE80CF     ASR W0, #15, W1
006FD8  EB4100     CLR.B W2
006FDA  072C59     RCALL FRAMReadByte
006FDC  784F00     MOV.B W0, [W14]
243:                   u8arrTodaySchedule[11] = data;
006FDE  21C1A0     MOV #0x1C1A, W0
006FE0  78481E     MOV.B [W14], [W0]
244:                   data = FRAMReadByte(memLocScheduleStart+offset+12, 0);
006FE2  90001E     MOV [W14+2], W0
006FE4  B00250     ADD #0x25, W0
006FE6  DE80CF     ASR W0, #15, W1
006FE8  EB4100     CLR.B W2
006FEA  072C51     RCALL FRAMReadByte
006FEC  784F00     MOV.B W0, [W14]
245:                   u8arrTodaySchedule[12] = data;
006FEE  21C1B0     MOV #0x1C1B, W0
006FF0  78481E     MOV.B [W14], [W0]
246:                   data = FRAMReadByte(memLocScheduleStart+offset+13, 0);
006FF2  90001E     MOV [W14+2], W0
006FF4  B00260     ADD #0x26, W0
006FF6  DE80CF     ASR W0, #15, W1
006FF8  EB4100     CLR.B W2
006FFA  072C49     RCALL FRAMReadByte
006FFC  784F00     MOV.B W0, [W14]
247:                   u8arrTodaySchedule[13] = data;
006FFE  21C1C0     MOV #0x1C1C, W0
007000  78481E     MOV.B [W14], [W0]
248:                   data = FRAMReadByte(memLocScheduleStart+offset+14, 0);
007002  90001E     MOV [W14+2], W0
007004  B00270     ADD #0x27, W0
007006  DE80CF     ASR W0, #15, W1
007008  EB4100     CLR.B W2
00700A  072C41     RCALL FRAMReadByte
00700C  784F00     MOV.B W0, [W14]
249:                   u8arrTodaySchedule[14] = data;
00700E  21C1D0     MOV #0x1C1D, W0
007010  78481E     MOV.B [W14], [W0]
250:                   data = FRAMReadByte(memLocScheduleStart+offset+15, 0);
007012  90001E     MOV [W14+2], W0
007014  B00280     ADD #0x28, W0
007016  DE80CF     ASR W0, #15, W1
007018  EB4100     CLR.B W2
00701A  072C39     RCALL FRAMReadByte
00701C  784F00     MOV.B W0, [W14]
251:                   u8arrTodaySchedule[15] = data;
00701E  21C1E0     MOV #0x1C1E, W0
007020  78481E     MOV.B [W14], [W0]
252:                   data = FRAMReadByte(memLocScheduleStart+offset+16, 0);
007022  90001E     MOV [W14+2], W0
007024  B00290     ADD #0x29, W0
007026  DE80CF     ASR W0, #15, W1
007028  EB4100     CLR.B W2
00702A  072C31     RCALL FRAMReadByte
00702C  784F00     MOV.B W0, [W14]
253:                   u8arrTodaySchedule[16] = data;
00702E  21C1F0     MOV #0x1C1F, W0
007030  78481E     MOV.B [W14], [W0]
254:                   data = FRAMReadByte(memLocScheduleStart+offset+17, 0);
007032  90001E     MOV [W14+2], W0
007034  B002A0     ADD #0x2A, W0
007036  DE80CF     ASR W0, #15, W1
007038  EB4100     CLR.B W2
00703A  072C29     RCALL FRAMReadByte
00703C  784F00     MOV.B W0, [W14]
255:                   u8arrTodaySchedule[17] = data;
00703E  21C200     MOV #0x1C20, W0
007040  78481E     MOV.B [W14], [W0]
256:                   data = FRAMReadByte(memLocScheduleStart+offset+18, 0);
007042  90001E     MOV [W14+2], W0
007044  B002B0     ADD #0x2B, W0
007046  DE80CF     ASR W0, #15, W1
007048  EB4100     CLR.B W2
00704A  072C21     RCALL FRAMReadByte
00704C  784F00     MOV.B W0, [W14]
257:                   u8arrTodaySchedule[18] = data;
00704E  21C210     MOV #0x1C21, W0
007050  78481E     MOV.B [W14], [W0]
258:                   data = FRAMReadByte(memLocScheduleStart+offset+19, 0);
007052  90001E     MOV [W14+2], W0
007054  B002C0     ADD #0x2C, W0
007056  DE80CF     ASR W0, #15, W1
007058  EB4100     CLR.B W2
00705A  072C19     RCALL FRAMReadByte
00705C  784F00     MOV.B W0, [W14]
259:                   u8arrTodaySchedule[19] = data;
00705E  21C220     MOV #0x1C22, W0
007060  78481E     MOV.B [W14], [W0]
260:               }
007062  FA8000     ULNK
007064  060000     RETURN
261:               
262:               /**
263:                * Writes a 1 at the bitmap corresponding to the schedule at dayOfWeek, and schedule number
264:                *  this function assumes that dayOfWeek is in range 0-6, and schedule_num is in range 0-4
265:                *    for writing a  bit for DR event, dayOfWeek should be 0x0F, and schedule number should be 0
266:               */
267:               void WriteSingleScheduleBitmap(int dayOfWeek, int schedule_num)
268:               {
007066  FA0008     LNK #0x8
007068  980720     MOV W0, [W14+4]
00706A  980731     MOV W1, [W14+6]
269:                   uint8_t data;
270:                   uint8_t tmpu8_loc;
271:                   uint8_t tmpu8_bit;
272:                   int tmpi;
273:                   tmpu8_loc = 0;
00706C  EB4000     CLR.B W0
00706E  784F00     MOV.B W0, [W14]
274:                   switch (dayOfWeek)
007070  90002E     MOV [W14+4], W0
007072  500FE3     SUB W0, #0x3, [W15]
007074  320021     BRA Z, .L27
007076  500FE3     SUB W0, #0x3, [W15]
007078  3C0007     BRA GT, .L32
00707A  500FE1     SUB W0, #0x1, [W15]
00707C  320013     BRA Z, .L25
00707E  500FE1     SUB W0, #0x1, [W15]
007080  3C0016     BRA GT, .L26
007082  E00000     CP0 W0
007084  32000A     BRA Z, .L24
007086  370030     BRA .L23
007088  500FE5     SUB W0, #0x5, [W15]
00708A  320020     BRA Z, .L29
00708C  500FE5     SUB W0, #0x5, [W15]
00708E  350019     BRA LT, .L28
007090  500FE6     SUB W0, #0x6, [W15]
007092  320021     BRA Z, .L30
007094  500FEF     SUB W0, #0xF, [W15]
007096  320024     BRA Z, .L31
007098  370027     BRA .L23
275:                   {
276:                       case 0:
277:                           tmpu8_loc = 2;
00709A  B3C020     MOV.B #0x2, W0
00709C  784F00     MOV.B W0, [W14]
278:                           tmpu8_bit = 6;
00709E  B3C060     MOV.B #0x6, W0
0070A0  984710     MOV.B W0, [W14+1]
279:                           break;
0070A2  370022     BRA .L23
280:                       case 1:
281:                           tmpu8_loc = 2;
0070A4  B3C020     MOV.B #0x2, W0
0070A6  784F00     MOV.B W0, [W14]
282:                           tmpu8_bit = 1;
0070A8  B3C010     MOV.B #0x1, W0
0070AA  984710     MOV.B W0, [W14+1]
283:                           break;
0070AC  37001D     BRA .L23
284:                       case 2:
285:                           tmpu8_loc = 3;
0070AE  B3C030     MOV.B #0x3, W0
0070B0  784F00     MOV.B W0, [W14]
286:                           tmpu8_bit = 4;
0070B2  B3C040     MOV.B #0x4, W0
0070B4  984710     MOV.B W0, [W14+1]
287:                           break;
0070B6  370018     BRA .L23
288:                       case 3:
289:                           tmpu8_loc = 4;
0070B8  B3C040     MOV.B #0x4, W0
0070BA  784F00     MOV.B W0, [W14]
290:                           tmpu8_bit = 7;
0070BC  B3C070     MOV.B #0x7, W0
0070BE  984710     MOV.B W0, [W14+1]
291:                           break;
0070C0  370013     BRA .L23
292:                       case 4:
293:                           tmpu8_loc = 4;
0070C2  B3C040     MOV.B #0x4, W0
0070C4  784F00     MOV.B W0, [W14]
294:                           tmpu8_bit = 2;
0070C6  B3C020     MOV.B #0x2, W0
0070C8  984710     MOV.B W0, [W14+1]
295:                           break;
0070CA  37000E     BRA .L23
296:                       case 5:
297:                           tmpu8_loc = 5;
0070CC  B3C050     MOV.B #0x5, W0
0070CE  784F00     MOV.B W0, [W14]
298:                           tmpu8_bit = 5;
0070D0  B3C050     MOV.B #0x5, W0
0070D2  984710     MOV.B W0, [W14+1]
299:                           break;
0070D4  370009     BRA .L23
300:                       case 6:
301:                           tmpu8_loc = 5;
0070D6  B3C050     MOV.B #0x5, W0
0070D8  784F00     MOV.B W0, [W14]
302:                           tmpu8_bit = 0;
0070DA  EB4000     CLR.B W0
0070DC  984710     MOV.B W0, [W14+1]
303:                           break;
0070DE  370004     BRA .L23
304:                       case 0x0F:
305:                           tmpu8_loc = 1;
0070E0  B3C010     MOV.B #0x1, W0
0070E2  784F00     MOV.B W0, [W14]
306:                           tmpu8_bit = 3;
0070E4  B3C030     MOV.B #0x3, W0
0070E6  984710     MOV.B W0, [W14+1]
307:                   }
308:                   // if schedule_num is zero, the values are already set
309:                   if ( (tmpu8_loc > 0) && (schedule_num > 0) )
0070E8  78401E     MOV.B [W14], W0
0070EA  E00400     CP0.B W0
0070EC  32000F     BRA Z, .L33
0070EE  90003E     MOV [W14+6], W0
0070F0  E00000     CP0 W0
0070F2  34000C     BRA LE, .L33
310:                   {
311:                       tmpu8_bit = tmpu8_bit + schedule_num;
0070F4  90003E     MOV [W14+6], W0
0070F6  784000     MOV.B W0, W0
0070F8  90409E     MOV.B [W14+1], W1
0070FA  40C000     ADD.B W1, W0, W0
0070FC  984710     MOV.B W0, [W14+1]
312:                       if (tmpu8_bit > 7)
0070FE  90401E     MOV.B [W14+1], W0
007100  504FE7     SUB.B W0, #0x7, [W15]
007102  360004     BRA LEU, .L33
313:                       {
314:                           tmpu8_bit = tmpu8_bit % 8;
007104  90401E     MOV.B [W14+1], W0
007106  604067     AND.B W0, #0x7, W0
007108  984710     MOV.B W0, [W14+1]
315:                           tmpu8_loc -=1;
00710A  E94F1E     DEC.B [W14], [W14]
316:                       }
317:                   }
318:                   data = FRAMReadByte(memLocScheduleStart + tmpu8_loc - 1, 0);
00710C  FB801E     ZE [W14], W0
00710E  400078     ADD W0, #0x18, W0
007110  DE80CF     ASR W0, #15, W1
007112  EB4100     CLR.B W2
007114  072BBC     RCALL FRAMReadByte
007116  984720     MOV.B W0, [W14+2]
319:                   data = data | (1 << tmpu8_bit);
007118  90401E     MOV.B [W14+1], W0
00711A  FB8000     ZE W0, W0
00711C  200011     MOV #0x1, W1
00711E  DD0800     SL W1, W0, W0
007120  784080     MOV.B W0, W1
007122  90402E     MOV.B [W14+2], W0
007124  70C000     IOR.B W1, W0, W0
007126  984720     MOV.B W0, [W14+2]
320:                   FRAMWriteByte(data, memLocScheduleStart + tmpu8_loc - 1, 0);
007128  FB801E     ZE [W14], W0
00712A  400078     ADD W0, #0x18, W0
00712C  B90161     MUL.SU W0, #1, W2
00712E  EB4080     CLR.B W1
007130  90402E     MOV.B [W14+2], W0
007132  072A3F     RCALL FRAMWriteByte
321:               }
007134  FA8000     ULNK
007136  060000     RETURN
322:               
323:               /**
324:                * The bluetooth will be sending individual schedules, and hence this 
325:                * function will write a single schedule to FRAM, i.e
326:                *      each schedule contains start time (hh(0-24), mm(0-60), cool and heat set points
327:                * @param dayOfWeek
328:                * @param schedule_number
329:                * @param hhour
330:                * @param mminute
331:                * @param cool_sp
332:                * @param heat_sp
333:                */
334:               void WriteSingleSchedule(int dayOfWeek, int schedule_number,
335:                       uint8_t hhour, uint8_t mminute, uint8_t cool_sp, uint8_t heat_sp)
336:               {
007138  FA000A     LNK #0xA
00713A  980710     MOV W0, [W14+2]
00713C  980721     MOV W1, [W14+4]
00713E  984762     MOV.B W2, [W14+6]
007140  984773     MOV.B W3, [W14+7]
007142  984F04     MOV.B W4, [W14+8]
007144  984F15     MOV.B W5, [W14+9]
337:                   int offset = 5 + 20*dayOfWeek + schedule_number*4; // 5 is the schedule bitmap
007146  90001E     MOV [W14+2], W0
007148  B90065     MUL.SU W0, #5, W0
00714A  780080     MOV W0, W1
00714C  90002E     MOV [W14+4], W0
00714E  408000     ADD W1, W0, W0
007150  DD0042     SL W0, #2, W0
007152  400F65     ADD W0, #0x5, [W14]
338:                   FRAMWriteByte(hhour, memLocScheduleStart+offset, 0);
007154  78009E     MOV [W14], W1
007156  408079     ADD W1, #0x19, W0
007158  B90161     MUL.SU W0, #1, W2
00715A  EB4080     CLR.B W1
00715C  90406E     MOV.B [W14+6], W0
00715E  072A29     RCALL FRAMWriteByte
339:                   FRAMWriteByte(mminute, memLocScheduleStart+offset+1, 0);
007160  78011E     MOV [W14], W2
007162  41007A     ADD W2, #0x1A, W0
007164  B90161     MUL.SU W0, #1, W2
007166  EB4080     CLR.B W1
007168  90407E     MOV.B [W14+7], W0
00716A  072A23     RCALL FRAMWriteByte
340:                   FRAMWriteByte(cool_sp, memLocScheduleStart+offset+2, 0);
00716C  78009E     MOV [W14], W1
00716E  40807B     ADD W1, #0x1B, W0
007170  B90161     MUL.SU W0, #1, W2
007172  EB4080     CLR.B W1
007174  90480E     MOV.B [W14+8], W0
007176  072A1D     RCALL FRAMWriteByte
341:                   FRAMWriteByte(heat_sp, memLocScheduleStart+offset+3, 0);
007178  78011E     MOV [W14], W2
00717A  41007C     ADD W2, #0x1C, W0
00717C  B90161     MUL.SU W0, #1, W2
00717E  EB4080     CLR.B W1
007180  90481E     MOV.B [W14+9], W0
007182  072A17     RCALL FRAMWriteByte
342:                   WriteSingleScheduleBitmap(dayOfWeek, schedule_number);
007184  9000AE     MOV [W14+4], W1
007186  90001E     MOV [W14+2], W0
007188  07FF6E     RCALL WriteSingleScheduleBitmap
343:                   offset = 20*dayOfWeek + schedule_number*4;
00718A  90001E     MOV [W14+2], W0
00718C  B90065     MUL.SU W0, #5, W0
00718E  780080     MOV W0, W1
007190  90002E     MOV [W14+4], W0
007192  408000     ADD W1, W0, W0
007194  DD0042     SL W0, #2, W0
007196  780F00     MOV W0, [W14]
344:                   u8arrSchedule[offset] = hhour;
007198  21C230     MOV #0x1C23, W0
00719A  40001E     ADD W0, [W14], W0
00719C  9040EE     MOV.B [W14+6], W1
00719E  784801     MOV.B W1, [W0]
345:                   u8arrSchedule[offset+1] = mminute;
0071A0  E8001E     INC [W14], W0
0071A2  21C231     MOV #0x1C23, W1
0071A4  90417E     MOV.B [W14+7], W2
0071A6  787082     MOV.B W2, [W1+W0]
346:                   u8arrSchedule[offset+2] = cool_sp;
0071A8  E8801E     INC2 [W14], W0
0071AA  21C231     MOV #0x1C23, W1
0071AC  90490E     MOV.B [W14+8], W2
0071AE  787082     MOV.B W2, [W1+W0]
347:                   u8arrSchedule[offset+3] = heat_sp;
0071B0  78009E     MOV [W14], W1
0071B2  408063     ADD W1, #0x3, W0
0071B4  21C231     MOV #0x1C23, W1
0071B6  90491E     MOV.B [W14+9], W2
0071B8  787082     MOV.B W2, [W1+W0]
348:               }
0071BA  FA8000     ULNK
0071BC  060000     RETURN
349:               
350:               /**
351:                * Write DR Schedule to FRAM
352:                * DR schedule in u8arrDrEvent, and format is same as the following parameters
353:                *      month
354:                *      dayOfMonth
355:                *      hhour
356:                *      mminute
357:                *      duration_hh
358:                *      duration_mm
359:                *      cool_sp
360:                *      heat_sp
361:                */
362:               void WriteDRSchedule()
363:               {
0071BE  FA0002     LNK #0x2
364:                   int offset = 5 + 20*7; // 5 is schedule bitmap
0071C0  200910     MOV #0x91, W0
0071C2  780F00     MOV W0, [W14]
365:                   FRAMWriteByte(u8arrDrEvent[0], memLocScheduleStart+offset, 0);
0071C4  78009E     MOV [W14], W1
0071C6  408079     ADD W1, #0x19, W0
0071C8  B90161     MUL.SU W0, #1, W2
0071CA  21CAF0     MOV #0x1CAF, W0
0071CC  784010     MOV.B [W0], W0
0071CE  EB4080     CLR.B W1
0071D0  0729F0     RCALL FRAMWriteByte
366:                   FRAMWriteByte(u8arrDrEvent[1], memLocScheduleStart+offset+1, 0);
0071D2  78009E     MOV [W14], W1
0071D4  40807A     ADD W1, #0x1A, W0
0071D6  B90161     MUL.SU W0, #1, W2
0071D8  21CB00     MOV #0x1CB0, W0
0071DA  784010     MOV.B [W0], W0
0071DC  EB4080     CLR.B W1
0071DE  0729E9     RCALL FRAMWriteByte
367:                   FRAMWriteByte(u8arrDrEvent[2], memLocScheduleStart+offset+2, 0);
0071E0  78009E     MOV [W14], W1
0071E2  40807B     ADD W1, #0x1B, W0
0071E4  B90161     MUL.SU W0, #1, W2
0071E6  21CB10     MOV #0x1CB1, W0
0071E8  784010     MOV.B [W0], W0
0071EA  EB4080     CLR.B W1
0071EC  0729E2     RCALL FRAMWriteByte
368:                   FRAMWriteByte(u8arrDrEvent[3], memLocScheduleStart+offset+3, 0);
0071EE  78009E     MOV [W14], W1
0071F0  40807C     ADD W1, #0x1C, W0
0071F2  B90161     MUL.SU W0, #1, W2
0071F4  21CB20     MOV #0x1CB2, W0
0071F6  784010     MOV.B [W0], W0
0071F8  EB4080     CLR.B W1
0071FA  0729DB     RCALL FRAMWriteByte
369:                   FRAMWriteByte(u8arrDrEvent[4], memLocScheduleStart+offset+4, 0);
0071FC  78009E     MOV [W14], W1
0071FE  40807D     ADD W1, #0x1D, W0
007200  B90161     MUL.SU W0, #1, W2
007202  21CB30     MOV #0x1CB3, W0
007204  784010     MOV.B [W0], W0
007206  EB4080     CLR.B W1
007208  0729D4     RCALL FRAMWriteByte
370:                   FRAMWriteByte(u8arrDrEvent[5], memLocScheduleStart+offset+5, 0);
00720A  78009E     MOV [W14], W1
00720C  40807E     ADD W1, #0x1E, W0
00720E  B90161     MUL.SU W0, #1, W2
007210  21CB40     MOV #0x1CB4, W0
007212  784010     MOV.B [W0], W0
007214  EB4080     CLR.B W1
007216  0729CD     RCALL FRAMWriteByte
371:                   FRAMWriteByte(u8arrDrEvent[6], memLocScheduleStart+offset+6, 0);
007218  78009E     MOV [W14], W1
00721A  40807F     ADD W1, #0x1F, W0
00721C  B90161     MUL.SU W0, #1, W2
00721E  21CB50     MOV #0x1CB5, W0
007220  784010     MOV.B [W0], W0
007222  EB4080     CLR.B W1
007224  0729C6     RCALL FRAMWriteByte
372:                   FRAMWriteByte(u8arrDrEvent[7], memLocScheduleStart+offset+7, 0);
007226  200201     MOV #0x20, W1
007228  40801E     ADD W1, [W14], W0
00722A  B90161     MUL.SU W0, #1, W2
00722C  21CB60     MOV #0x1CB6, W0
00722E  784010     MOV.B [W0], W0
007230  EB4080     CLR.B W1
007232  0729BF     RCALL FRAMWriteByte
373:                   WriteSingleScheduleBitmap(0x0F, 0);
007234  EB0080     CLR W1
007236  2000F0     MOV #0xF, W0
007238  07FF16     RCALL WriteSingleScheduleBitmap
374:               }
00723A  FA8000     ULNK
00723C  060000     RETURN
375:               
376:               /**
377:                * Read the DR schedule from FRAM TO u8arrDrEvent array
378:                */
379:               void ReadDRSchedule()
380:               {
00723E  FA0002     LNK #0x2
381:                   int offset = 5 + 20*7; // 5 is schedule bitmap
007240  200910     MOV #0x91, W0
007242  780F00     MOV W0, [W14]
382:                   u8arrDrEvent[0] = FRAMReadByte(memLocScheduleStart+offset, 0);
007244  78009E     MOV [W14], W1
007246  408079     ADD W1, #0x19, W0
007248  DE80CF     ASR W0, #15, W1
00724A  EB4100     CLR.B W2
00724C  072B20     RCALL FRAMReadByte
00724E  21CAF1     MOV #0x1CAF, W1
007250  784880     MOV.B W0, [W1]
383:                   u8arrDrEvent[1] = FRAMReadByte( memLocScheduleStart+offset+1, 0);
007252  78009E     MOV [W14], W1
007254  40807A     ADD W1, #0x1A, W0
007256  DE80CF     ASR W0, #15, W1
007258  EB4100     CLR.B W2
00725A  072B19     RCALL FRAMReadByte
00725C  21CB01     MOV #0x1CB0, W1
00725E  784880     MOV.B W0, [W1]
384:                   u8arrDrEvent[2] = FRAMReadByte( memLocScheduleStart+offset+2, 0);
007260  78009E     MOV [W14], W1
007262  40807B     ADD W1, #0x1B, W0
007264  DE80CF     ASR W0, #15, W1
007266  EB4100     CLR.B W2
007268  072B12     RCALL FRAMReadByte
00726A  21CB11     MOV #0x1CB1, W1
00726C  784880     MOV.B W0, [W1]
385:                   u8arrDrEvent[3] = FRAMReadByte( memLocScheduleStart+offset+3, 0);
00726E  78009E     MOV [W14], W1
007270  40807C     ADD W1, #0x1C, W0
007272  DE80CF     ASR W0, #15, W1
007274  EB4100     CLR.B W2
007276  072B0B     RCALL FRAMReadByte
007278  21CB21     MOV #0x1CB2, W1
00727A  784880     MOV.B W0, [W1]
386:                   u8arrDrEvent[4] = FRAMReadByte( memLocScheduleStart+offset+4, 0);
00727C  78009E     MOV [W14], W1
00727E  40807D     ADD W1, #0x1D, W0
007280  DE80CF     ASR W0, #15, W1
007282  EB4100     CLR.B W2
007284  072B04     RCALL FRAMReadByte
007286  21CB31     MOV #0x1CB3, W1
007288  784880     MOV.B W0, [W1]
387:                   u8arrDrEvent[5] = FRAMReadByte( memLocScheduleStart+offset+5, 0);
00728A  78009E     MOV [W14], W1
00728C  40807E     ADD W1, #0x1E, W0
00728E  DE80CF     ASR W0, #15, W1
007290  EB4100     CLR.B W2
007292  072AFD     RCALL FRAMReadByte
007294  21CB41     MOV #0x1CB4, W1
007296  784880     MOV.B W0, [W1]
388:                   u8arrDrEvent[6] = FRAMReadByte( memLocScheduleStart+offset+6, 0);
007298  78009E     MOV [W14], W1
00729A  40807F     ADD W1, #0x1F, W0
00729C  DE80CF     ASR W0, #15, W1
00729E  EB4100     CLR.B W2
0072A0  072AF6     RCALL FRAMReadByte
0072A2  21CB51     MOV #0x1CB5, W1
0072A4  784880     MOV.B W0, [W1]
389:                   u8arrDrEvent[7] = FRAMReadByte( memLocScheduleStart+offset+7, 0);
0072A6  200201     MOV #0x20, W1
0072A8  40801E     ADD W1, [W14], W0
0072AA  DE80CF     ASR W0, #15, W1
0072AC  EB4100     CLR.B W2
0072AE  072AEF     RCALL FRAMReadByte
0072B0  21CB61     MOV #0x1CB6, W1
0072B2  784880     MOV.B W0, [W1]
390:               }
0072B4  FA8000     ULNK
0072B6  060000     RETURN
391:               
392:               /**
393:                * clears the DRSchedule in FRAM 
394:                */
395:               void ClearDRSchedule()
396:               {
0072B8  FA0002     LNK #0x2
397:                   uint8_t tmpu8;
398:                   // delete the DR event from memory
399:                   FRAMWriteLong(0x00000000, memLocScheduleStart + 5 + 7*20, 0);
0072BA  EB4200     CLR.B W4
0072BC  200AA2     MOV #0xAA, W2
0072BE  200003     MOV #0x0, W3
0072C0  B80060     MUL.UU W0, #0, W0
0072C2  072A0A     RCALL FRAMWriteLong
400:                   FRAMWriteLong(0x00000000, memLocScheduleStart + 5 + 7*20+4, 0);
0072C4  EB4200     CLR.B W4
0072C6  200AE2     MOV #0xAE, W2
0072C8  200003     MOV #0x0, W3
0072CA  B80060     MUL.UU W0, #0, W0
0072CC  072A05     RCALL FRAMWriteLong
401:                   // clear the DR event bit 
402:                   tmpu8 = FRAMReadByte(memLocScheduleStart, 0);
0072CE  EB4100     CLR.B W2
0072D0  200190     MOV #0x19, W0
0072D2  200001     MOV #0x0, W1
0072D4  072ADC     RCALL FRAMReadByte
0072D6  784F00     MOV.B W0, [W14]
403:                   tmpu8 = (uint8_t)(tmpu8 & (~0x08));
0072D8  A1341E     BCLR.B [W14], #3
404:                   FRAMWriteByte(tmpu8, memLocScheduleStart, 0);
0072DA  EB4080     CLR.B W1
0072DC  200192     MOV #0x19, W2
0072DE  200003     MOV #0x0, W3
0072E0  78401E     MOV.B [W14], W0
0072E2  072967     RCALL FRAMWriteByte
405:               }
0072E4  FA8000     ULNK
0072E6  060000     RETURN
406:               
407:               /**
408:                * Stores a single day's schedule to FRAM
409:                * todaySchedule must be correctly populated, and the Write function called to store it in FRAM
410:                * @param: dayOfWeek, 0 represents Sunday, 1 represents Monday, 2 represents Tuesday, .... 6 represents Saturday
411:                */
412:               void WriteSchedule(int dayOfWeek)
413:               {
0072E8  FA0006     LNK #0x6
0072EA  980720     MOV W0, [W14+4]
414:                   uint8_t data;
415:                   int offset = 5 + 20*dayOfWeek; // 5 is schedule bitmap
0072EC  90002E     MOV [W14+4], W0
0072EE  B90074     MUL.SU W0, #20, W0
0072F0  780000     MOV W0, W0
0072F2  400F65     ADD W0, #0x5, [W14]
416:                   data = u8arrTodaySchedule[0];
0072F4  21C0F0     MOV #0x1C0F, W0
0072F6  784090     MOV.B [W0], W1
0072F8  984721     MOV.B W1, [W14+2]
417:                   FRAMWriteByte(data,memLocScheduleStart + offset, 0 );
0072FA  78009E     MOV [W14], W1
0072FC  408079     ADD W1, #0x19, W0
0072FE  B90161     MUL.SU W0, #1, W2
007300  EB4080     CLR.B W1
007302  90402E     MOV.B [W14+2], W0
007304  072956     RCALL FRAMWriteByte
418:                   data = u8arrTodaySchedule[1];
007306  21C100     MOV #0x1C10, W0
007308  784090     MOV.B [W0], W1
00730A  984721     MOV.B W1, [W14+2]
419:                   FRAMWriteByte(data,memLocScheduleStart + offset+1, 0 );
00730C  78009E     MOV [W14], W1
00730E  40807A     ADD W1, #0x1A, W0
007310  B90161     MUL.SU W0, #1, W2
007312  EB4080     CLR.B W1
007314  90402E     MOV.B [W14+2], W0
007316  07294D     RCALL FRAMWriteByte
420:                   data = u8arrTodaySchedule[2];
007318  21C110     MOV #0x1C11, W0
00731A  784090     MOV.B [W0], W1
00731C  984721     MOV.B W1, [W14+2]
421:                   FRAMWriteByte(data,memLocScheduleStart + offset+2, 0 );
00731E  78009E     MOV [W14], W1
007320  40807B     ADD W1, #0x1B, W0
007322  B90161     MUL.SU W0, #1, W2
007324  EB4080     CLR.B W1
007326  90402E     MOV.B [W14+2], W0
007328  072944     RCALL FRAMWriteByte
422:                   data = u8arrTodaySchedule[3];
00732A  21C120     MOV #0x1C12, W0
00732C  784090     MOV.B [W0], W1
00732E  984721     MOV.B W1, [W14+2]
423:                   FRAMWriteByte(data,memLocScheduleStart + offset+3, 0 );
007330  78009E     MOV [W14], W1
007332  40807C     ADD W1, #0x1C, W0
007334  B90161     MUL.SU W0, #1, W2
007336  EB4080     CLR.B W1
007338  90402E     MOV.B [W14+2], W0
00733A  07293B     RCALL FRAMWriteByte
424:                   data = u8arrTodaySchedule[4];
00733C  21C130     MOV #0x1C13, W0
00733E  784090     MOV.B [W0], W1
007340  984721     MOV.B W1, [W14+2]
425:                   FRAMWriteByte(data,memLocScheduleStart + offset+4, 0 );
007342  78009E     MOV [W14], W1
007344  40807D     ADD W1, #0x1D, W0
007346  B90161     MUL.SU W0, #1, W2
007348  EB4080     CLR.B W1
00734A  90402E     MOV.B [W14+2], W0
00734C  072932     RCALL FRAMWriteByte
426:                   data = u8arrTodaySchedule[5];
00734E  21C140     MOV #0x1C14, W0
007350  784090     MOV.B [W0], W1
007352  984721     MOV.B W1, [W14+2]
427:                   FRAMWriteByte(data,memLocScheduleStart + offset+5, 0 );
007354  78009E     MOV [W14], W1
007356  40807E     ADD W1, #0x1E, W0
007358  B90161     MUL.SU W0, #1, W2
00735A  EB4080     CLR.B W1
00735C  90402E     MOV.B [W14+2], W0
00735E  072929     RCALL FRAMWriteByte
428:                   data = u8arrTodaySchedule[6];
007360  21C150     MOV #0x1C15, W0
007362  784090     MOV.B [W0], W1
007364  984721     MOV.B W1, [W14+2]
429:                   FRAMWriteByte(data,memLocScheduleStart + offset+6, 0 );
007366  78009E     MOV [W14], W1
007368  40807F     ADD W1, #0x1F, W0
00736A  B90161     MUL.SU W0, #1, W2
00736C  EB4080     CLR.B W1
00736E  90402E     MOV.B [W14+2], W0
007370  072920     RCALL FRAMWriteByte
430:                   data = u8arrTodaySchedule[7];
007372  21C160     MOV #0x1C16, W0
007374  784090     MOV.B [W0], W1
007376  984721     MOV.B W1, [W14+2]
431:                   FRAMWriteByte(data,memLocScheduleStart + offset+7, 0 );
007378  200201     MOV #0x20, W1
00737A  40801E     ADD W1, [W14], W0
00737C  B90161     MUL.SU W0, #1, W2
00737E  EB4080     CLR.B W1
007380  90402E     MOV.B [W14+2], W0
007382  072917     RCALL FRAMWriteByte
432:                   data = u8arrTodaySchedule[8];
007384  21C170     MOV #0x1C17, W0
007386  784090     MOV.B [W0], W1
007388  984721     MOV.B W1, [W14+2]
433:                   FRAMWriteByte(data,memLocScheduleStart + offset+8, 0 );
00738A  200211     MOV #0x21, W1
00738C  40801E     ADD W1, [W14], W0
00738E  B90161     MUL.SU W0, #1, W2
007390  EB4080     CLR.B W1
007392  90402E     MOV.B [W14+2], W0
007394  07290E     RCALL FRAMWriteByte
434:                   data = u8arrTodaySchedule[9];
007396  21C180     MOV #0x1C18, W0
007398  784090     MOV.B [W0], W1
00739A  984721     MOV.B W1, [W14+2]
435:                   FRAMWriteByte(data,memLocScheduleStart + offset+9, 0 );
00739C  200221     MOV #0x22, W1
00739E  40801E     ADD W1, [W14], W0
0073A0  B90161     MUL.SU W0, #1, W2
0073A2  EB4080     CLR.B W1
0073A4  90402E     MOV.B [W14+2], W0
0073A6  072905     RCALL FRAMWriteByte
436:                   data = u8arrTodaySchedule[10];
0073A8  21C190     MOV #0x1C19, W0
0073AA  784090     MOV.B [W0], W1
0073AC  984721     MOV.B W1, [W14+2]
437:                   FRAMWriteByte(data,memLocScheduleStart + offset+10, 0 );
0073AE  200231     MOV #0x23, W1
0073B0  40801E     ADD W1, [W14], W0
0073B2  B90161     MUL.SU W0, #1, W2
0073B4  EB4080     CLR.B W1
0073B6  90402E     MOV.B [W14+2], W0
0073B8  0728FC     RCALL FRAMWriteByte
438:                   data = u8arrTodaySchedule[11];
0073BA  21C1A0     MOV #0x1C1A, W0
0073BC  784090     MOV.B [W0], W1
0073BE  984721     MOV.B W1, [W14+2]
439:                   FRAMWriteByte(data,memLocScheduleStart + offset+11, 0 );
0073C0  200241     MOV #0x24, W1
0073C2  40801E     ADD W1, [W14], W0
0073C4  B90161     MUL.SU W0, #1, W2
0073C6  EB4080     CLR.B W1
0073C8  90402E     MOV.B [W14+2], W0
0073CA  0728F3     RCALL FRAMWriteByte
440:                   data = u8arrTodaySchedule[12];
0073CC  21C1B0     MOV #0x1C1B, W0
0073CE  784090     MOV.B [W0], W1
0073D0  984721     MOV.B W1, [W14+2]
441:                   FRAMWriteByte(data,memLocScheduleStart + offset+12, 0 );
0073D2  200251     MOV #0x25, W1
0073D4  40801E     ADD W1, [W14], W0
0073D6  B90161     MUL.SU W0, #1, W2
0073D8  EB4080     CLR.B W1
0073DA  90402E     MOV.B [W14+2], W0
0073DC  0728EA     RCALL FRAMWriteByte
442:                   data = u8arrTodaySchedule[13];
0073DE  21C1C0     MOV #0x1C1C, W0
0073E0  784090     MOV.B [W0], W1
0073E2  984721     MOV.B W1, [W14+2]
443:                   FRAMWriteByte(data,memLocScheduleStart + offset+13, 0 );
0073E4  200261     MOV #0x26, W1
0073E6  40801E     ADD W1, [W14], W0
0073E8  B90161     MUL.SU W0, #1, W2
0073EA  EB4080     CLR.B W1
0073EC  90402E     MOV.B [W14+2], W0
0073EE  0728E1     RCALL FRAMWriteByte
444:                   data = u8arrTodaySchedule[14];
0073F0  21C1D0     MOV #0x1C1D, W0
0073F2  784090     MOV.B [W0], W1
0073F4  984721     MOV.B W1, [W14+2]
445:                   FRAMWriteByte(data,memLocScheduleStart + offset+14, 0 );
0073F6  200271     MOV #0x27, W1
0073F8  40801E     ADD W1, [W14], W0
0073FA  B90161     MUL.SU W0, #1, W2
0073FC  EB4080     CLR.B W1
0073FE  90402E     MOV.B [W14+2], W0
007400  0728D8     RCALL FRAMWriteByte
446:                   data = u8arrTodaySchedule[15];
007402  21C1E0     MOV #0x1C1E, W0
007404  784090     MOV.B [W0], W1
007406  984721     MOV.B W1, [W14+2]
447:                   FRAMWriteByte(data,memLocScheduleStart + offset+15, 0 );
007408  200281     MOV #0x28, W1
00740A  40801E     ADD W1, [W14], W0
00740C  B90161     MUL.SU W0, #1, W2
00740E  EB4080     CLR.B W1
007410  90402E     MOV.B [W14+2], W0
007412  0728CF     RCALL FRAMWriteByte
448:               }
007414  FA8000     ULNK
007416  060000     RETURN
449:               
450:               
451:               /*
452:                * Read/ Write the location memLocBufferInitialized to indicate if the system is executing for the 
453:                *      first time, or has some data from earlier state
454:                *      if first time write BufferInitializedWriteValue (0x6D) to location
455:                *          else do not do any initialization
456:                */
457:               void WriteBuffersInitialized()
458:               {
007418  FA0002     LNK #0x2
459:                   uint8_t data;
460:                   data = ReadBuffersInitialized();
00741A  07000E     RCALL ReadBuffersInitialized
00741C  784F00     MOV.B W0, [W14]
461:                   if (data != (uint8_t)BufferInitializedWriteValue) {
00741E  B3C6D0     MOV.B #0x6D, W0
007420  78409E     MOV.B [W14], W1
007422  50CF80     SUB.B W1, W0, [W15]
007424  320007     BRA Z, .L39
462:                       data = (uint8_t)BufferInitializedWriteValue;
007426  B3C6D0     MOV.B #0x6D, W0
007428  784F00     MOV.B W0, [W14]
463:                       FRAMWriteByte(data, memLocBufferInitialized, 0);
00742A  EB4080     CLR.B W1
00742C  2000D2     MOV #0xD, W2
00742E  200003     MOV #0x0, W3
007430  78401E     MOV.B [W14], W0
007432  0728BF     RCALL FRAMWriteByte
464:                   }
465:               }
007434  FA8000     ULNK
007436  060000     RETURN
466:               uint8_t ReadBuffersInitialized()
467:               {
007438  FA0002     LNK #0x2
468:                   uint8_t data;
469:                   data = FRAMReadByte(memLocBufferInitialized, 0);
00743A  EB4100     CLR.B W2
00743C  2000D0     MOV #0xD, W0
00743E  200001     MOV #0x0, W1
007440  072A26     RCALL FRAMReadByte
007442  784F00     MOV.B W0, [W14]
470:                   return data;
007444  78401E     MOV.B [W14], W0
471:               }
007446  FA8000     ULNK
007448  060000     RETURN
472:               
473:               
474:               /*
475:                * Buffer for temperature data stored in FRAM
476:                * initialize:
477:                *     this function initializes the buffer for setpoint data storage
478:                *     - set head to 0, 
479:                *     - set tail to 0, 
480:                *     - set capacity to TemperatureBufferCapacity (max based on allocated storage)
481:                *     - set count to 0,
482:                *     - set overtide count to 0,
483:                *     - set all rtc time base bytes to 0
484:                *    This function is called only when buffers are not Initialized, and  WriteBuffersInitialized() is called before calling this function
485:                */
486:               void TemperatureBufferInit()
487:               {
00744A  FA0002     LNK #0x2
488:                   uint8_t data;
489:                   data = ReadBuffersInitialized();
00744C  07FFF5     RCALL ReadBuffersInitialized
00744E  784F00     MOV.B W0, [W14]
490:                   if (data == (uint8_t)BufferInitializedWriteValue ) 
007450  B3C6D0     MOV.B #0x6D, W0
007452  78409E     MOV.B [W14], W1
007454  50CF80     SUB.B W1, W0, [W15]
007456  3A0032     BRA NZ, .L42
491:                   {
492:                       // initialize the temperature buffer
493:                       // set head to zero
494:                       FRAMWriteWord(0x0000, memLocTemperatureBufferStart, 0);
007458  EB4080     CLR.B W1
00745A  239502     MOV #0x3950, W2
00745C  200013     MOV #0x1, W3
00745E  EB0000     CLR W0
007460  0728E8     RCALL FRAMWriteWord
495:                       // set tail to zero
496:                       FRAMWriteWord(0x0000, memLocTemperatureBufferStart+2, 0);
007462  EB4080     CLR.B W1
007464  239522     MOV #0x3952, W2
007466  200013     MOV #0x1, W3
007468  EB0000     CLR W0
00746A  0728E3     RCALL FRAMWriteWord
497:                       // set capacity to TemperatureBufferCapacity
498:                       FRAMWriteWord((uint16_t)TemperatureBufferMaxCapacity, memLocTemperatureBufferStart+4, 0);
00746C  EB4080     CLR.B W1
00746E  239542     MOV #0x3954, W2
007470  200013     MOV #0x1, W3
007472  2B1A80     MOV #0xB1A8, W0
007474  0728DE     RCALL FRAMWriteWord
499:                       // set count to zero
500:                       FRAMWriteWord(0x0000, memLocTemperatureBufferStart+6, 0);
007476  EB4080     CLR.B W1
007478  239562     MOV #0x3956, W2
00747A  200013     MOV #0x1, W3
00747C  EB0000     CLR W0
00747E  0728D9     RCALL FRAMWriteWord
501:                       // set override count to zero
502:                       FRAMWriteWord(0x0000, memLocTemperatureBufferStart+8, 0);
007480  EB4080     CLR.B W1
007482  239582     MOV #0x3958, W2
007484  200013     MOV #0x1, W3
007486  EB0000     CLR W0
007488  0728D4     RCALL FRAMWriteWord
503:                       // set all rtc time base bytes to zero
504:                       FRAMWriteByte(0x00, memLocTemperatureBufferStart+10, 0);
00748A  EB4080     CLR.B W1
00748C  2395A2     MOV #0x395A, W2
00748E  200013     MOV #0x1, W3
007490  EB4000     CLR.B W0
007492  07288F     RCALL FRAMWriteByte
505:                       FRAMWriteByte(0x00, memLocTemperatureBufferStart+11, 0);
007494  EB4080     CLR.B W1
007496  2395B2     MOV #0x395B, W2
007498  200013     MOV #0x1, W3
00749A  EB4000     CLR.B W0
00749C  07288A     RCALL FRAMWriteByte
506:                       FRAMWriteByte(0x00, memLocTemperatureBufferStart+12, 0);
00749E  EB4080     CLR.B W1
0074A0  2395C2     MOV #0x395C, W2
0074A2  200013     MOV #0x1, W3
0074A4  EB4000     CLR.B W0
0074A6  072885     RCALL FRAMWriteByte
507:                       FRAMWriteByte(0x00, memLocTemperatureBufferStart+13, 0);
0074A8  EB4080     CLR.B W1
0074AA  2395D2     MOV #0x395D, W2
0074AC  200013     MOV #0x1, W3
0074AE  EB4000     CLR.B W0
0074B0  072880     RCALL FRAMWriteByte
508:                       FRAMWriteByte(0x00, memLocTemperatureBufferStart+14, 0);
0074B2  EB4080     CLR.B W1
0074B4  2395E2     MOV #0x395E, W2
0074B6  200013     MOV #0x1, W3
0074B8  EB4000     CLR.B W0
0074BA  07287B     RCALL FRAMWriteByte
509:                   }
510:               }
0074BC  FA8000     ULNK
0074BE  060000     RETURN
511:               
512:               /*
513:                * u8CurrentTemperature stores the current temperature
514:                * write the value in u8CurrentTemperature to temperature buffer 
515:                * This function writes the temperature stored in u8CurrentTemperature to the tmeperature buffer
516:                */
517:               void WriteTemperatureBuffer()
518:               {
0074C0  FA0040     LNK #0x40
0074C2  781F88     MOV W8, [W15++]
519:                   uint8_t data;
520:                   uint32_t u32data;
521:                   uint16_t count_in_tempbuf;
522:                   double diff_time;
523:                   time_t base_t, curr_t;
524:                   int offset;
525:                   uint16_t tmpu16;
526:                   struct tm base_time;
527:                   struct tm curr_time;
528:                   uint16_t head;
529:                   uint16_t capacity;
530:                   data = ReadBuffersInitialized();
0074C4  07FFB9     RCALL ReadBuffersInitialized
0074C6  984F00     MOV.B W0, [W14+8]
531:                   if (data != BufferInitializedWriteValue)
0074C8  90488E     MOV.B [W14+8], W1
0074CA  B3C6D0     MOV.B #0x6D, W0
0074CC  50CF80     SUB.B W1, W0, [W15]
0074CE  3A010B     BRA NZ, .L55
532:                   {
533:                       return;
0076E6  000000     NOP
0076E8  370003     BRA .L44
534:                   }
535:                   count_in_tempbuf = FRAMReadWord(memLocTemperatureBufferStart + 6, 0);
0074D0  EB4100     CLR.B W2
0074D2  239560     MOV #0x3956, W0
0074D4  200011     MOV #0x1, W1
0074D6  072A00     RCALL FRAMReadWord
0074D8  980750     MOV W0, [W14+10]
536:                   // TODO: create circular buffer
537:                   // for now if we reach max capacity, we stop writing
538:                   head = FRAMReadWord(memLocTemperatureBufferStart, 0 );
0074DA  EB4100     CLR.B W2
0074DC  239500     MOV #0x3950, W0
0074DE  200011     MOV #0x1, W1
0074E0  0729FB     RCALL FRAMReadWord
0074E2  980760     MOV W0, [W14+12]
539:                   capacity = FRAMReadWord(memLocTemperatureBufferStart + 4, 0);
0074E4  EB4100     CLR.B W2
0074E6  239540     MOV #0x3954, W0
0074E8  200011     MOV #0x1, W1
0074EA  0729F6     RCALL FRAMReadWord
0074EC  980770     MOV W0, [W14+14]
540:                   // reached max capacity return
541:                   if (count_in_tempbuf >= capacity) {
0074EE  9000DE     MOV [W14+10], W1
0074F0  90007E     MOV [W14+14], W0
0074F2  508F80     SUB W1, W0, [W15]
0074F4  3100FA     BRA C, .L56
542:                       return;
0076EA  000000     NOP
0076EC  370001     BRA .L44
543:                   }
544:                   if (count_in_tempbuf == 0)
0074F6  90005E     MOV [W14+10], W0
0074F8  E00000     CP0 W0
0074FA  3A0028     BRA NZ, .L48
545:                   {
546:                       // write the current timestamp to rtc time base
547:                       RTCC_TimeGet(&base_time);
0074FC  47007C     ADD W14, #0x1C, W0
0074FE  072B44     RCALL RTCC_TimeGet
548:                       data = base_time.tm_year;
007500  90103E     MOV [W14+38], W0
007502  984F00     MOV.B W0, [W14+8]
549:                       FRAMWriteByte(data, memLocTemperatureBufferStart + 10, 0);
007504  EB4080     CLR.B W1
007506  2395A2     MOV #0x395A, W2
007508  200013     MOV #0x1, W3
00750A  90480E     MOV.B [W14+8], W0
00750C  072852     RCALL FRAMWriteByte
550:                       data = base_time.tm_mon;
00750E  90102E     MOV [W14+36], W0
007510  984F00     MOV.B W0, [W14+8]
551:                       FRAMWriteByte(data, memLocTemperatureBufferStart + 11, 0);
007512  EB4080     CLR.B W1
007514  2395B2     MOV #0x395B, W2
007516  200013     MOV #0x1, W3
007518  90480E     MOV.B [W14+8], W0
00751A  07284B     RCALL FRAMWriteByte
552:                       data = base_time.tm_mday;
00751C  90101E     MOV [W14+34], W0
00751E  984F00     MOV.B W0, [W14+8]
553:                       FRAMWriteByte(data, memLocTemperatureBufferStart + 12, 0);
007520  EB4080     CLR.B W1
007522  2395C2     MOV #0x395C, W2
007524  200013     MOV #0x1, W3
007526  90480E     MOV.B [W14+8], W0
007528  072844     RCALL FRAMWriteByte
554:                       data = base_time.tm_hour;
00752A  90100E     MOV [W14+32], W0
00752C  984F00     MOV.B W0, [W14+8]
555:                       FRAMWriteByte(data, memLocTemperatureBufferStart + 13, 0);
00752E  EB4080     CLR.B W1
007530  2395D2     MOV #0x395D, W2
007532  200013     MOV #0x1, W3
007534  90480E     MOV.B [W14+8], W0
007536  07283D     RCALL FRAMWriteByte
556:                       data = base_time.tm_min;
007538  90087E     MOV [W14+30], W0
00753A  984F00     MOV.B W0, [W14+8]
557:                       FRAMWriteByte(data, memLocTemperatureBufferStart + 14, 0);
00753C  EB4080     CLR.B W1
00753E  2395E2     MOV #0x395E, W2
007540  200013     MOV #0x1, W3
007542  90480E     MOV.B [W14+8], W0
007544  072836     RCALL FRAMWriteByte
558:                       u32data = 0x00;
007546  B80060     MUL.UU W0, #0, W0
007548  BE8F00     MOV.D W0, [W14]
00754A  370067     BRA .L49
559:                       
560:                   }
561:                   else 
562:                   {
563:                       RTCC_TimeGet(&curr_time);
00754C  2002E0     MOV #0x2E, W0
00754E  40000E     ADD W0, W14, W0
007550  072B1B     RCALL RTCC_TimeGet
564:                       // read the rtc time base from buffer
565:                       data = FRAMReadByte(memLocTemperatureBufferStart + 10, 0);
007552  EB4100     CLR.B W2
007554  2395A0     MOV #0x395A, W0
007556  200011     MOV #0x1, W1
007558  07299A     RCALL FRAMReadByte
00755A  984F00     MOV.B W0, [W14+8]
566:                       base_time.tm_year = (int)data;
00755C  90480E     MOV.B [W14+8], W0
00755E  FB8000     ZE W0, W0
007560  981730     MOV W0, [W14+38]
567:                       data = FRAMReadByte(memLocTemperatureBufferStart + 11, 0);
007562  EB4100     CLR.B W2
007564  2395B0     MOV #0x395B, W0
007566  200011     MOV #0x1, W1
007568  072992     RCALL FRAMReadByte
00756A  984F00     MOV.B W0, [W14+8]
568:                       base_time.tm_mon = (int)data;
00756C  90480E     MOV.B [W14+8], W0
00756E  FB8000     ZE W0, W0
007570  981720     MOV W0, [W14+36]
569:                       data = FRAMReadByte(memLocTemperatureBufferStart + 12, 0);
007572  EB4100     CLR.B W2
007574  2395C0     MOV #0x395C, W0
007576  200011     MOV #0x1, W1
007578  07298A     RCALL FRAMReadByte
00757A  984F00     MOV.B W0, [W14+8]
570:                       base_time.tm_mday = (int)data;
00757C  90480E     MOV.B [W14+8], W0
00757E  FB8000     ZE W0, W0
007580  981710     MOV W0, [W14+34]
571:                       data = FRAMReadByte(memLocTemperatureBufferStart + 13, 0);
007582  EB4100     CLR.B W2
007584  2395D0     MOV #0x395D, W0
007586  200011     MOV #0x1, W1
007588  072982     RCALL FRAMReadByte
00758A  984F00     MOV.B W0, [W14+8]
572:                       base_time.tm_hour = (int)data;
00758C  90480E     MOV.B [W14+8], W0
00758E  FB8000     ZE W0, W0
007590  981700     MOV W0, [W14+32]
573:                       data = FRAMReadByte(memLocTemperatureBufferStart + 11, 0);
007592  EB4100     CLR.B W2
007594  2395B0     MOV #0x395B, W0
007596  200011     MOV #0x1, W1
007598  07297A     RCALL FRAMReadByte
00759A  984F00     MOV.B W0, [W14+8]
574:                       base_time.tm_min = (int)data;
00759C  90480E     MOV.B [W14+8], W0
00759E  FB8000     ZE W0, W0
0075A0  980F70     MOV W0, [W14+30]
575:                       base_time.tm_sec = 0;
0075A2  EB0000     CLR W0
0075A4  980F60     MOV W0, [W14+28]
576:                       base_t = mktime(&base_time);
0075A6  47007C     ADD W14, #0x1C, W0
0075A8  07CBB1     RCALL _mktime
0075AA  980F00     MOV W0, [W14+16]
0075AC  980F11     MOV W1, [W14+18]
577:                       curr_t = mktime(&curr_time);
0075AE  2002E0     MOV #0x2E, W0
0075B0  40000E     ADD W0, W14, W0
0075B2  07CBAC     RCALL _mktime
0075B4  980F20     MOV W0, [W14+20]
0075B6  980F31     MOV W1, [W14+22]
578:                       diff_time = difftime(curr_t, base_t);
0075B8  90090E     MOV [W14+16], W2
0075BA  90099E     MOV [W14+18], W3
0075BC  90082E     MOV [W14+20], W0
0075BE  9008BE     MOV [W14+22], W1
0075C0  07CB86     RCALL _difftime
0075C2  980720     MOV W0, [W14+4]
0075C4  980731     MOV W1, [W14+6]
579:                       if (diff_time < 0)
0075C6  B3C018     MOV.B #0x1, W8
0075C8  B81160     MUL.UU W2, #0, W2
0075CA  90002E     MOV [W14+4], W0
0075CC  9000BE     MOV [W14+6], W1
0075CE  07C7B4     RCALL ___ltsf2, ___eqsf2, ___lesf2
0075D0  E00000     CP0 W0
0075D2  350001     BRA LT, .L50
0075D4  EB4400     CLR.B W8
0075D6  E00408     CP0.B W8
0075D8  320005     BRA Z, .L51
580:                       {
581:                           diff_time = -diff_time;
0075DA  90002E     MOV [W14+4], W0
0075DC  9000BE     MOV [W14+6], W1
0075DE  A2F001     BTG W1, #15
0075E0  980720     MOV W0, [W14+4]
0075E2  980731     MOV W1, [W14+6]
582:                       }
583:                       diff_time = diff_time / 60.0; // convert to minutes;
0075E4  200002     MOV #0x0, W2
0075E6  242703     MOV #0x4270, W3
0075E8  90002E     MOV [W14+4], W0
0075EA  9000BE     MOV [W14+6], W1
0075EC  07C754     RCALL ___divsf3
0075EE  980720     MOV W0, [W14+4]
0075F0  980731     MOV W1, [W14+6]
584:                       if (diff_time > (double)0xFFFF)
0075F2  B3C018     MOV.B #0x1, W8
0075F4  2FF002     MOV #0xFF00, W2
0075F6  2477F3     MOV #0x477F, W3
0075F8  90002E     MOV [W14+4], W0
0075FA  9000BE     MOV [W14+6], W1
0075FC  07C79F     RCALL ___gesf2, ___gtsf2
0075FE  E00000     CP0 W0
007600  3C0001     BRA GT, .L52
007602  EB4400     CLR.B W8
007604  E00408     CP0.B W8
007606  320003     BRA Z, .L53
585:                       {
586:                           u32data = 0;
007608  B80060     MUL.UU W0, #0, W0
00760A  BE8F00     MOV.D W0, [W14]
00760C  370006     BRA .L49
587:                       }
588:                       else 
589:                       {
590:                           u32data =(int) diff_time;
00760E  90002E     MOV [W14+4], W0
007610  9000BE     MOV [W14+6], W1
007612  07C796     RCALL ___fixsfsi
007614  780000     MOV W0, W0
007616  DE80CF     ASR W0, #15, W1
007618  BE8F00     MOV.D W0, [W14]
591:                       }
592:                   }
593:                   if ( (u32data == 0) && ( count_in_tempbuf  > 0) )
00761A  BE001E     MOV.D [W14], W0
00761C  500FE0     SUB W0, #0x0, [W15]
00761E  588FE0     SUBB W1, #0x0, [W15]
007620  3A0003     BRA NZ, .L54
007622  90005E     MOV [W14+10], W0
007624  E00000     CP0 W0
007626  3A0063     BRA NZ, .L57
594:                   {
595:                       // cannot report data since not enough space to store time
596:                       return;
0076EE  000000     NOP
597:                   }
598:                   //offset = count_in_tempbuf * 4 + 15; // memLocTemperatureBufferStart;
599:                   offset = head * 4 + 15;
007628  90006E     MOV [W14+12], W0
00762A  DD0042     SL W0, #2, W0
00762C  40006F     ADD W0, #0xF, W0
00762E  980F40     MOV W0, [W14+24]
600:                   tmpu16 = (head + 1) % capacity;
007630  90006E     MOV [W14+12], W0
007632  E80080     INC W0, W1
007634  90007E     MOV [W14+14], W0
007636  780100     MOV W0, W2
007638  090011     REPEAT #0x11
00763A  D88082     DIV.UW W1, W2
00763C  FD0080     EXCH W0, W1
00763E  980F50     MOV W0, [W14+26]
601:                   data = (uint8_t)(u32data & 0xFF); // Little endian format
007640  78001E     MOV [W14], W0
007642  984F00     MOV.B W0, [W14+8]
602:                   FRAMWriteByte(data, memLocTemperatureBufferStart + offset, 0 );
007644  90084E     MOV [W14+24], W0
007646  B90161     MUL.SU W0, #1, W2
007648  239500     MOV #0x3950, W0
00764A  200011     MOV #0x1, W1
00764C  400002     ADD W0, W2, W0
00764E  488083     ADDC W1, W3, W1
007650  BE0100     MOV.D W0, W2
007652  EB4080     CLR.B W1
007654  90480E     MOV.B [W14+8], W0
007656  0727AD     RCALL FRAMWriteByte
603:                   data = (uint8_t)( (u32data & 0xFF00) >> 8); // Little endian format
007658  2FF000     MOV #0xFF00, W0
00765A  200001     MOV #0x0, W1
00765C  BE011E     MOV.D [W14], W2
00765E  780202     MOV W2, W4
007660  780103     MOV W3, W2
007662  780180     MOV W0, W3
007664  780001     MOV W1, W0
007666  620203     AND W4, W3, W4
007668  610000     AND W2, W0, W0
00766A  EB0080     CLR W1
00766C  DD00C0     SL W0, #0, W1
00766E  200000     MOV #0x0, W0
007670  BE0100     MOV.D W0, W2
007672  B82061     MUL.UU W4, #1, W0
007674  710100     IOR W2, W0, W2
007676  718181     IOR W3, W1, W3
007678  DD1A48     SL W3, #8, W4
00767A  DE1048     LSR W2, #8, W0
00767C  720000     IOR W4, W0, W0
00767E  DE18C8     LSR W3, #8, W1
007680  984F00     MOV.B W0, [W14+8]
604:                   FRAMWriteByte(data, memLocTemperatureBufferStart + offset + 1, 0);
007682  90084E     MOV [W14+24], W0
007684  B90161     MUL.SU W0, #1, W2
007686  239510     MOV #0x3951, W0
007688  200011     MOV #0x1, W1
00768A  400002     ADD W0, W2, W0
00768C  488083     ADDC W1, W3, W1
00768E  BE0100     MOV.D W0, W2
007690  EB4080     CLR.B W1
007692  90480E     MOV.B [W14+8], W0
007694  07278E     RCALL FRAMWriteByte
605:                   data = u8CurrentTemperature;
007696  208C01     MOV #0x8C0, W1
007698  784091     MOV.B [W1], W1
00769A  984F01     MOV.B W1, [W14+8]
606:                   FRAMWriteByte(data, memLocTemperatureBufferStart + offset + 2, 0);
00769C  90084E     MOV [W14+24], W0
00769E  B90161     MUL.SU W0, #1, W2
0076A0  239520     MOV #0x3952, W0
0076A2  200011     MOV #0x1, W1
0076A4  400002     ADD W0, W2, W0
0076A6  488083     ADDC W1, W3, W1
0076A8  BE0100     MOV.D W0, W2
0076AA  EB4080     CLR.B W1
0076AC  90480E     MOV.B [W14+8], W0
0076AE  072781     RCALL FRAMWriteByte
607:                   data = u8RelativeHumidity;
0076B0  208D42     MOV #0x8D4, W2
0076B2  784112     MOV.B [W2], W2
0076B4  984F02     MOV.B W2, [W14+8]
608:                   FRAMWriteByte(data, memLocTemperatureBufferStart + offset + 3, 0);
0076B6  90084E     MOV [W14+24], W0
0076B8  B90161     MUL.SU W0, #1, W2
0076BA  239530     MOV #0x3953, W0
0076BC  200011     MOV #0x1, W1
0076BE  400002     ADD W0, W2, W0
0076C0  488083     ADDC W1, W3, W1
0076C2  BE0100     MOV.D W0, W2
0076C4  EB4080     CLR.B W1
0076C6  90480E     MOV.B [W14+8], W0
0076C8  072774     RCALL FRAMWriteByte
609:                   // write number_of_items + 1 to fram
610:                   FRAMWriteWord(tmpu16, memLocTemperatureBufferStart, 0);
0076CA  EB4080     CLR.B W1
0076CC  239502     MOV #0x3950, W2
0076CE  200013     MOV #0x1, W3
0076D0  90085E     MOV [W14+26], W0
0076D2  0727AF     RCALL FRAMWriteWord
611:                   tmpu16 = (uint16_t)(count_in_tempbuf + 1);
0076D4  90005E     MOV [W14+10], W0
0076D6  E80000     INC W0, W0
0076D8  980F50     MOV W0, [W14+26]
612:                   FRAMWriteWord(tmpu16, memLocTemperatureBufferStart + 6, 0);
0076DA  EB4080     CLR.B W1
0076DC  239562     MOV #0x3956, W2
0076DE  200013     MOV #0x1, W3
0076E0  90085E     MOV [W14+26], W0
0076E2  0727A7     RCALL FRAMWriteWord
0076E4  370005     BRA .L44
613:               }
0076F0  78044F     MOV [--W15], W8
0076F2  FA8000     ULNK
0076F4  060000     RETURN
614:               
615:               /**
616:                * ReadTemperatureBuffer
617:                *  arguments 
618:                *      number_of_samples to read
619:                *      data_buf(uint8_t *) for storing return elements;this must be allocated before the call
620:                *      data_buf_len: length of buffer created
621:                * 
622:                *  return value:
623:                *      int: 
624:                *          number of uint8_t bytes written to data_buf if successful
625:                *          -1 if data_buf_len is less than the required length for number of elements
626:                *          -2 if temperature buffer is empty
627:                *          -3 if buffer in FRAM has not been initialized
628:                * 
629:                *  format of data_buf returned
630:                *      first 5 bytes base timestamp as stored in FRAM
631:                *      4 BYTES per sample each
632:                *               
633:                */
634:               int ReadTemperatureBuffer(int number_of_samples, uint8_t * data_buf, int data_buf_len)
635:               {
0076F6  FA0014     LNK #0x14
0076F8  980770     MOV W0, [W14+14]
0076FA  980F01     MOV W1, [W14+16]
0076FC  980F12     MOV W2, [W14+18]
636:                   uint8_t data;
637:                   int buf_ret_count = 0;
0076FE  EB0000     CLR W0
007700  780F00     MOV W0, [W14]
638:                   uint16_t count_in_tempbuf;
639:                   int ii;
640:                   uint16_t tail;
641:                   uint16_t capacity;
642:                   int offset;
643:                   
644:                   data = ReadBuffersInitialized();
007702  07FE9A     RCALL ReadBuffersInitialized
007704  984F00     MOV.B W0, [W14+8]
645:                   if (data != BufferInitializedWriteValue)
007706  90488E     MOV.B [W14+8], W1
007708  B3C6D0     MOV.B #0x6D, W0
00770A  50CF80     SUB.B W1, W0, [W15]
00770C  320002     BRA Z, .L59
646:                   {
647:                       return -3;
00770E  2FFFD0     MOV #0xFFFD, W0
007710  3700AE     BRA .L60
648:                   }
649:                   if ( (number_of_samples * 4 + 5) > data_buf_len) 
007712  90007E     MOV [W14+14], W0
007714  DD0042     SL W0, #2, W0
007716  4000E5     ADD W0, #0x5, W1
007718  90081E     MOV [W14+18], W0
00771A  508F80     SUB W1, W0, [W15]
00771C  340002     BRA LE, .L61
650:                   {
651:                       // insufficient space to return data
652:                       return -1;
00771E  EB8000     SETM W0
007720  3700A6     BRA .L60
653:                   }
654:                   count_in_tempbuf = FRAMReadWord(memLocTemperatureBufferStart + 6, 0);
007722  EB4100     CLR.B W2
007724  239560     MOV #0x3956, W0
007726  200011     MOV #0x1, W1
007728  0728D7     RCALL FRAMReadWord
00772A  980710     MOV W0, [W14+2]
655:                   if ( count_in_tempbuf == 0)
00772C  90001E     MOV [W14+2], W0
00772E  E00000     CP0 W0
007730  3A0002     BRA NZ, .L62
656:                   {
657:                       return -2;
007732  2FFFE0     MOV #0xFFFE, W0
007734  37009C     BRA .L60
658:                   }
659:                   tail = FRAMReadWord(memLocTemperatureBufferStart + 2, 0);
007736  EB4100     CLR.B W2
007738  239520     MOV #0x3952, W0
00773A  200011     MOV #0x1, W1
00773C  0728CD     RCALL FRAMReadWord
00773E  980730     MOV W0, [W14+6]
660:                   capacity = FRAMReadWord(memLocTemperatureBufferStart + 4, 0);
007740  EB4100     CLR.B W2
007742  239540     MOV #0x3954, W0
007744  200011     MOV #0x1, W1
007746  0728C8     RCALL FRAMReadWord
007748  980750     MOV W0, [W14+10]
661:                   
662:                   buf_ret_count = 0;
00774A  EB0000     CLR W0
00774C  780F00     MOV W0, [W14]
663:                   data = FRAMReadByte(memLocTemperatureBufferStart + 10, 0);
00774E  EB4100     CLR.B W2
007750  2395A0     MOV #0x395A, W0
007752  200011     MOV #0x1, W1
007754  07289C     RCALL FRAMReadByte
007756  984F00     MOV.B W0, [W14+8]
664:                   data_buf[buf_ret_count] = data;
007758  78001E     MOV [W14], W0
00775A  90088E     MOV [W14+16], W1
00775C  408000     ADD W1, W0, W0
00775E  90488E     MOV.B [W14+8], W1
007760  784801     MOV.B W1, [W0]
665:                   buf_ret_count ++;
007762  E80F1E     INC [W14], [W14]
666:                   data = FRAMReadByte(memLocTemperatureBufferStart + 11, 0);
007764  EB4100     CLR.B W2
007766  2395B0     MOV #0x395B, W0
007768  200011     MOV #0x1, W1
00776A  072891     RCALL FRAMReadByte
00776C  984F00     MOV.B W0, [W14+8]
667:                   data_buf[buf_ret_count] = data; 
00776E  78001E     MOV [W14], W0
007770  90088E     MOV [W14+16], W1
007772  408000     ADD W1, W0, W0
007774  90490E     MOV.B [W14+8], W2
007776  784802     MOV.B W2, [W0]
668:                   buf_ret_count ++;
007778  E80F1E     INC [W14], [W14]
669:                   data = FRAMReadByte(memLocTemperatureBufferStart + 12, 0);
00777A  EB4100     CLR.B W2
00777C  2395C0     MOV #0x395C, W0
00777E  200011     MOV #0x1, W1
007780  072886     RCALL FRAMReadByte
007782  984F00     MOV.B W0, [W14+8]
670:                   data_buf[buf_ret_count] = data;
007784  78001E     MOV [W14], W0
007786  90088E     MOV [W14+16], W1
007788  408000     ADD W1, W0, W0
00778A  90488E     MOV.B [W14+8], W1
00778C  784801     MOV.B W1, [W0]
671:                   buf_ret_count ++;
00778E  E80F1E     INC [W14], [W14]
672:                   data = FRAMReadByte(memLocTemperatureBufferStart + 13, 0);
007790  EB4100     CLR.B W2
007792  2395D0     MOV #0x395D, W0
007794  200011     MOV #0x1, W1
007796  07287B     RCALL FRAMReadByte
007798  984F00     MOV.B W0, [W14+8]
673:                   data_buf[buf_ret_count] = data;
00779A  78001E     MOV [W14], W0
00779C  90088E     MOV [W14+16], W1
00779E  408000     ADD W1, W0, W0
0077A0  90490E     MOV.B [W14+8], W2
0077A2  784802     MOV.B W2, [W0]
674:                   buf_ret_count ++;
0077A4  E80F1E     INC [W14], [W14]
675:                   data = FRAMReadByte(memLocTemperatureBufferStart + 11, 0);
0077A6  EB4100     CLR.B W2
0077A8  2395B0     MOV #0x395B, W0
0077AA  200011     MOV #0x1, W1
0077AC  072870     RCALL FRAMReadByte
0077AE  984F00     MOV.B W0, [W14+8]
676:                   data_buf[buf_ret_count] = data;
0077B0  78001E     MOV [W14], W0
0077B2  90088E     MOV [W14+16], W1
0077B4  408000     ADD W1, W0, W0
0077B6  90488E     MOV.B [W14+8], W1
0077B8  784801     MOV.B W1, [W0]
677:                   buf_ret_count ++;
0077BA  E80F1E     INC [W14], [W14]
678:                   ii = 0;
0077BC  EB0000     CLR W0
0077BE  980720     MOV W0, [W14+4]
679:                   while ( (ii < number_of_samples) && (count_in_tempbuf > 0) )
0077C0  37004E     BRA .L63
00785E  9000AE     MOV [W14+4], W1
007860  90007E     MOV [W14+14], W0
007862  508F80     SUB W1, W0, [W15]
007864  3D0003     BRA GE, .L64
007866  90001E     MOV [W14+2], W0
007868  E00000     CP0 W0
00786A  3AFFAB     BRA NZ, .L65
680:                   {
681:                       offset = tail * 4 + 15;
0077C2  90003E     MOV [W14+6], W0
0077C4  DD0042     SL W0, #2, W0
0077C6  40006F     ADD W0, #0xF, W0
0077C8  980760     MOV W0, [W14+12]
682:                       data = FRAMReadByte(memLocTemperatureBufferStart + offset, 0);
0077CA  90006E     MOV [W14+12], W0
0077CC  B90161     MUL.SU W0, #1, W2
0077CE  239500     MOV #0x3950, W0
0077D0  200011     MOV #0x1, W1
0077D2  400002     ADD W0, W2, W0
0077D4  488083     ADDC W1, W3, W1
0077D6  EB4100     CLR.B W2
0077D8  07285A     RCALL FRAMReadByte
0077DA  984F00     MOV.B W0, [W14+8]
683:                       data_buf[buf_ret_count] = data;
0077DC  78001E     MOV [W14], W0
0077DE  90088E     MOV [W14+16], W1
0077E0  408000     ADD W1, W0, W0
0077E2  90490E     MOV.B [W14+8], W2
0077E4  784802     MOV.B W2, [W0]
684:                       buf_ret_count ++;
0077E6  E80F1E     INC [W14], [W14]
685:                       data = FRAMReadByte(memLocTemperatureBufferStart + offset+1, 0);
0077E8  90006E     MOV [W14+12], W0
0077EA  B90161     MUL.SU W0, #1, W2
0077EC  239510     MOV #0x3951, W0
0077EE  200011     MOV #0x1, W1
0077F0  400002     ADD W0, W2, W0
0077F2  488083     ADDC W1, W3, W1
0077F4  EB4100     CLR.B W2
0077F6  07284B     RCALL FRAMReadByte
0077F8  984F00     MOV.B W0, [W14+8]
686:                       data_buf[buf_ret_count] = data;
0077FA  78001E     MOV [W14], W0
0077FC  90088E     MOV [W14+16], W1
0077FE  408000     ADD W1, W0, W0
007800  90488E     MOV.B [W14+8], W1
007802  784801     MOV.B W1, [W0]
687:                       buf_ret_count ++;
007804  E80F1E     INC [W14], [W14]
688:                       data = FRAMReadByte(memLocTemperatureBufferStart + offset+2, 0);
007806  90006E     MOV [W14+12], W0
007808  B90161     MUL.SU W0, #1, W2
00780A  239520     MOV #0x3952, W0
00780C  200011     MOV #0x1, W1
00780E  400002     ADD W0, W2, W0
007810  488083     ADDC W1, W3, W1
007812  EB4100     CLR.B W2
007814  07283C     RCALL FRAMReadByte
007816  984F00     MOV.B W0, [W14+8]
689:                       data_buf[buf_ret_count] = data;
007818  78001E     MOV [W14], W0
00781A  90088E     MOV [W14+16], W1
00781C  408000     ADD W1, W0, W0
00781E  90490E     MOV.B [W14+8], W2
007820  784802     MOV.B W2, [W0]
690:                       buf_ret_count ++;
007822  E80F1E     INC [W14], [W14]
691:                       data = FRAMReadByte(memLocTemperatureBufferStart + offset+3, 0);
007824  90006E     MOV [W14+12], W0
007826  B90161     MUL.SU W0, #1, W2
007828  239530     MOV #0x3953, W0
00782A  200011     MOV #0x1, W1
00782C  400002     ADD W0, W2, W0
00782E  488083     ADDC W1, W3, W1
007830  EB4100     CLR.B W2
007832  07282D     RCALL FRAMReadByte
007834  984F00     MOV.B W0, [W14+8]
692:                       data_buf[buf_ret_count] = data;
007836  78001E     MOV [W14], W0
007838  90088E     MOV [W14+16], W1
00783A  408000     ADD W1, W0, W0
00783C  90488E     MOV.B [W14+8], W1
00783E  784801     MOV.B W1, [W0]
693:                       buf_ret_count ++;
007840  E80F1E     INC [W14], [W14]
694:                       tail = (tail + 1) % capacity;
007842  90003E     MOV [W14+6], W0
007844  E80080     INC W0, W1
007846  90005E     MOV [W14+10], W0
007848  780100     MOV W0, W2
00784A  090011     REPEAT #0x11
00784C  D88082     DIV.UW W1, W2
00784E  FD0080     EXCH W0, W1
007850  980730     MOV W0, [W14+6]
695:                       count_in_tempbuf --;
007852  90001E     MOV [W14+2], W0
007854  E90000     DEC W0, W0
007856  980710     MOV W0, [W14+2]
696:                       ii++;
007858  90002E     MOV [W14+4], W0
00785A  E80000     INC W0, W0
00785C  980720     MOV W0, [W14+4]
697:                   }
698:                   return buf_ret_count;
00786C  78001E     MOV [W14], W0
699:               }
00786E  FA8000     ULNK
007870  060000     RETURN
700:               
701:               /**
702:                * 
703:                * @param num_of_items
704:                * Delete from FRAM num_of_items from Temperature Buffer
705:                *      since they were successfully transmitted
706:                */
707:               void DeleteEntriesTemperatureBuffer(int num_of_items)
708:               {
007872  FA0008     LNK #0x8
007874  980730     MOV W0, [W14+6]
709:                   uint16_t count_in_tempbuf;
710:                   uint16_t tail;
711:                   uint16_t capacity;
712:                   count_in_tempbuf = FRAMReadWord(memLocTemperatureBufferStart + 6, 0);
007876  EB4100     CLR.B W2
007878  239560     MOV #0x3956, W0
00787A  200011     MOV #0x1, W1
00787C  07282D     RCALL FRAMReadWord
00787E  780F00     MOV W0, [W14]
713:                   if ( count_in_tempbuf == 0)
007880  78001E     MOV [W14], W0
007882  E00000     CP0 W0
007884  32004A     BRA Z, .L71
714:                   {
715:                       return;
00791A  000000     NOP
716:                   }
717:                   tail = FRAMReadWord(memLocTemperatureBufferStart + 2, 0);
007886  EB4100     CLR.B W2
007888  239520     MOV #0x3952, W0
00788A  200011     MOV #0x1, W1
00788C  072825     RCALL FRAMReadWord
00788E  980710     MOV W0, [W14+2]
718:                   capacity = FRAMReadWord(memLocTemperatureBufferStart + 4, 0);
007890  EB4100     CLR.B W2
007892  239540     MOV #0x3954, W0
007894  200011     MOV #0x1, W1
007896  072820     RCALL FRAMReadWord
007898  980720     MOV W0, [W14+4]
719:                   if (count_in_tempbuf < num_of_items)
00789A  90003E     MOV [W14+6], W0
00789C  500F9E     SUB W0, [W14], [W15]
00789E  36000B     BRA LEU, .L69
720:                   {
721:                       tail = (tail + count_in_tempbuf) % capacity;
0078A0  90001E     MOV [W14+2], W0
0078A2  40009E     ADD W0, [W14], W1
0078A4  90002E     MOV [W14+4], W0
0078A6  780100     MOV W0, W2
0078A8  090011     REPEAT #0x11
0078AA  D88082     DIV.UW W1, W2
0078AC  FD0080     EXCH W0, W1
0078AE  980710     MOV W0, [W14+2]
722:                       count_in_tempbuf = 0;
0078B0  EB0000     CLR W0
0078B2  780F00     MOV W0, [W14]
0078B4  37000B     BRA .L70
723:                   }
724:                   else 
725:                   {
726:                       count_in_tempbuf -= num_of_items;
0078B6  90003E     MOV [W14+6], W0
0078B8  100F1E     SUBR W0, [W14], [W14]
727:                       tail = (tail + num_of_items) % capacity;
0078BA  9000BE     MOV [W14+6], W1
0078BC  90001E     MOV [W14+2], W0
0078BE  408080     ADD W1, W0, W1
0078C0  90002E     MOV [W14+4], W0
0078C2  780100     MOV W0, W2
0078C4  090011     REPEAT #0x11
0078C6  D88082     DIV.UW W1, W2
0078C8  FD0080     EXCH W0, W1
0078CA  980710     MOV W0, [W14+2]
728:                   }
729:                   // write new tail to fram
730:                   FRAMWriteWord(count_in_tempbuf, memLocTemperatureBufferStart + 6,    0);
0078CC  EB4080     CLR.B W1
0078CE  239562     MOV #0x3956, W2
0078D0  200013     MOV #0x1, W3
0078D2  78001E     MOV [W14], W0
0078D4  0726AE     RCALL FRAMWriteWord
731:                   FRAMWriteWord(tail, memLocTemperatureBufferStart + 2, 0);
0078D6  EB4080     CLR.B W1
0078D8  239522     MOV #0x3952, W2
0078DA  200013     MOV #0x1, W3
0078DC  90001E     MOV [W14+2], W0
0078DE  0726A9     RCALL FRAMWriteWord
732:                   if (count_in_tempbuf == 0)
0078E0  78001E     MOV [W14], W0
0078E2  E00000     CP0 W0
0078E4  3A001B     BRA NZ, .L66
733:                   {
734:                       // clear the timestamp in temperature buffer as all elements are empty
735:                       FRAMWriteByte(0, memLocTemperatureBufferStart + 10, 0);
0078E6  EB4080     CLR.B W1
0078E8  2395A2     MOV #0x395A, W2
0078EA  200013     MOV #0x1, W3
0078EC  EB4000     CLR.B W0
0078EE  072661     RCALL FRAMWriteByte
736:                       FRAMWriteByte(0, memLocTemperatureBufferStart + 11, 0);
0078F0  EB4080     CLR.B W1
0078F2  2395B2     MOV #0x395B, W2
0078F4  200013     MOV #0x1, W3
0078F6  EB4000     CLR.B W0
0078F8  07265C     RCALL FRAMWriteByte
737:                       FRAMWriteByte(0, memLocTemperatureBufferStart + 12, 0);
0078FA  EB4080     CLR.B W1
0078FC  2395C2     MOV #0x395C, W2
0078FE  200013     MOV #0x1, W3
007900  EB4000     CLR.B W0
007902  072657     RCALL FRAMWriteByte
738:                       FRAMWriteByte(0, memLocTemperatureBufferStart + 13, 0);
007904  EB4080     CLR.B W1
007906  2395D2     MOV #0x395D, W2
007908  200013     MOV #0x1, W3
00790A  EB4000     CLR.B W0
00790C  072652     RCALL FRAMWriteByte
739:                       FRAMWriteByte(0, memLocTemperatureBufferStart + 14, 0);
00790E  EB4080     CLR.B W1
007910  2395E2     MOV #0x395E, W2
007912  200013     MOV #0x1, W3
007914  EB4000     CLR.B W0
007916  07264D     RCALL FRAMWriteByte
007918  370001     BRA .L66
740:                   }
741:                   
742:               }
00791C  FA8000     ULNK
00791E  060000     RETURN
743:               
744:               /*
745:                * Buffer for runtime data stored in FRAM
746:                * initialize:
747:                *     this function initializes the buffer for runtime data storage
748:                *     - set head to 0, 
749:                *     - set tail to 0, 
750:                *     - set capacity to RuntimeBufferMaxCapacity (max based on allocated storage)
751:                *     - set count to 0,
752:                *     - set overtide count to 0,
753:                *     - set all rtc time base bytes to 0
754:                *    This function is called only when buffers are not Initialized, and  WriteBuffersInitialized() is called before calling this function
755:                */
756:               void RuntimeBufferInit()
757:               {
007920  FA0002     LNK #0x2
758:                   uint8_t data;
759:                   data = ReadBuffersInitialized();
007922  07FD8A     RCALL ReadBuffersInitialized
007924  784F00     MOV.B W0, [W14]
760:                   if (data == (uint8_t)BufferInitializedWriteValue ) 
007926  B3C6D0     MOV.B #0x6D, W0
007928  78409E     MOV.B [W14], W1
00792A  50CF80     SUB.B W1, W0, [W15]
00792C  3A0032     BRA NZ, .L72
761:                   {
762:                       // initialize the setpoint buffer
763:                       // set head to zero
764:                       FRAMWriteWord(0x0000, memLocRuntimeBufferStart, 0);
00792E  EB4080     CLR.B W1
007930  24EE12     MOV #0x4EE1, W2
007932  200003     MOV #0x0, W3
007934  EB0000     CLR W0
007936  07267D     RCALL FRAMWriteWord
765:                       // set tail to zero
766:                       FRAMWriteWord(0x0000, memLocRuntimeBufferStart+2, 0);
007938  EB4080     CLR.B W1
00793A  24EE32     MOV #0x4EE3, W2
00793C  200003     MOV #0x0, W3
00793E  EB0000     CLR W0
007940  072678     RCALL FRAMWriteWord
767:                       // set capacity to TemperatureBufferCapacity
768:                       FRAMWriteWord((uint16_t)RuntimeBufferMaxCapacity, memLocRuntimeBufferStart+4, 0);
007942  EB4080     CLR.B W1
007944  24EE52     MOV #0x4EE5, W2
007946  200003     MOV #0x0, W3
007948  23A980     MOV #0x3A98, W0
00794A  072673     RCALL FRAMWriteWord
769:                       // set count to zero
770:                       FRAMWriteWord(0x0000, memLocRuntimeBufferStart+6, 0);
00794C  EB4080     CLR.B W1
00794E  24EE72     MOV #0x4EE7, W2
007950  200003     MOV #0x0, W3
007952  EB0000     CLR W0
007954  07266E     RCALL FRAMWriteWord
771:                       // set override count to zero
772:                       FRAMWriteWord(0x0000, memLocRuntimeBufferStart+8, 0);
007956  EB4080     CLR.B W1
007958  24EE92     MOV #0x4EE9, W2
00795A  200003     MOV #0x0, W3
00795C  EB0000     CLR W0
00795E  072669     RCALL FRAMWriteWord
773:                       // set all rtc time base bytes to zero
774:                       FRAMWriteByte(0x00, memLocRuntimeBufferStart+10, 0);
007960  EB4080     CLR.B W1
007962  24EEB2     MOV #0x4EEB, W2
007964  200003     MOV #0x0, W3
007966  EB4000     CLR.B W0
007968  072624     RCALL FRAMWriteByte
775:                       FRAMWriteByte(0x00, memLocRuntimeBufferStart+11, 0);
00796A  EB4080     CLR.B W1
00796C  24EEC2     MOV #0x4EEC, W2
00796E  200003     MOV #0x0, W3
007970  EB4000     CLR.B W0
007972  07261F     RCALL FRAMWriteByte
776:                       FRAMWriteByte(0x00, memLocRuntimeBufferStart+12, 0);
007974  EB4080     CLR.B W1
007976  24EED2     MOV #0x4EED, W2
007978  200003     MOV #0x0, W3
00797A  EB4000     CLR.B W0
00797C  07261A     RCALL FRAMWriteByte
777:                       FRAMWriteByte(0x00, memLocRuntimeBufferStart+13, 0);
00797E  EB4080     CLR.B W1
007980  24EEE2     MOV #0x4EEE, W2
007982  200003     MOV #0x0, W3
007984  EB4000     CLR.B W0
007986  072615     RCALL FRAMWriteByte
778:                       FRAMWriteByte(0x00, memLocRuntimeBufferStart+14, 0);
007988  EB4080     CLR.B W1
00798A  24EEF2     MOV #0x4EEF, W2
00798C  200003     MOV #0x0, W3
00798E  EB4000     CLR.B W0
007990  072610     RCALL FRAMWriteByte
779:                   }
780:               }
007992  FA8000     ULNK
007994  060000     RETURN
781:               
782:               
783:               /*
784:                * u8CurrentTemperature stores the current temperature
785:                * u8CurrentThermostatAction stores the current action of thermostat : ACTION_HEATING, ACTION_COOLING, ACTION_NONE
786:                * write the value in u8CurrentTemperature and u8Thermostat Action into cool info and heat info bytes 
787:                * This function writes the temperature stored in u8CurrentTemperature and u8Thermostat Action into 2 bytes:
788:                * one byte for Cool info and one byte for heat info
789:                */
790:               void WriteRuntimeBuffer()
791:               {
007996  FA0040     LNK #0x40
007998  781F88     MOV W8, [W15++]
792:                   uint8_t data;
793:                   uint32_t u32data;
794:                   uint16_t count_in_tempbuf;
795:                   double diff_time;
796:                   time_t base_t, curr_t;
797:                   int offset;
798:                   uint16_t tmpu16;
799:                   struct tm base_time;
800:                   struct tm curr_time;
801:                   uint16_t head;
802:                   uint16_t capacity;
803:                   data = ReadBuffersInitialized();
00799A  07FD4E     RCALL ReadBuffersInitialized
00799C  784F00     MOV.B W0, [W14]
804:                   if (data != BufferInitializedWriteValue)
00799E  B3C6D0     MOV.B #0x6D, W0
0079A0  78409E     MOV.B [W14], W1
0079A2  50CF80     SUB.B W1, W0, [W15]
0079A4  3A0107     BRA NZ, .L87
805:                   {
806:                       return;
007BB4  000000     NOP
007BB6  370003     BRA .L74
807:                   }
808:                   count_in_tempbuf = FRAMReadWord(memLocRuntimeBufferStart + 6, 0);
0079A6  EB4100     CLR.B W2
0079A8  24EE70     MOV #0x4EE7, W0
0079AA  200001     MOV #0x0, W1
0079AC  072795     RCALL FRAMReadWord
0079AE  980750     MOV W0, [W14+10]
809:                   // for now if we reach max capacity, we stop writing
810:                   head = FRAMReadWord(memLocRuntimeBufferStart, 0 );
0079B0  EB4100     CLR.B W2
0079B2  24EE10     MOV #0x4EE1, W0
0079B4  200001     MOV #0x0, W1
0079B6  072790     RCALL FRAMReadWord
0079B8  980760     MOV W0, [W14+12]
811:                   capacity = FRAMReadWord(memLocRuntimeBufferStart + 4, 0);
0079BA  EB4100     CLR.B W2
0079BC  24EE50     MOV #0x4EE5, W0
0079BE  200001     MOV #0x0, W1
0079C0  07278B     RCALL FRAMReadWord
0079C2  980770     MOV W0, [W14+14]
812:                   // reached max capacity return
813:                   if (count_in_tempbuf >= capacity) {
0079C4  9000DE     MOV [W14+10], W1
0079C6  90007E     MOV [W14+14], W0
0079C8  508F80     SUB W1, W0, [W15]
0079CA  3100F6     BRA C, .L88
814:                       return;
007BB8  000000     NOP
007BBA  370001     BRA .L74
815:                   }
816:                   if (count_in_tempbuf == 0)
0079CC  90005E     MOV [W14+10], W0
0079CE  E00000     CP0 W0
0079D0  3A0029     BRA NZ, .L78
817:                   {
818:                       // write the current timestamp to rtc time base
819:                       RTCC_TimeGet(&base_time);
0079D2  47007C     ADD W14, #0x1C, W0
0079D4  0728D9     RCALL RTCC_TimeGet
820:                       data = base_time.tm_year;
0079D6  90103E     MOV [W14+38], W0
0079D8  784F00     MOV.B W0, [W14]
821:                       FRAMWriteByte(data, memLocRuntimeBufferStart + 10, 0);
0079DA  EB4080     CLR.B W1
0079DC  24EEB2     MOV #0x4EEB, W2
0079DE  200003     MOV #0x0, W3
0079E0  78401E     MOV.B [W14], W0
0079E2  0725E7     RCALL FRAMWriteByte
822:                       data = base_time.tm_mon;
0079E4  90102E     MOV [W14+36], W0
0079E6  784F00     MOV.B W0, [W14]
823:                       FRAMWriteByte(data, memLocRuntimeBufferStart + 11, 0);
0079E8  EB4080     CLR.B W1
0079EA  24EEC2     MOV #0x4EEC, W2
0079EC  200003     MOV #0x0, W3
0079EE  78401E     MOV.B [W14], W0
0079F0  0725E0     RCALL FRAMWriteByte
824:                       data = base_time.tm_mday;
0079F2  90101E     MOV [W14+34], W0
0079F4  784F00     MOV.B W0, [W14]
825:                       FRAMWriteByte(data, memLocRuntimeBufferStart + 12, 0);
0079F6  EB4080     CLR.B W1
0079F8  24EED2     MOV #0x4EED, W2
0079FA  200003     MOV #0x0, W3
0079FC  78401E     MOV.B [W14], W0
0079FE  0725D9     RCALL FRAMWriteByte
826:                       data = base_time.tm_hour;
007A00  90100E     MOV [W14+32], W0
007A02  784F00     MOV.B W0, [W14]
827:                       FRAMWriteByte(data, memLocRuntimeBufferStart + 13, 0);
007A04  EB4080     CLR.B W1
007A06  24EEE2     MOV #0x4EEE, W2
007A08  200003     MOV #0x0, W3
007A0A  78401E     MOV.B [W14], W0
007A0C  0725D2     RCALL FRAMWriteByte
828:                       data = base_time.tm_min;
007A0E  90087E     MOV [W14+30], W0
007A10  784F00     MOV.B W0, [W14]
829:                       FRAMWriteByte(data, memLocRuntimeBufferStart + 14, 0);
007A12  EB4080     CLR.B W1
007A14  24EEF2     MOV #0x4EEF, W2
007A16  200003     MOV #0x0, W3
007A18  78401E     MOV.B [W14], W0
007A1A  0725CB     RCALL FRAMWriteByte
830:                       u32data = 0x00;
007A1C  B80060     MUL.UU W0, #0, W0
007A1E  980710     MOV W0, [W14+2]
007A20  980721     MOV W1, [W14+4]
007A22  370064     BRA .L79
831:                       
832:                   }
833:                   else 
834:                   {
835:                       RTCC_TimeGet(&curr_time);
007A24  2002E0     MOV #0x2E, W0
007A26  40000E     ADD W0, W14, W0
007A28  0728AF     RCALL RTCC_TimeGet
836:                       // read the rtc time base from buffer
837:                       data = FRAMReadByte(memLocRuntimeBufferStart + 10, 0);
007A2A  EB4100     CLR.B W2
007A2C  24EEB0     MOV #0x4EEB, W0
007A2E  200001     MOV #0x0, W1
007A30  07272E     RCALL FRAMReadByte
007A32  784F00     MOV.B W0, [W14]
838:                       base_time.tm_year = (int)data;
007A34  FB801E     ZE [W14], W0
007A36  981730     MOV W0, [W14+38]
839:                       data = FRAMReadByte(memLocRuntimeBufferStart + 11, 0);
007A38  EB4100     CLR.B W2
007A3A  24EEC0     MOV #0x4EEC, W0
007A3C  200001     MOV #0x0, W1
007A3E  072727     RCALL FRAMReadByte
007A40  784F00     MOV.B W0, [W14]
840:                       base_time.tm_mon = (int)data;
007A42  FB801E     ZE [W14], W0
007A44  981720     MOV W0, [W14+36]
841:                       data = FRAMReadByte(memLocRuntimeBufferStart + 12, 0);
007A46  EB4100     CLR.B W2
007A48  24EED0     MOV #0x4EED, W0
007A4A  200001     MOV #0x0, W1
007A4C  072720     RCALL FRAMReadByte
007A4E  784F00     MOV.B W0, [W14]
842:                       base_time.tm_mday = (int)data;
007A50  FB801E     ZE [W14], W0
007A52  981710     MOV W0, [W14+34]
843:                       data = FRAMReadByte(memLocRuntimeBufferStart + 13, 0);
007A54  EB4100     CLR.B W2
007A56  24EEE0     MOV #0x4EEE, W0
007A58  200001     MOV #0x0, W1
007A5A  072719     RCALL FRAMReadByte
007A5C  784F00     MOV.B W0, [W14]
844:                       base_time.tm_hour = (int)data;
007A5E  FB801E     ZE [W14], W0
007A60  981700     MOV W0, [W14+32]
845:                       data = FRAMReadByte(memLocRuntimeBufferStart + 11, 0);
007A62  EB4100     CLR.B W2
007A64  24EEC0     MOV #0x4EEC, W0
007A66  200001     MOV #0x0, W1
007A68  072712     RCALL FRAMReadByte
007A6A  784F00     MOV.B W0, [W14]
846:                       base_time.tm_min = (int)data;
007A6C  FB801E     ZE [W14], W0
007A6E  980F70     MOV W0, [W14+30]
847:                       base_time.tm_sec = 0;
007A70  EB0000     CLR W0
007A72  980F60     MOV W0, [W14+28]
848:                       base_t = mktime(&base_time);
007A74  47007C     ADD W14, #0x1C, W0
007A76  07C94A     RCALL _mktime
007A78  980F00     MOV W0, [W14+16]
007A7A  980F11     MOV W1, [W14+18]
849:                       curr_t = mktime(&curr_time);
007A7C  2002E0     MOV #0x2E, W0
007A7E  40000E     ADD W0, W14, W0
007A80  07C945     RCALL _mktime
007A82  980F20     MOV W0, [W14+20]
007A84  980F31     MOV W1, [W14+22]
850:                       diff_time = difftime(curr_t, base_t);
007A86  90090E     MOV [W14+16], W2
007A88  90099E     MOV [W14+18], W3
007A8A  90082E     MOV [W14+20], W0
007A8C  9008BE     MOV [W14+22], W1
007A8E  07C91F     RCALL _difftime
007A90  980730     MOV W0, [W14+6]
007A92  980741     MOV W1, [W14+8]
851:                       if (diff_time < 0)
007A94  B3C018     MOV.B #0x1, W8
007A96  B81160     MUL.UU W2, #0, W2
007A98  90003E     MOV [W14+6], W0
007A9A  9000CE     MOV [W14+8], W1
007A9C  07C54D     RCALL ___ltsf2, ___eqsf2, ___lesf2
007A9E  E00000     CP0 W0
007AA0  350001     BRA LT, .L80
007AA2  EB4400     CLR.B W8
007AA4  E00408     CP0.B W8
007AA6  320005     BRA Z, .L81
852:                       {
853:                           diff_time = -diff_time;
007AA8  90003E     MOV [W14+6], W0
007AAA  9000CE     MOV [W14+8], W1
007AAC  A2F001     BTG W1, #15
007AAE  980730     MOV W0, [W14+6]
007AB0  980741     MOV W1, [W14+8]
854:                       }
855:                       diff_time = diff_time / 60.0; // convert to minutes;
007AB2  200002     MOV #0x0, W2
007AB4  242703     MOV #0x4270, W3
007AB6  90003E     MOV [W14+6], W0
007AB8  9000CE     MOV [W14+8], W1
007ABA  07C4ED     RCALL ___divsf3
007ABC  980730     MOV W0, [W14+6]
007ABE  980741     MOV W1, [W14+8]
856:                       if (diff_time > (double)0xFFFF)
007AC0  B3C018     MOV.B #0x1, W8
007AC2  2FF002     MOV #0xFF00, W2
007AC4  2477F3     MOV #0x477F, W3
007AC6  90003E     MOV [W14+6], W0
007AC8  9000CE     MOV [W14+8], W1
007ACA  07C538     RCALL ___gesf2, ___gtsf2
007ACC  E00000     CP0 W0
007ACE  3C0001     BRA GT, .L82
007AD0  EB4400     CLR.B W8
007AD2  E00408     CP0.B W8
007AD4  320004     BRA Z, .L83
857:                       {
858:                           u32data = 0;
007AD6  B80060     MUL.UU W0, #0, W0
007AD8  980710     MOV W0, [W14+2]
007ADA  980721     MOV W1, [W14+4]
007ADC  370007     BRA .L79
859:                       }
860:                       else 
861:                       {
862:                           u32data =(int) diff_time;
007ADE  90003E     MOV [W14+6], W0
007AE0  9000CE     MOV [W14+8], W1
007AE2  07C52E     RCALL ___fixsfsi
007AE4  780000     MOV W0, W0
007AE6  DE80CF     ASR W0, #15, W1
007AE8  980710     MOV W0, [W14+2]
007AEA  980721     MOV W1, [W14+4]
863:                       }
864:                   }
865:                   if ( (u32data == 0) && ( count_in_tempbuf  > 0) )
007AEC  90001E     MOV [W14+2], W0
007AEE  9000AE     MOV [W14+4], W1
007AF0  500FE0     SUB W0, #0x0, [W15]
007AF2  588FE0     SUBB W1, #0x0, [W15]
007AF4  3A0003     BRA NZ, .L84
007AF6  90005E     MOV [W14+10], W0
007AF8  E00000     CP0 W0
007AFA  3A0060     BRA NZ, .L89
866:                   {
867:                       // cannot report data since not enough space to store time
868:                       return;
007BBC  000000     NOP
869:                   }
870:                   //offset = count_in_tempbuf * 4 + 15; // memLocTemperatureBufferStart;
871:                   offset = head * 4 + 15;
007AFC  90006E     MOV [W14+12], W0
007AFE  DD0042     SL W0, #2, W0
007B00  40006F     ADD W0, #0xF, W0
007B02  980F40     MOV W0, [W14+24]
872:                   tmpu16 = (head + 1) % capacity;
007B04  90006E     MOV [W14+12], W0
007B06  E80080     INC W0, W1
007B08  90007E     MOV [W14+14], W0
007B0A  780100     MOV W0, W2
007B0C  090011     REPEAT #0x11
007B0E  D88082     DIV.UW W1, W2
007B10  FD0080     EXCH W0, W1
007B12  980F50     MOV W0, [W14+26]
873:                   data = (uint8_t)(u32data & 0xFF); // Little endian format
007B14  90001E     MOV [W14+2], W0
007B16  784F00     MOV.B W0, [W14]
874:                   FRAMWriteByte(data, memLocRuntimeBufferStart + offset, 0 );
007B18  9008CE     MOV [W14+24], W1
007B1A  24EE10     MOV #0x4EE1, W0
007B1C  408000     ADD W1, W0, W0
007B1E  B90161     MUL.SU W0, #1, W2
007B20  EB4080     CLR.B W1
007B22  78401E     MOV.B [W14], W0
007B24  072546     RCALL FRAMWriteByte
875:                   data = (uint8_t)( (u32data & 0xFF00) >> 8); // Little endian format
007B26  90011E     MOV [W14+2], W2
007B28  9001AE     MOV [W14+4], W3
007B2A  2FF000     MOV #0xFF00, W0
007B2C  200001     MOV #0x0, W1
007B2E  780202     MOV W2, W4
007B30  780103     MOV W3, W2
007B32  780180     MOV W0, W3
007B34  780001     MOV W1, W0
007B36  620203     AND W4, W3, W4
007B38  610000     AND W2, W0, W0
007B3A  EB0080     CLR W1
007B3C  DD00C0     SL W0, #0, W1
007B3E  200000     MOV #0x0, W0
007B40  BE0100     MOV.D W0, W2
007B42  B82061     MUL.UU W4, #1, W0
007B44  710100     IOR W2, W0, W2
007B46  718181     IOR W3, W1, W3
007B48  DD1A48     SL W3, #8, W4
007B4A  DE1048     LSR W2, #8, W0
007B4C  720000     IOR W4, W0, W0
007B4E  DE18C8     LSR W3, #8, W1
007B50  784F00     MOV.B W0, [W14]
876:                   FRAMWriteByte(data, memLocRuntimeBufferStart + offset + 1, 0);
007B52  9008CE     MOV [W14+24], W1
007B54  24EE20     MOV #0x4EE2, W0
007B56  408000     ADD W1, W0, W0
007B58  B90161     MUL.SU W0, #1, W2
007B5A  EB4080     CLR.B W1
007B5C  78401E     MOV.B [W14], W0
007B5E  072529     RCALL FRAMWriteByte
877:                   data = u8CurrentTemperature;
007B60  208C01     MOV #0x8C0, W1
007B62  784091     MOV.B [W1], W1
007B64  784F01     MOV.B W1, [W14]
878:                   if (u8ThermostatMode == ACTION_COOLING)
007B66  BFC8BE     MOV.B u8ThermostatMode, WREG
007B68  504FE2     SUB.B W0, #0x2, [W15]
007B6A  3A0001     BRA NZ, .L85
879:                   {
880:                       data = data | 0x80;
007B6C  A0741E     BSET.B [W14], #7
881:                   }
882:                   FRAMWriteByte(data, memLocRuntimeBufferStart + offset + 2, 0);
007B6E  9008CE     MOV [W14+24], W1
007B70  24EE30     MOV #0x4EE3, W0
007B72  408000     ADD W1, W0, W0
007B74  B90161     MUL.SU W0, #1, W2
007B76  EB4080     CLR.B W1
007B78  78401E     MOV.B [W14], W0
007B7A  07251B     RCALL FRAMWriteByte
883:                   data = u8CurrentTemperature;
007B7C  208C02     MOV #0x8C0, W2
007B7E  784112     MOV.B [W2], W2
007B80  784F02     MOV.B W2, [W14]
884:                   if (u8ThermostatMode == ACTION_HEATING)
007B82  BFC8BE     MOV.B u8ThermostatMode, WREG
007B84  504FE1     SUB.B W0, #0x1, [W15]
007B86  3A0001     BRA NZ, .L86
885:                   {
886:                       data = data | 0x80;
007B88  A0741E     BSET.B [W14], #7
887:                   }
888:                   FRAMWriteByte(data, memLocRuntimeBufferStart + offset + 3, 0);
007B8A  9008CE     MOV [W14+24], W1
007B8C  24EE40     MOV #0x4EE4, W0
007B8E  408000     ADD W1, W0, W0
007B90  B90161     MUL.SU W0, #1, W2
007B92  EB4080     CLR.B W1
007B94  78401E     MOV.B [W14], W0
007B96  07250D     RCALL FRAMWriteByte
889:                   // write number_of_items + 1 to fram
890:                   FRAMWriteWord(tmpu16, memLocRuntimeBufferStart, 0);
007B98  EB4080     CLR.B W1
007B9A  24EE12     MOV #0x4EE1, W2
007B9C  200003     MOV #0x0, W3
007B9E  90085E     MOV [W14+26], W0
007BA0  072548     RCALL FRAMWriteWord
891:                   tmpu16 = (uint16_t)(count_in_tempbuf + 1);
007BA2  90005E     MOV [W14+10], W0
007BA4  E80000     INC W0, W0
007BA6  980F50     MOV W0, [W14+26]
892:                   FRAMWriteWord(tmpu16, memLocRuntimeBufferStart + 6, 0);
007BA8  EB4080     CLR.B W1
007BAA  24EE72     MOV #0x4EE7, W2
007BAC  200003     MOV #0x0, W3
007BAE  90085E     MOV [W14+26], W0
007BB0  072540     RCALL FRAMWriteWord
007BB2  370005     BRA .L74
893:               }
007BBE  78044F     MOV [--W15], W8
007BC0  FA8000     ULNK
007BC2  060000     RETURN
894:               
895:               /**
896:                * ReadRuntimeBuffer
897:                *  arguments 
898:                *      number_of_samples to read
899:                *      data_buf(uint8_t *) for storing return elements;this must be allocated before the call
900:                *      data_buf_len: length of buffer created
901:                * 
902:                *  return value:
903:                *      int: 
904:                *          number of uint8_t bytes written to data_buf if successful
905:                *          -1 if data_buf_len is less than the required length for number of elements
906:                *          -2 if temperature buffer is empty
907:                *          -3 if buffer in FRAM has not been initialized
908:                * 
909:                *  format of data_buf returned
910:                *      first 5 bytes base timestamp as stored in FRAM
911:                *      4 BYTES per sample each
912:                *               
913:                */
914:               int ReadRuntimeBuffer(int number_of_samples, uint8_t * data_buf, int data_buf_len)
915:               {
007BC4  FA0014     LNK #0x14
007BC6  980770     MOV W0, [W14+14]
007BC8  980F01     MOV W1, [W14+16]
007BCA  980F12     MOV W2, [W14+18]
916:                   uint8_t data;
917:                   int buf_ret_count = 0;
007BCC  EB0000     CLR W0
007BCE  780F00     MOV W0, [W14]
918:                   uint16_t count_in_tempbuf;
919:                   int ii;
920:                   uint16_t tail;
921:                   uint16_t capacity;
922:                   int offset;
923:                   
924:                   data = ReadBuffersInitialized();
007BD0  07FC33     RCALL ReadBuffersInitialized
007BD2  984F00     MOV.B W0, [W14+8]
925:                   if (data != BufferInitializedWriteValue)
007BD4  90488E     MOV.B [W14+8], W1
007BD6  B3C6D0     MOV.B #0x6D, W0
007BD8  50CF80     SUB.B W1, W0, [W15]
007BDA  320002     BRA Z, .L91
926:                   {
927:                       return -3;
007BDC  2FFFD0     MOV #0xFFFD, W0
007BDE  3700A6     BRA .L92
928:                   }
929:                   if ( (number_of_samples * 4 + 5) > data_buf_len) 
007BE0  90007E     MOV [W14+14], W0
007BE2  DD0042     SL W0, #2, W0
007BE4  4000E5     ADD W0, #0x5, W1
007BE6  90081E     MOV [W14+18], W0
007BE8  508F80     SUB W1, W0, [W15]
007BEA  340002     BRA LE, .L93
930:                   {
931:                       // insufficient space to return data
932:                       return -1;
007BEC  EB8000     SETM W0
007BEE  37009E     BRA .L92
933:                   }
934:                   count_in_tempbuf = FRAMReadWord(memLocRuntimeBufferStart + 6, 0);
007BF0  EB4100     CLR.B W2
007BF2  24EE70     MOV #0x4EE7, W0
007BF4  200001     MOV #0x0, W1
007BF6  072670     RCALL FRAMReadWord
007BF8  980710     MOV W0, [W14+2]
935:                   if ( count_in_tempbuf == 0)
007BFA  90001E     MOV [W14+2], W0
007BFC  E00000     CP0 W0
007BFE  3A0002     BRA NZ, .L94
936:                   {
937:                       return -2;
007C00  2FFFE0     MOV #0xFFFE, W0
007C02  370094     BRA .L92
938:                   }
939:                   tail = FRAMReadWord(memLocRuntimeBufferStart + 2, 0);
007C04  EB4100     CLR.B W2
007C06  24EE30     MOV #0x4EE3, W0
007C08  200001     MOV #0x0, W1
007C0A  072666     RCALL FRAMReadWord
007C0C  980730     MOV W0, [W14+6]
940:                   capacity = FRAMReadWord(memLocRuntimeBufferStart + 4, 0);
007C0E  EB4100     CLR.B W2
007C10  24EE50     MOV #0x4EE5, W0
007C12  200001     MOV #0x0, W1
007C14  072661     RCALL FRAMReadWord
007C16  980750     MOV W0, [W14+10]
941:                   
942:                   buf_ret_count = 0;
007C18  EB0000     CLR W0
007C1A  780F00     MOV W0, [W14]
943:                   data = FRAMReadByte(memLocRuntimeBufferStart + 10, 0);
007C1C  EB4100     CLR.B W2
007C1E  24EEB0     MOV #0x4EEB, W0
007C20  200001     MOV #0x0, W1
007C22  072635     RCALL FRAMReadByte
007C24  984F00     MOV.B W0, [W14+8]
944:                   data_buf[buf_ret_count] = data;
007C26  78001E     MOV [W14], W0
007C28  90088E     MOV [W14+16], W1
007C2A  408000     ADD W1, W0, W0
007C2C  90488E     MOV.B [W14+8], W1
007C2E  784801     MOV.B W1, [W0]
945:                   buf_ret_count ++;
007C30  E80F1E     INC [W14], [W14]
946:                   data = FRAMReadByte(memLocRuntimeBufferStart + 11, 0);
007C32  EB4100     CLR.B W2
007C34  24EEC0     MOV #0x4EEC, W0
007C36  200001     MOV #0x0, W1
007C38  07262A     RCALL FRAMReadByte
007C3A  984F00     MOV.B W0, [W14+8]
947:                   data_buf[buf_ret_count] = data; 
007C3C  78001E     MOV [W14], W0
007C3E  90088E     MOV [W14+16], W1
007C40  408000     ADD W1, W0, W0
007C42  90490E     MOV.B [W14+8], W2
007C44  784802     MOV.B W2, [W0]
948:                   buf_ret_count ++;
007C46  E80F1E     INC [W14], [W14]
949:                   data = FRAMReadByte(memLocRuntimeBufferStart + 12, 0);
007C48  EB4100     CLR.B W2
007C4A  24EED0     MOV #0x4EED, W0
007C4C  200001     MOV #0x0, W1
007C4E  07261F     RCALL FRAMReadByte
007C50  984F00     MOV.B W0, [W14+8]
950:                   data_buf[buf_ret_count] = data;
007C52  78001E     MOV [W14], W0
007C54  90088E     MOV [W14+16], W1
007C56  408000     ADD W1, W0, W0
007C58  90488E     MOV.B [W14+8], W1
007C5A  784801     MOV.B W1, [W0]
951:                   buf_ret_count ++;
007C5C  E80F1E     INC [W14], [W14]
952:                   data = FRAMReadByte(memLocRuntimeBufferStart + 13, 0);
007C5E  EB4100     CLR.B W2
007C60  24EEE0     MOV #0x4EEE, W0
007C62  200001     MOV #0x0, W1
007C64  072614     RCALL FRAMReadByte
007C66  984F00     MOV.B W0, [W14+8]
953:                   data_buf[buf_ret_count] = data;
007C68  78001E     MOV [W14], W0
007C6A  90088E     MOV [W14+16], W1
007C6C  408000     ADD W1, W0, W0
007C6E  90490E     MOV.B [W14+8], W2
007C70  784802     MOV.B W2, [W0]
954:                   buf_ret_count ++;
007C72  E80F1E     INC [W14], [W14]
955:                   data = FRAMReadByte(memLocRuntimeBufferStart + 11, 0);
007C74  EB4100     CLR.B W2
007C76  24EEC0     MOV #0x4EEC, W0
007C78  200001     MOV #0x0, W1
007C7A  072609     RCALL FRAMReadByte
007C7C  984F00     MOV.B W0, [W14+8]
956:                   data_buf[buf_ret_count] = data;
007C7E  78001E     MOV [W14], W0
007C80  90088E     MOV [W14+16], W1
007C82  408000     ADD W1, W0, W0
007C84  90488E     MOV.B [W14+8], W1
007C86  784801     MOV.B W1, [W0]
957:                   buf_ret_count ++;
007C88  E80F1E     INC [W14], [W14]
958:                   ii = 0;
007C8A  EB0000     CLR W0
007C8C  980720     MOV W0, [W14+4]
959:                   while ( (ii < number_of_samples) && (count_in_tempbuf > 0) )
007C8E  370046     BRA .L95
007D1C  9000AE     MOV [W14+4], W1
007D1E  90007E     MOV [W14+14], W0
007D20  508F80     SUB W1, W0, [W15]
007D22  3D0003     BRA GE, .L96
007D24  90001E     MOV [W14+2], W0
007D26  E00000     CP0 W0
007D28  3AFFB3     BRA NZ, .L97
960:                   {
961:                       offset = tail * 4 + 15;
007C90  90003E     MOV [W14+6], W0
007C92  DD0042     SL W0, #2, W0
007C94  40006F     ADD W0, #0xF, W0
007C96  980760     MOV W0, [W14+12]
962:                       data = FRAMReadByte(memLocRuntimeBufferStart + offset, 0);
007C98  9000EE     MOV [W14+12], W1
007C9A  24EE10     MOV #0x4EE1, W0
007C9C  408000     ADD W1, W0, W0
007C9E  DE80CF     ASR W0, #15, W1
007CA0  EB4100     CLR.B W2
007CA2  0725F5     RCALL FRAMReadByte
007CA4  984F00     MOV.B W0, [W14+8]
963:                       data_buf[buf_ret_count] = data;
007CA6  78001E     MOV [W14], W0
007CA8  90088E     MOV [W14+16], W1
007CAA  408000     ADD W1, W0, W0
007CAC  90490E     MOV.B [W14+8], W2
007CAE  784802     MOV.B W2, [W0]
964:                       buf_ret_count ++;
007CB0  E80F1E     INC [W14], [W14]
965:                       data = FRAMReadByte(memLocRuntimeBufferStart + offset+1, 0);
007CB2  9000EE     MOV [W14+12], W1
007CB4  24EE20     MOV #0x4EE2, W0
007CB6  408000     ADD W1, W0, W0
007CB8  DE80CF     ASR W0, #15, W1
007CBA  EB4100     CLR.B W2
007CBC  0725E8     RCALL FRAMReadByte
007CBE  984F00     MOV.B W0, [W14+8]
966:                       data_buf[buf_ret_count] = data;
007CC0  78001E     MOV [W14], W0
007CC2  90088E     MOV [W14+16], W1
007CC4  408000     ADD W1, W0, W0
007CC6  90488E     MOV.B [W14+8], W1
007CC8  784801     MOV.B W1, [W0]
967:                       buf_ret_count ++;
007CCA  E80F1E     INC [W14], [W14]
968:                       data = FRAMReadByte(memLocRuntimeBufferStart + offset+2, 0);
007CCC  9000EE     MOV [W14+12], W1
007CCE  24EE30     MOV #0x4EE3, W0
007CD0  408000     ADD W1, W0, W0
007CD2  DE80CF     ASR W0, #15, W1
007CD4  EB4100     CLR.B W2
007CD6  0725DB     RCALL FRAMReadByte
007CD8  984F00     MOV.B W0, [W14+8]
969:                       data_buf[buf_ret_count] = data;
007CDA  78001E     MOV [W14], W0
007CDC  90088E     MOV [W14+16], W1
007CDE  408000     ADD W1, W0, W0
007CE0  90490E     MOV.B [W14+8], W2
007CE2  784802     MOV.B W2, [W0]
970:                       buf_ret_count ++;
007CE4  E80F1E     INC [W14], [W14]
971:                       data = FRAMReadByte(memLocRuntimeBufferStart + offset+3, 0);
007CE6  9000EE     MOV [W14+12], W1
007CE8  24EE40     MOV #0x4EE4, W0
007CEA  408000     ADD W1, W0, W0
007CEC  DE80CF     ASR W0, #15, W1
007CEE  EB4100     CLR.B W2
007CF0  0725CE     RCALL FRAMReadByte
007CF2  984F00     MOV.B W0, [W14+8]
972:                       data_buf[buf_ret_count] = data;
007CF4  78001E     MOV [W14], W0
007CF6  90088E     MOV [W14+16], W1
007CF8  408000     ADD W1, W0, W0
007CFA  90488E     MOV.B [W14+8], W1
007CFC  784801     MOV.B W1, [W0]
973:                       buf_ret_count ++;
007CFE  E80F1E     INC [W14], [W14]
974:                       tail = (tail + 1) % capacity;
007D00  90003E     MOV [W14+6], W0
007D02  E80080     INC W0, W1
007D04  90005E     MOV [W14+10], W0
007D06  780100     MOV W0, W2
007D08  090011     REPEAT #0x11
007D0A  D88082     DIV.UW W1, W2
007D0C  FD0080     EXCH W0, W1
007D0E  980730     MOV W0, [W14+6]
975:                       count_in_tempbuf --;
007D10  90001E     MOV [W14+2], W0
007D12  E90000     DEC W0, W0
007D14  980710     MOV W0, [W14+2]
976:                       ii++;
007D16  90002E     MOV [W14+4], W0
007D18  E80000     INC W0, W0
007D1A  980720     MOV W0, [W14+4]
977:                   }
978:                   return buf_ret_count;
007D2A  78001E     MOV [W14], W0
979:               }
007D2C  FA8000     ULNK
007D2E  060000     RETURN
980:               
981:               
982:               /**
983:                * 
984:                * @param num_of_items
985:                * Delete from FRAM num_of_items from Runtime Buffer
986:                *      since they were successfully transmitted
987:                */
988:               void DeleteEntriesRuntimeBuffer(int num_of_items)
989:               {
007D30  FA0008     LNK #0x8
007D32  980730     MOV W0, [W14+6]
990:                   uint16_t count_in_tempbuf;
991:                   uint16_t tail;
992:                   uint16_t capacity;
993:                   count_in_tempbuf = FRAMReadWord(memLocRuntimeBufferStart + 6, 0);
007D34  EB4100     CLR.B W2
007D36  24EE70     MOV #0x4EE7, W0
007D38  200001     MOV #0x0, W1
007D3A  0725CE     RCALL FRAMReadWord
007D3C  780F00     MOV W0, [W14]
994:                   if ( count_in_tempbuf == 0)
007D3E  78001E     MOV [W14], W0
007D40  E00000     CP0 W0
007D42  32004A     BRA Z, .L103
995:                   {
996:                       return;
007DD8  000000     NOP
997:                   }
998:                   tail = FRAMReadWord(memLocRuntimeBufferStart + 2, 0);
007D44  EB4100     CLR.B W2
007D46  24EE30     MOV #0x4EE3, W0
007D48  200001     MOV #0x0, W1
007D4A  0725C6     RCALL FRAMReadWord
007D4C  980710     MOV W0, [W14+2]
999:                   capacity = FRAMReadWord(memLocRuntimeBufferStart + 4, 0);
007D4E  EB4100     CLR.B W2
007D50  24EE50     MOV #0x4EE5, W0
007D52  200001     MOV #0x0, W1
007D54  0725C1     RCALL FRAMReadWord
007D56  980720     MOV W0, [W14+4]
1000:                  if (count_in_tempbuf < num_of_items)
007D58  90003E     MOV [W14+6], W0
007D5A  500F9E     SUB W0, [W14], [W15]
007D5C  36000B     BRA LEU, .L101
1001:                  {
1002:                      tail = (tail + count_in_tempbuf) % capacity;
007D5E  90001E     MOV [W14+2], W0
007D60  40009E     ADD W0, [W14], W1
007D62  90002E     MOV [W14+4], W0
007D64  780100     MOV W0, W2
007D66  090011     REPEAT #0x11
007D68  D88082     DIV.UW W1, W2
007D6A  FD0080     EXCH W0, W1
007D6C  980710     MOV W0, [W14+2]
1003:                      count_in_tempbuf = 0;
007D6E  EB0000     CLR W0
007D70  780F00     MOV W0, [W14]
007D72  37000B     BRA .L102
1004:                  }
1005:                  else 
1006:                  {
1007:                      count_in_tempbuf -= num_of_items;
007D74  90003E     MOV [W14+6], W0
007D76  100F1E     SUBR W0, [W14], [W14]
1008:                      tail = (tail + num_of_items) % capacity;
007D78  9000BE     MOV [W14+6], W1
007D7A  90001E     MOV [W14+2], W0
007D7C  408080     ADD W1, W0, W1
007D7E  90002E     MOV [W14+4], W0
007D80  780100     MOV W0, W2
007D82  090011     REPEAT #0x11
007D84  D88082     DIV.UW W1, W2
007D86  FD0080     EXCH W0, W1
007D88  980710     MOV W0, [W14+2]
1009:                  }
1010:                  // write new tail to fram
1011:                  FRAMWriteWord(count_in_tempbuf, memLocRuntimeBufferStart + 6,    0);
007D8A  EB4080     CLR.B W1
007D8C  24EE72     MOV #0x4EE7, W2
007D8E  200003     MOV #0x0, W3
007D90  78001E     MOV [W14], W0
007D92  07244F     RCALL FRAMWriteWord
1012:                  FRAMWriteWord(tail, memLocRuntimeBufferStart + 2, 0);
007D94  EB4080     CLR.B W1
007D96  24EE32     MOV #0x4EE3, W2
007D98  200003     MOV #0x0, W3
007D9A  90001E     MOV [W14+2], W0
007D9C  07244A     RCALL FRAMWriteWord
1013:                  if (count_in_tempbuf == 0)
007D9E  78001E     MOV [W14], W0
007DA0  E00000     CP0 W0
007DA2  3A001B     BRA NZ, .L98
1014:                  {
1015:                      // clear the timestamp in temperature buffer as all elements are empty
1016:                      FRAMWriteByte(0, memLocRuntimeBufferStart + 10, 0);
007DA4  EB4080     CLR.B W1
007DA6  24EEB2     MOV #0x4EEB, W2
007DA8  200003     MOV #0x0, W3
007DAA  EB4000     CLR.B W0
007DAC  072402     RCALL FRAMWriteByte
1017:                      FRAMWriteByte(0, memLocRuntimeBufferStart + 11, 0);
007DAE  EB4080     CLR.B W1
007DB0  24EEC2     MOV #0x4EEC, W2
007DB2  200003     MOV #0x0, W3
007DB4  EB4000     CLR.B W0
007DB6  0723FD     RCALL FRAMWriteByte
1018:                      FRAMWriteByte(0, memLocRuntimeBufferStart + 12, 0);
007DB8  EB4080     CLR.B W1
007DBA  24EED2     MOV #0x4EED, W2
007DBC  200003     MOV #0x0, W3
007DBE  EB4000     CLR.B W0
007DC0  0723F8     RCALL FRAMWriteByte
1019:                      FRAMWriteByte(0, memLocRuntimeBufferStart + 13, 0);
007DC2  EB4080     CLR.B W1
007DC4  24EEE2     MOV #0x4EEE, W2
007DC6  200003     MOV #0x0, W3
007DC8  EB4000     CLR.B W0
007DCA  0723F3     RCALL FRAMWriteByte
1020:                      FRAMWriteByte(0, memLocRuntimeBufferStart + 14, 0);
007DCC  EB4080     CLR.B W1
007DCE  24EEF2     MOV #0x4EEF, W2
007DD0  200003     MOV #0x0, W3
007DD2  EB4000     CLR.B W0
007DD4  0723EE     RCALL FRAMWriteByte
007DD6  370001     BRA .L98
1021:                  }
1022:                  
1023:              }
007DDA  FA8000     ULNK
007DDC  060000     RETURN
1024:              
1025:              /*
1026:               * Buffer for setpoint data stored in FRAM
1027:               * initialize:
1028:               *     this function initializes the buffer for setpoint data storage
1029:               *     - set head to 0, 
1030:               *     - set tail to 0, 
1031:               *     - set capacity to SetpointBufferMaxCapacity (max based on allocated storage)
1032:               *     - set count to 0,
1033:               *     - set overtide count to 0,
1034:               *     - set all rtc time base bytes to 0
1035:               *    This function is called only when buffers are not Initialized, and  WriteBuffersInitialized() is called before calling this function
1036:               */
1037:              void SetpointBufferInit()
1038:              {
007DDE  FA0002     LNK #0x2
1039:                  uint8_t data;
1040:                  data = ReadBuffersInitialized();
007DE0  07FB2B     RCALL ReadBuffersInitialized
007DE2  784F00     MOV.B W0, [W14]
1041:                  if (data == (uint8_t)BufferInitializedWriteValue ) 
007DE4  B3C6D0     MOV.B #0x6D, W0
007DE6  78409E     MOV.B [W14], W1
007DE8  50CF80     SUB.B W1, W0, [W15]
007DEA  3A0032     BRA NZ, .L104
1042:                  {
1043:                      // initialize the set point buffer
1044:                      // set head to zero
1045:                      FRAMWriteWord(0x0000, memLocSetpointBufferStart, 0);
007DEC  EB4080     CLR.B W1
007DEE  200B22     MOV #0xB2, W2
007DF0  200003     MOV #0x0, W3
007DF2  EB0000     CLR W0
007DF4  07241E     RCALL FRAMWriteWord
1046:                      // set tail to zero
1047:                      FRAMWriteWord(0x0000, memLocSetpointBufferStart+2, 0);
007DF6  EB4080     CLR.B W1
007DF8  200B42     MOV #0xB4, W2
007DFA  200003     MOV #0x0, W3
007DFC  EB0000     CLR W0
007DFE  072419     RCALL FRAMWriteWord
1048:                      // set capacity to TemperatureBufferCapacity
1049:                      FRAMWriteWord((uint16_t)SetpointBufferMaxCapacity, memLocSetpointBufferStart+4, 0);
007E00  EB4080     CLR.B W1
007E02  200B62     MOV #0xB6, W2
007E04  200003     MOV #0x0, W3
007E06  213880     MOV #0x1388, W0
007E08  072414     RCALL FRAMWriteWord
1050:                      // set count to zero
1051:                      FRAMWriteWord(0x0000, memLocSetpointBufferStart+6, 0);
007E0A  EB4080     CLR.B W1
007E0C  200B82     MOV #0xB8, W2
007E0E  200003     MOV #0x0, W3
007E10  EB0000     CLR W0
007E12  07240F     RCALL FRAMWriteWord
1052:                      // set override count to zero
1053:                      FRAMWriteWord(0x0000, memLocSetpointBufferStart+8, 0);
007E14  EB4080     CLR.B W1
007E16  200BA2     MOV #0xBA, W2
007E18  200003     MOV #0x0, W3
007E1A  EB0000     CLR W0
007E1C  07240A     RCALL FRAMWriteWord
1054:                      // set all rtc time base bytes to zero
1055:                      FRAMWriteByte(0x00, memLocSetpointBufferStart+10, 0);
007E1E  EB4080     CLR.B W1
007E20  200BC2     MOV #0xBC, W2
007E22  200003     MOV #0x0, W3
007E24  EB4000     CLR.B W0
007E26  0723C5     RCALL FRAMWriteByte
1056:                      FRAMWriteByte(0x00, memLocSetpointBufferStart+11, 0);
007E28  EB4080     CLR.B W1
007E2A  200BD2     MOV #0xBD, W2
007E2C  200003     MOV #0x0, W3
007E2E  EB4000     CLR.B W0
007E30  0723C0     RCALL FRAMWriteByte
1057:                      FRAMWriteByte(0x00, memLocSetpointBufferStart+12, 0);
007E32  EB4080     CLR.B W1
007E34  200BE2     MOV #0xBE, W2
007E36  200003     MOV #0x0, W3
007E38  EB4000     CLR.B W0
007E3A  0723BB     RCALL FRAMWriteByte
1058:                      FRAMWriteByte(0x00, memLocSetpointBufferStart+13, 0);
007E3C  EB4080     CLR.B W1
007E3E  200BF2     MOV #0xBF, W2
007E40  200003     MOV #0x0, W3
007E42  EB4000     CLR.B W0
007E44  0723B6     RCALL FRAMWriteByte
1059:                      FRAMWriteByte(0x00, memLocSetpointBufferStart+14, 0);
007E46  EB4080     CLR.B W1
007E48  200C02     MOV #0xC0, W2
007E4A  200003     MOV #0x0, W3
007E4C  EB4000     CLR.B W0
007E4E  0723B1     RCALL FRAMWriteByte
1060:                  }
1061:              }
007E50  FA8000     ULNK
007E52  060000     RETURN
1062:              
1063:              
1064:              /*
1065:               * u8NewCoolSetpoint stores the cool setpoint, and u8NewHeatSetpoint stores the heat setpoint
1066:               * write the value in u8NewCoolSetpoint and u8NewHeatSetpoint into the buffer 
1067:               * one byte for Cool setpoint and one byte for heat setpoint
1068:               * this is triggered even if one of them has changed
1069:               */
1070:              void WriteSetpointBuffer()
1071:              {
007E54  FA0040     LNK #0x40
007E56  781F88     MOV W8, [W15++]
1072:                  uint8_t data;
1073:                  uint32_t u32data;
1074:                  uint16_t count_in_tempbuf;
1075:                  double diff_time;
1076:                  time_t base_t, curr_t;
1077:                  int offset;
1078:                  uint16_t tmpu16;
1079:                  struct tm base_time;
1080:                  struct tm curr_time;
1081:                  uint16_t head;
1082:                  uint16_t capacity;
1083:                  data = ReadBuffersInitialized();
007E58  07FAEF     RCALL ReadBuffersInitialized
007E5A  984F00     MOV.B W0, [W14+8]
1084:                  if (data != BufferInitializedWriteValue)
007E5C  90488E     MOV.B [W14+8], W1
007E5E  B3C6D0     MOV.B #0x6D, W0
007E60  50CF80     SUB.B W1, W0, [W15]
007E62  3A00FB     BRA NZ, .L117
1085:                  {
1086:                      return;
00805A  000000     NOP
00805C  370003     BRA .L106
1087:                  }
1088:                  count_in_tempbuf = FRAMReadWord(memLocSetpointBufferStart + 6, 0);
007E64  EB4100     CLR.B W2
007E66  200B80     MOV #0xB8, W0
007E68  200001     MOV #0x0, W1
007E6A  072536     RCALL FRAMReadWord
007E6C  980750     MOV W0, [W14+10]
1089:                  // for now if we reach max capacity, we stop writing
1090:                  head = FRAMReadWord(memLocSetpointBufferStart, 0 );
007E6E  EB4100     CLR.B W2
007E70  200B20     MOV #0xB2, W0
007E72  200001     MOV #0x0, W1
007E74  072531     RCALL FRAMReadWord
007E76  980760     MOV W0, [W14+12]
1091:                  capacity = FRAMReadWord(memLocSetpointBufferStart + 4, 0);
007E78  EB4100     CLR.B W2
007E7A  200B60     MOV #0xB6, W0
007E7C  200001     MOV #0x0, W1
007E7E  07252C     RCALL FRAMReadWord
007E80  980770     MOV W0, [W14+14]
1092:                  // reached max capacity return
1093:                  if (count_in_tempbuf >= capacity) {
007E82  9000DE     MOV [W14+10], W1
007E84  90007E     MOV [W14+14], W0
007E86  508F80     SUB W1, W0, [W15]
007E88  3100EA     BRA C, .L118
1094:                      return;
00805E  000000     NOP
008060  370001     BRA .L106
1095:                  }
1096:                  if (count_in_tempbuf == 0)
007E8A  90005E     MOV [W14+10], W0
007E8C  E00000     CP0 W0
007E8E  3A0028     BRA NZ, .L110
1097:                  {
1098:                      // write the current timestamp to rtc time base
1099:                      RTCC_TimeGet(&base_time);
007E90  47007C     ADD W14, #0x1C, W0
007E92  07267A     RCALL RTCC_TimeGet
1100:                      data = base_time.tm_year;
007E94  90103E     MOV [W14+38], W0
007E96  984F00     MOV.B W0, [W14+8]
1101:                      FRAMWriteByte(data, memLocSetpointBufferStart + 10, 0);
007E98  EB4080     CLR.B W1
007E9A  200BC2     MOV #0xBC, W2
007E9C  200003     MOV #0x0, W3
007E9E  90480E     MOV.B [W14+8], W0
007EA0  072388     RCALL FRAMWriteByte
1102:                      data = base_time.tm_mon;
007EA2  90102E     MOV [W14+36], W0
007EA4  984F00     MOV.B W0, [W14+8]
1103:                      FRAMWriteByte(data, memLocSetpointBufferStart + 11, 0);
007EA6  EB4080     CLR.B W1
007EA8  200BD2     MOV #0xBD, W2
007EAA  200003     MOV #0x0, W3
007EAC  90480E     MOV.B [W14+8], W0
007EAE  072381     RCALL FRAMWriteByte
1104:                      data = base_time.tm_mday;
007EB0  90101E     MOV [W14+34], W0
007EB2  984F00     MOV.B W0, [W14+8]
1105:                      FRAMWriteByte(data, memLocSetpointBufferStart + 12, 0);
007EB4  EB4080     CLR.B W1
007EB6  200BE2     MOV #0xBE, W2
007EB8  200003     MOV #0x0, W3
007EBA  90480E     MOV.B [W14+8], W0
007EBC  07237A     RCALL FRAMWriteByte
1106:                      data = base_time.tm_hour;
007EBE  90100E     MOV [W14+32], W0
007EC0  984F00     MOV.B W0, [W14+8]
1107:                      FRAMWriteByte(data, memLocSetpointBufferStart + 13, 0);
007EC2  EB4080     CLR.B W1
007EC4  200BF2     MOV #0xBF, W2
007EC6  200003     MOV #0x0, W3
007EC8  90480E     MOV.B [W14+8], W0
007ECA  072373     RCALL FRAMWriteByte
1108:                      data = base_time.tm_min;
007ECC  90087E     MOV [W14+30], W0
007ECE  984F00     MOV.B W0, [W14+8]
1109:                      FRAMWriteByte(data, memLocSetpointBufferStart + 14, 0);
007ED0  EB4080     CLR.B W1
007ED2  200C02     MOV #0xC0, W2
007ED4  200003     MOV #0x0, W3
007ED6  90480E     MOV.B [W14+8], W0
007ED8  07236C     RCALL FRAMWriteByte
1110:                      u32data = 0x00;
007EDA  B80060     MUL.UU W0, #0, W0
007EDC  BE8F00     MOV.D W0, [W14]
007EDE  370067     BRA .L111
1111:                      
1112:                  }
1113:                  else 
1114:                  {
1115:                      RTCC_TimeGet(&curr_time);
007EE0  2002E0     MOV #0x2E, W0
007EE2  40000E     ADD W0, W14, W0
007EE4  072651     RCALL RTCC_TimeGet
1116:                      // read the rtc time base from buffer
1117:                      data = FRAMReadByte(memLocSetpointBufferStart + 10, 0);
007EE6  EB4100     CLR.B W2
007EE8  200BC0     MOV #0xBC, W0
007EEA  200001     MOV #0x0, W1
007EEC  0724D0     RCALL FRAMReadByte
007EEE  984F00     MOV.B W0, [W14+8]
1118:                      base_time.tm_year = (int)data;
007EF0  90480E     MOV.B [W14+8], W0
007EF2  FB8000     ZE W0, W0
007EF4  981730     MOV W0, [W14+38]
1119:                      data = FRAMReadByte(memLocSetpointBufferStart + 11, 0);
007EF6  EB4100     CLR.B W2
007EF8  200BD0     MOV #0xBD, W0
007EFA  200001     MOV #0x0, W1
007EFC  0724C8     RCALL FRAMReadByte
007EFE  984F00     MOV.B W0, [W14+8]
1120:                      base_time.tm_mon = (int)data;
007F00  90480E     MOV.B [W14+8], W0
007F02  FB8000     ZE W0, W0
007F04  981720     MOV W0, [W14+36]
1121:                      data = FRAMReadByte(memLocSetpointBufferStart + 12, 0);
007F06  EB4100     CLR.B W2
007F08  200BE0     MOV #0xBE, W0
007F0A  200001     MOV #0x0, W1
007F0C  0724C0     RCALL FRAMReadByte
007F0E  984F00     MOV.B W0, [W14+8]
1122:                      base_time.tm_mday = (int)data;
007F10  90480E     MOV.B [W14+8], W0
007F12  FB8000     ZE W0, W0
007F14  981710     MOV W0, [W14+34]
1123:                      data = FRAMReadByte(memLocSetpointBufferStart + 13, 0);
007F16  EB4100     CLR.B W2
007F18  200BF0     MOV #0xBF, W0
007F1A  200001     MOV #0x0, W1
007F1C  0724B8     RCALL FRAMReadByte
007F1E  984F00     MOV.B W0, [W14+8]
1124:                      base_time.tm_hour = (int)data;
007F20  90480E     MOV.B [W14+8], W0
007F22  FB8000     ZE W0, W0
007F24  981700     MOV W0, [W14+32]
1125:                      data = FRAMReadByte(memLocSetpointBufferStart + 11, 0);
007F26  EB4100     CLR.B W2
007F28  200BD0     MOV #0xBD, W0
007F2A  200001     MOV #0x0, W1
007F2C  0724B0     RCALL FRAMReadByte
007F2E  984F00     MOV.B W0, [W14+8]
1126:                      base_time.tm_min = (int)data;
007F30  90480E     MOV.B [W14+8], W0
007F32  FB8000     ZE W0, W0
007F34  980F70     MOV W0, [W14+30]
1127:                      base_time.tm_sec = 0;
007F36  EB0000     CLR W0
007F38  980F60     MOV W0, [W14+28]
1128:                      base_t = mktime(&base_time);
007F3A  47007C     ADD W14, #0x1C, W0
007F3C  07C6E7     RCALL _mktime
007F3E  980F00     MOV W0, [W14+16]
007F40  980F11     MOV W1, [W14+18]
1129:                      curr_t = mktime(&curr_time);
007F42  2002E0     MOV #0x2E, W0
007F44  40000E     ADD W0, W14, W0
007F46  07C6E2     RCALL _mktime
007F48  980F20     MOV W0, [W14+20]
007F4A  980F31     MOV W1, [W14+22]
1130:                      diff_time = difftime(curr_t, base_t);
007F4C  90090E     MOV [W14+16], W2
007F4E  90099E     MOV [W14+18], W3
007F50  90082E     MOV [W14+20], W0
007F52  9008BE     MOV [W14+22], W1
007F54  07C6BC     RCALL _difftime
007F56  980720     MOV W0, [W14+4]
007F58  980731     MOV W1, [W14+6]
1131:                      if (diff_time < 0)
007F5A  B3C018     MOV.B #0x1, W8
007F5C  B81160     MUL.UU W2, #0, W2
007F5E  90002E     MOV [W14+4], W0
007F60  9000BE     MOV [W14+6], W1
007F62  07C2EA     RCALL ___ltsf2, ___eqsf2, ___lesf2
007F64  E00000     CP0 W0
007F66  350001     BRA LT, .L112
007F68  EB4400     CLR.B W8
007F6A  E00408     CP0.B W8
007F6C  320005     BRA Z, .L113
1132:                      {
1133:                          diff_time = -diff_time;
007F6E  90002E     MOV [W14+4], W0
007F70  9000BE     MOV [W14+6], W1
007F72  A2F001     BTG W1, #15
007F74  980720     MOV W0, [W14+4]
007F76  980731     MOV W1, [W14+6]
1134:                      }
1135:                      diff_time = diff_time / 60.0; // convert to minutes;
007F78  200002     MOV #0x0, W2
007F7A  242703     MOV #0x4270, W3
007F7C  90002E     MOV [W14+4], W0
007F7E  9000BE     MOV [W14+6], W1
007F80  07C28A     RCALL ___divsf3
007F82  980720     MOV W0, [W14+4]
007F84  980731     MOV W1, [W14+6]
1136:                      if (diff_time > (double)0xFFFF)
007F86  B3C018     MOV.B #0x1, W8
007F88  2FF002     MOV #0xFF00, W2
007F8A  2477F3     MOV #0x477F, W3
007F8C  90002E     MOV [W14+4], W0
007F8E  9000BE     MOV [W14+6], W1
007F90  07C2D5     RCALL ___gesf2, ___gtsf2
007F92  E00000     CP0 W0
007F94  3C0001     BRA GT, .L114
007F96  EB4400     CLR.B W8
007F98  E00408     CP0.B W8
007F9A  320003     BRA Z, .L115
1137:                      {
1138:                          u32data = 0;
007F9C  B80060     MUL.UU W0, #0, W0
007F9E  BE8F00     MOV.D W0, [W14]
007FA0  370006     BRA .L111
1139:                      }
1140:                      else 
1141:                      {
1142:                          u32data =(int) diff_time;
007FA2  90002E     MOV [W14+4], W0
007FA4  9000BE     MOV [W14+6], W1
007FA6  07C2CC     RCALL ___fixsfsi
007FA8  780000     MOV W0, W0
007FAA  DE80CF     ASR W0, #15, W1
007FAC  BE8F00     MOV.D W0, [W14]
1143:                      }
1144:                  }
1145:                  if ( (u32data == 0) && ( count_in_tempbuf  > 0) )
007FAE  BE001E     MOV.D [W14], W0
007FB0  500FE0     SUB W0, #0x0, [W15]
007FB2  588FE0     SUBB W1, #0x0, [W15]
007FB4  3A0003     BRA NZ, .L116
007FB6  90005E     MOV [W14+10], W0
007FB8  E00000     CP0 W0
007FBA  3A0053     BRA NZ, .L119
1146:                  {
1147:                      // cannot report data since not enough space to store time
1148:                      return;
008062  000000     NOP
1149:                  }
1150:                  //offset = count_in_tempbuf * 4 + 15; // memLocTemperatureBufferStart;
1151:                  offset = head * 4 + 15;
007FBC  90006E     MOV [W14+12], W0
007FBE  DD0042     SL W0, #2, W0
007FC0  40006F     ADD W0, #0xF, W0
007FC2  980F40     MOV W0, [W14+24]
1152:                  tmpu16 = (head + 1) % capacity;
007FC4  90006E     MOV [W14+12], W0
007FC6  E80080     INC W0, W1
007FC8  90007E     MOV [W14+14], W0
007FCA  780100     MOV W0, W2
007FCC  090011     REPEAT #0x11
007FCE  D88082     DIV.UW W1, W2
007FD0  FD0080     EXCH W0, W1
007FD2  980F50     MOV W0, [W14+26]
1153:                  data = (uint8_t)(u32data & 0xFF); // Little endian format
007FD4  78001E     MOV [W14], W0
007FD6  984F00     MOV.B W0, [W14+8]
1154:                  FRAMWriteByte(data, memLocSetpointBufferStart + offset, 0 );
007FD8  90084E     MOV [W14+24], W0
007FDA  B00B20     ADD #0xB2, W0
007FDC  B90161     MUL.SU W0, #1, W2
007FDE  EB4080     CLR.B W1
007FE0  90480E     MOV.B [W14+8], W0
007FE2  0722E7     RCALL FRAMWriteByte
1155:                  data = (uint8_t)( (u32data & 0xFF00) >> 8); // Little endian format
007FE4  2FF000     MOV #0xFF00, W0
007FE6  200001     MOV #0x0, W1
007FE8  BE011E     MOV.D [W14], W2
007FEA  780202     MOV W2, W4
007FEC  780103     MOV W3, W2
007FEE  780180     MOV W0, W3
007FF0  780001     MOV W1, W0
007FF2  620203     AND W4, W3, W4
007FF4  610000     AND W2, W0, W0
007FF6  EB0080     CLR W1
007FF8  DD00C0     SL W0, #0, W1
007FFA  200000     MOV #0x0, W0
007FFC  BE0100     MOV.D W0, W2
007FFE  B82061     MUL.UU W4, #1, W0
008000  710100     IOR W2, W0, W2
008002  718181     IOR W3, W1, W3
008004  DD1A48     SL W3, #8, W4
008006  DE1048     LSR W2, #8, W0
008008  720000     IOR W4, W0, W0
00800A  DE18C8     LSR W3, #8, W1
00800C  984F00     MOV.B W0, [W14+8]
1156:                  FRAMWriteByte(data, memLocSetpointBufferStart + offset + 1, 0);
00800E  90084E     MOV [W14+24], W0
008010  B00B30     ADD #0xB3, W0
008012  B90161     MUL.SU W0, #1, W2
008014  EB4080     CLR.B W1
008016  90480E     MOV.B [W14+8], W0
008018  0722CC     RCALL FRAMWriteByte
1157:                  data = u8NewCoolSetpoint;
00801A  208B61     MOV #0x8B6, W1
00801C  784091     MOV.B [W1], W1
00801E  984F01     MOV.B W1, [W14+8]
1158:                  FRAMWriteByte(data, memLocSetpointBufferStart + offset + 2, 0);
008020  90084E     MOV [W14+24], W0
008022  B00B40     ADD #0xB4, W0
008024  B90161     MUL.SU W0, #1, W2
008026  EB4080     CLR.B W1
008028  90480E     MOV.B [W14+8], W0
00802A  0722C3     RCALL FRAMWriteByte
1159:                  data = u8NewHeatSetpoint;
00802C  208B92     MOV #0x8B9, W2
00802E  784112     MOV.B [W2], W2
008030  984F02     MOV.B W2, [W14+8]
1160:                  FRAMWriteByte(data, memLocSetpointBufferStart + offset + 3, 0);
008032  90084E     MOV [W14+24], W0
008034  B00B50     ADD #0xB5, W0
008036  B90161     MUL.SU W0, #1, W2
008038  EB4080     CLR.B W1
00803A  90480E     MOV.B [W14+8], W0
00803C  0722BA     RCALL FRAMWriteByte
1161:                  // write number_of_items + 1 to fram
1162:                  FRAMWriteWord(tmpu16, memLocSetpointBufferStart, 0);
00803E  EB4080     CLR.B W1
008040  200B22     MOV #0xB2, W2
008042  200003     MOV #0x0, W3
008044  90085E     MOV [W14+26], W0
008046  0722F5     RCALL FRAMWriteWord
1163:                  tmpu16 = (uint16_t)(count_in_tempbuf + 1);
008048  90005E     MOV [W14+10], W0
00804A  E80000     INC W0, W0
00804C  980F50     MOV W0, [W14+26]
1164:                  FRAMWriteWord(tmpu16, memLocSetpointBufferStart + 6, 0);
00804E  EB4080     CLR.B W1
008050  200B82     MOV #0xB8, W2
008052  200003     MOV #0x0, W3
008054  90085E     MOV [W14+26], W0
008056  0722ED     RCALL FRAMWriteWord
008058  370005     BRA .L106
1165:              }
008064  78044F     MOV [--W15], W8
008066  FA8000     ULNK
008068  060000     RETURN
1166:              
1167:              /**
1168:               * ReadSetpointBuffer
1169:               *  arguments 
1170:               *      number_of_samples to read
1171:               *      data_buf(uint8_t *) for storing return elements;this must be allocated before the call
1172:               *      data_buf_len: length of buffer created
1173:               * 
1174:               *  return value:
1175:               *      int: 
1176:               *          number of uint8_t bytes written to data_buf if successful
1177:               *          -1 if data_buf_len is less than the required length for number of elements
1178:               *          -2 if temperature buffer is empty
1179:               *          -3 if buffer in FRAM has not been initialized
1180:               * 
1181:               *  format of data_buf returned
1182:               *      first 5 bytes base timestamp as stored in FRAM
1183:               *      4 BYTES per sample each
1184:               *               
1185:               */
1186:              int ReadSetpointBuffer(int number_of_samples, uint8_t * data_buf, int data_buf_len)
1187:              {
00806A  FA0014     LNK #0x14
00806C  980770     MOV W0, [W14+14]
00806E  980F01     MOV W1, [W14+16]
008070  980F12     MOV W2, [W14+18]
1188:                  uint8_t data;
1189:                  int buf_ret_count = 0;
008072  EB0000     CLR W0
008074  780F00     MOV W0, [W14]
1190:                  uint16_t count_in_tempbuf;
1191:                  int ii;
1192:                  uint16_t tail;
1193:                  uint16_t capacity;
1194:                  int offset;
1195:                  
1196:                  data = ReadBuffersInitialized();
008076  07F9E0     RCALL ReadBuffersInitialized
008078  984F00     MOV.B W0, [W14+8]
1197:                  if (data != BufferInitializedWriteValue)
00807A  90488E     MOV.B [W14+8], W1
00807C  B3C6D0     MOV.B #0x6D, W0
00807E  50CF80     SUB.B W1, W0, [W15]
008080  320002     BRA Z, .L121
1198:                  {
1199:                      return -3;
008082  2FFFD0     MOV #0xFFFD, W0
008084  3700A2     BRA .L122
1200:                  }
1201:                  if ( (number_of_samples * 4 + 5) > data_buf_len) 
008086  90007E     MOV [W14+14], W0
008088  DD0042     SL W0, #2, W0
00808A  4000E5     ADD W0, #0x5, W1
00808C  90081E     MOV [W14+18], W0
00808E  508F80     SUB W1, W0, [W15]
008090  340002     BRA LE, .L123
1202:                  {
1203:                      // insufficient space to return data
1204:                      return -1;
008092  EB8000     SETM W0
008094  37009A     BRA .L122
1205:                  }
1206:                  count_in_tempbuf = FRAMReadWord(memLocSetpointBufferStart + 6, 0);
008096  EB4100     CLR.B W2
008098  200B80     MOV #0xB8, W0
00809A  200001     MOV #0x0, W1
00809C  07241D     RCALL FRAMReadWord
00809E  980710     MOV W0, [W14+2]
1207:                  if ( count_in_tempbuf == 0)
0080A0  90001E     MOV [W14+2], W0
0080A2  E00000     CP0 W0
0080A4  3A0002     BRA NZ, .L124
1208:                  {
1209:                      return -2;
0080A6  2FFFE0     MOV #0xFFFE, W0
0080A8  370090     BRA .L122
1210:                  }
1211:                  tail = FRAMReadWord(memLocSetpointBufferStart + 2, 0);
0080AA  EB4100     CLR.B W2
0080AC  200B40     MOV #0xB4, W0
0080AE  200001     MOV #0x0, W1
0080B0  072413     RCALL FRAMReadWord
0080B2  980730     MOV W0, [W14+6]
1212:                  capacity = FRAMReadWord(memLocSetpointBufferStart + 4, 0);
0080B4  EB4100     CLR.B W2
0080B6  200B60     MOV #0xB6, W0
0080B8  200001     MOV #0x0, W1
0080BA  07240E     RCALL FRAMReadWord
0080BC  980750     MOV W0, [W14+10]
1213:                  
1214:                  buf_ret_count = 0;
0080BE  EB0000     CLR W0
0080C0  780F00     MOV W0, [W14]
1215:                  data = FRAMReadByte(memLocSetpointBufferStart + 10, 0);
0080C2  EB4100     CLR.B W2
0080C4  200BC0     MOV #0xBC, W0
0080C6  200001     MOV #0x0, W1
0080C8  0723E2     RCALL FRAMReadByte
0080CA  984F00     MOV.B W0, [W14+8]
1216:                  data_buf[buf_ret_count] = data;
0080CC  78001E     MOV [W14], W0
0080CE  90088E     MOV [W14+16], W1
0080D0  408000     ADD W1, W0, W0
0080D2  90488E     MOV.B [W14+8], W1
0080D4  784801     MOV.B W1, [W0]
1217:                  buf_ret_count ++;
0080D6  E80F1E     INC [W14], [W14]
1218:                  data = FRAMReadByte(memLocSetpointBufferStart + 11, 0);
0080D8  EB4100     CLR.B W2
0080DA  200BD0     MOV #0xBD, W0
0080DC  200001     MOV #0x0, W1
0080DE  0723D7     RCALL FRAMReadByte
0080E0  984F00     MOV.B W0, [W14+8]
1219:                  data_buf[buf_ret_count] = data; 
0080E2  78001E     MOV [W14], W0
0080E4  90088E     MOV [W14+16], W1
0080E6  408000     ADD W1, W0, W0
0080E8  90490E     MOV.B [W14+8], W2
0080EA  784802     MOV.B W2, [W0]
1220:                  buf_ret_count ++;
0080EC  E80F1E     INC [W14], [W14]
1221:                  data = FRAMReadByte(memLocSetpointBufferStart + 12, 0);
0080EE  EB4100     CLR.B W2
0080F0  200BE0     MOV #0xBE, W0
0080F2  200001     MOV #0x0, W1
0080F4  0723CC     RCALL FRAMReadByte
0080F6  984F00     MOV.B W0, [W14+8]
1222:                  data_buf[buf_ret_count] = data;
0080F8  78001E     MOV [W14], W0
0080FA  90088E     MOV [W14+16], W1
0080FC  408000     ADD W1, W0, W0
0080FE  90488E     MOV.B [W14+8], W1
008100  784801     MOV.B W1, [W0]
1223:                  buf_ret_count ++;
008102  E80F1E     INC [W14], [W14]
1224:                  data = FRAMReadByte(memLocSetpointBufferStart + 13, 0);
008104  EB4100     CLR.B W2
008106  200BF0     MOV #0xBF, W0
008108  200001     MOV #0x0, W1
00810A  0723C1     RCALL FRAMReadByte
00810C  984F00     MOV.B W0, [W14+8]
1225:                  data_buf[buf_ret_count] = data;
00810E  78001E     MOV [W14], W0
008110  90088E     MOV [W14+16], W1
008112  408000     ADD W1, W0, W0
008114  90490E     MOV.B [W14+8], W2
008116  784802     MOV.B W2, [W0]
1226:                  buf_ret_count ++;
008118  E80F1E     INC [W14], [W14]
1227:                  data = FRAMReadByte(memLocSetpointBufferStart + 11, 0);
00811A  EB4100     CLR.B W2
00811C  200BD0     MOV #0xBD, W0
00811E  200001     MOV #0x0, W1
008120  0723B6     RCALL FRAMReadByte
008122  984F00     MOV.B W0, [W14+8]
1228:                  data_buf[buf_ret_count] = data;
008124  78001E     MOV [W14], W0
008126  90088E     MOV [W14+16], W1
008128  408000     ADD W1, W0, W0
00812A  90488E     MOV.B [W14+8], W1
00812C  784801     MOV.B W1, [W0]
1229:                  buf_ret_count ++;
00812E  E80F1E     INC [W14], [W14]
1230:                  ii = 0;
008130  EB0000     CLR W0
008132  980720     MOV W0, [W14+4]
1231:                  while ( (ii < number_of_samples) && (count_in_tempbuf > 0) )
008134  370042     BRA .L125
0081BA  9000AE     MOV [W14+4], W1
0081BC  90007E     MOV [W14+14], W0
0081BE  508F80     SUB W1, W0, [W15]
0081C0  3D0003     BRA GE, .L126
0081C2  90001E     MOV [W14+2], W0
0081C4  E00000     CP0 W0
0081C6  3AFFB7     BRA NZ, .L127
1232:                  {
1233:                      offset = tail * 4 + 15;
008136  90003E     MOV [W14+6], W0
008138  DD0042     SL W0, #2, W0
00813A  40006F     ADD W0, #0xF, W0
00813C  980760     MOV W0, [W14+12]
1234:                      data = FRAMReadByte(memLocSetpointBufferStart + offset, 0);
00813E  90006E     MOV [W14+12], W0
008140  B00B20     ADD #0xB2, W0
008142  DE80CF     ASR W0, #15, W1
008144  EB4100     CLR.B W2
008146  0723A3     RCALL FRAMReadByte
008148  984F00     MOV.B W0, [W14+8]
1235:                      data_buf[buf_ret_count] = data;
00814A  78001E     MOV [W14], W0
00814C  90088E     MOV [W14+16], W1
00814E  408000     ADD W1, W0, W0
008150  90490E     MOV.B [W14+8], W2
008152  784802     MOV.B W2, [W0]
1236:                      buf_ret_count ++;
008154  E80F1E     INC [W14], [W14]
1237:                      data = FRAMReadByte(memLocSetpointBufferStart + offset+1, 0);
008156  90006E     MOV [W14+12], W0
008158  B00B30     ADD #0xB3, W0
00815A  DE80CF     ASR W0, #15, W1
00815C  EB4100     CLR.B W2
00815E  072397     RCALL FRAMReadByte
008160  984F00     MOV.B W0, [W14+8]
1238:                      data_buf[buf_ret_count] = data;
008162  78001E     MOV [W14], W0
008164  90088E     MOV [W14+16], W1
008166  408000     ADD W1, W0, W0
008168  90488E     MOV.B [W14+8], W1
00816A  784801     MOV.B W1, [W0]
1239:                      buf_ret_count ++;
00816C  E80F1E     INC [W14], [W14]
1240:                      data = FRAMReadByte(memLocSetpointBufferStart + offset+2, 0);
00816E  90006E     MOV [W14+12], W0
008170  B00B40     ADD #0xB4, W0
008172  DE80CF     ASR W0, #15, W1
008174  EB4100     CLR.B W2
008176  07238B     RCALL FRAMReadByte
008178  984F00     MOV.B W0, [W14+8]
1241:                      data_buf[buf_ret_count] = data;
00817A  78001E     MOV [W14], W0
00817C  90088E     MOV [W14+16], W1
00817E  408000     ADD W1, W0, W0
008180  90490E     MOV.B [W14+8], W2
008182  784802     MOV.B W2, [W0]
1242:                      buf_ret_count ++;
008184  E80F1E     INC [W14], [W14]
1243:                      data = FRAMReadByte(memLocSetpointBufferStart + offset+3, 0);
008186  90006E     MOV [W14+12], W0
008188  B00B50     ADD #0xB5, W0
00818A  DE80CF     ASR W0, #15, W1
00818C  EB4100     CLR.B W2
00818E  07237F     RCALL FRAMReadByte
008190  984F00     MOV.B W0, [W14+8]
1244:                      data_buf[buf_ret_count] = data;
008192  78001E     MOV [W14], W0
008194  90088E     MOV [W14+16], W1
008196  408000     ADD W1, W0, W0
008198  90488E     MOV.B [W14+8], W1
00819A  784801     MOV.B W1, [W0]
1245:                      buf_ret_count ++;
00819C  E80F1E     INC [W14], [W14]
1246:                      tail = (tail + 1) % capacity;
00819E  90003E     MOV [W14+6], W0
0081A0  E80080     INC W0, W1
0081A2  90005E     MOV [W14+10], W0
0081A4  780100     MOV W0, W2
0081A6  090011     REPEAT #0x11
0081A8  D88082     DIV.UW W1, W2
0081AA  FD0080     EXCH W0, W1
0081AC  980730     MOV W0, [W14+6]
1247:                      count_in_tempbuf --;
0081AE  90001E     MOV [W14+2], W0
0081B0  E90000     DEC W0, W0
0081B2  980710     MOV W0, [W14+2]
1248:                      ii++;
0081B4  90002E     MOV [W14+4], W0
0081B6  E80000     INC W0, W0
0081B8  980720     MOV W0, [W14+4]
1249:                  }
1250:                  return buf_ret_count;
0081C8  78001E     MOV [W14], W0
1251:              }
0081CA  FA8000     ULNK
0081CC  060000     RETURN
1252:              
1253:              
1254:              /**
1255:               * 
1256:               * @param num_of_items
1257:               * Delete from FRAM num_of_items from setpoint Buffer
1258:               *      since they were successfully transmitted
1259:               */
1260:              void DeleteEntriesSetpointBuffer(int num_of_items)
1261:              {
0081CE  FA0008     LNK #0x8
0081D0  980730     MOV W0, [W14+6]
1262:                  uint16_t count_in_tempbuf;
1263:                  uint16_t tail;
1264:                  uint16_t capacity;
1265:                  count_in_tempbuf = FRAMReadWord(memLocSetpointBufferStart + 6, 0);
0081D2  EB4100     CLR.B W2
0081D4  200B80     MOV #0xB8, W0
0081D6  200001     MOV #0x0, W1
0081D8  07237F     RCALL FRAMReadWord
0081DA  780F00     MOV W0, [W14]
1266:                  if ( count_in_tempbuf == 0)
0081DC  78001E     MOV [W14], W0
0081DE  E00000     CP0 W0
0081E0  32004A     BRA Z, .L133
1267:                  {
1268:                      return;
008276  000000     NOP
1269:                  }
1270:                  tail = FRAMReadWord(memLocSetpointBufferStart + 2, 0);
0081E2  EB4100     CLR.B W2
0081E4  200B40     MOV #0xB4, W0
0081E6  200001     MOV #0x0, W1
0081E8  072377     RCALL FRAMReadWord
0081EA  980710     MOV W0, [W14+2]
1271:                  capacity = FRAMReadWord(memLocSetpointBufferStart + 4, 0);
0081EC  EB4100     CLR.B W2
0081EE  200B60     MOV #0xB6, W0
0081F0  200001     MOV #0x0, W1
0081F2  072372     RCALL FRAMReadWord
0081F4  980720     MOV W0, [W14+4]
1272:                  if (count_in_tempbuf < num_of_items)
0081F6  90003E     MOV [W14+6], W0
0081F8  500F9E     SUB W0, [W14], [W15]
0081FA  36000B     BRA LEU, .L131
1273:                  {
1274:                      tail = (tail + count_in_tempbuf) % capacity;
0081FC  90001E     MOV [W14+2], W0
0081FE  40009E     ADD W0, [W14], W1
008200  90002E     MOV [W14+4], W0
008202  780100     MOV W0, W2
008204  090011     REPEAT #0x11
008206  D88082     DIV.UW W1, W2
008208  FD0080     EXCH W0, W1
00820A  980710     MOV W0, [W14+2]
1275:                      count_in_tempbuf = 0;
00820C  EB0000     CLR W0
00820E  780F00     MOV W0, [W14]
008210  37000B     BRA .L132
1276:                  }
1277:                  else 
1278:                  {
1279:                      count_in_tempbuf -= num_of_items;
008212  90003E     MOV [W14+6], W0
008214  100F1E     SUBR W0, [W14], [W14]
1280:                      tail = (tail + num_of_items) % capacity;
008216  9000BE     MOV [W14+6], W1
008218  90001E     MOV [W14+2], W0
00821A  408080     ADD W1, W0, W1
00821C  90002E     MOV [W14+4], W0
00821E  780100     MOV W0, W2
008220  090011     REPEAT #0x11
008222  D88082     DIV.UW W1, W2
008224  FD0080     EXCH W0, W1
008226  980710     MOV W0, [W14+2]
1281:                  }
1282:                  // write new tail to fram
1283:                  FRAMWriteWord(count_in_tempbuf, memLocSetpointBufferStart + 6,    0);
008228  EB4080     CLR.B W1
00822A  200B82     MOV #0xB8, W2
00822C  200003     MOV #0x0, W3
00822E  78001E     MOV [W14], W0
008230  072200     RCALL FRAMWriteWord
1284:                  FRAMWriteWord(tail, memLocSetpointBufferStart + 2, 0);
008232  EB4080     CLR.B W1
008234  200B42     MOV #0xB4, W2
008236  200003     MOV #0x0, W3
008238  90001E     MOV [W14+2], W0
00823A  0721FB     RCALL FRAMWriteWord
1285:                  if (count_in_tempbuf == 0)
00823C  78001E     MOV [W14], W0
00823E  E00000     CP0 W0
008240  3A001B     BRA NZ, .L128
1286:                  {
1287:                      // clear the timestamp in temperature buffer as all elements are empty
1288:                      FRAMWriteByte(0, memLocSetpointBufferStart + 10, 0);
008242  EB4080     CLR.B W1
008244  200BC2     MOV #0xBC, W2
008246  200003     MOV #0x0, W3
008248  EB4000     CLR.B W0
00824A  0721B3     RCALL FRAMWriteByte
1289:                      FRAMWriteByte(0, memLocSetpointBufferStart + 11, 0);
00824C  EB4080     CLR.B W1
00824E  200BD2     MOV #0xBD, W2
008250  200003     MOV #0x0, W3
008252  EB4000     CLR.B W0
008254  0721AE     RCALL FRAMWriteByte
1290:                      FRAMWriteByte(0, memLocSetpointBufferStart + 12, 0);
008256  EB4080     CLR.B W1
008258  200BE2     MOV #0xBE, W2
00825A  200003     MOV #0x0, W3
00825C  EB4000     CLR.B W0
00825E  0721A9     RCALL FRAMWriteByte
1291:                      FRAMWriteByte(0, memLocSetpointBufferStart + 13, 0);
008260  EB4080     CLR.B W1
008262  200BF2     MOV #0xBF, W2
008264  200003     MOV #0x0, W3
008266  EB4000     CLR.B W0
008268  0721A4     RCALL FRAMWriteByte
1292:                      FRAMWriteByte(0, memLocSetpointBufferStart + 14, 0);
00826A  EB4080     CLR.B W1
00826C  200C02     MOV #0xC0, W2
00826E  200003     MOV #0x0, W3
008270  EB4000     CLR.B W0
008272  07219F     RCALL FRAMWriteByte
008274  370001     BRA .L128
1293:                  }
1294:                  
1295:              }
008278  FA8000     ULNK
00827A  060000     RETURN
1296:              
1297:              void ParametersInit()
1298:              {
00827C  FA0000     LNK #0x0
1299:                  FRAMWriteByte(0x01, memLocHysteresis, 0);
00827E  EB4080     CLR.B W1
008280  200132     MOV #0x13, W2
008282  200003     MOV #0x0, W3
008284  B3C010     MOV.B #0x1, W0
008286  072195     RCALL FRAMWriteByte
1300:                  FRAMWriteByte(MODE_HEATCOOL, memLocThermostatMode, 0);
008288  EB4080     CLR.B W1
00828A  200142     MOV #0x14, W2
00828C  200003     MOV #0x0, W3
00828E  B3C030     MOV.B #0x3, W0
008290  072190     RCALL FRAMWriteByte
1301:                  FRAMWriteByte(COOL_SETPOINT_DEFAULT_DEGF, memLocCoolSetpoint, 0);
008292  EB4080     CLR.B W1
008294  200072     MOV #0x7, W2
008296  200003     MOV #0x0, W3
008298  B3C4E0     MOV.B #0x4E, W0
00829A  07218B     RCALL FRAMWriteByte
1302:                  FRAMWriteByte(HEAT_SETPOINT_DEFAULT_DEGF, memLocHeatSetpoint, 0);
00829C  EB4080     CLR.B W1
00829E  200082     MOV #0x8, W2
0082A0  200003     MOV #0x0, W3
0082A2  B3C440     MOV.B #0x44, W0
0082A4  072186     RCALL FRAMWriteByte
1303:                  FRAMWriteByte(SCHEDULE_NONE, memLocPreviousSchedule, 0);
0082A6  EB4080     CLR.B W1
0082A8  2000F2     MOV #0xF, W2
0082AA  200003     MOV #0x0, W3
0082AC  B3C040     MOV.B #0x4, W0
0082AE  072181     RCALL FRAMWriteByte
1304:              }
0082B0  FA8000     ULNK
0082B2  060000     RETURN
1305:              
1306:              /**
1307:               * Reads the FRAM to check if schedule has been received by reading the 
1308:               *  bitmaps at specific locations
1309:               * @return 1 if all required bitmpas are set
1310:               * @return 0 otherwise
1311:               */
1312:              uint8_t ScheduleAvailable()
1313:              {
0082B4  FA0006     LNK #0x6
1314:                  uint8_t tmpu8;
1315:                  uint32_t tmpu32;
1316:                  tmpu8 = FRAMReadByte(memLocScheduleStart, 0);
0082B6  EB4100     CLR.B W2
0082B8  200190     MOV #0x19, W0
0082BA  200001     MOV #0x0, W1
0082BC  0722E8     RCALL FRAMReadByte
0082BE  784F00     MOV.B W0, [W14]
1317:                  if ( (tmpu8 & 0x07 ) == 0x07 )
0082C0  FB801E     ZE [W14], W0
0082C2  600067     AND W0, #0x7, W0
0082C4  500FE7     SUB W0, #0x7, [W15]
0082C6  3A0011     BRA NZ, .L136
1318:                  {
1319:                      tmpu32 = FRAMReadLong(memLocScheduleStart+1, 0);
0082C8  EB4100     CLR.B W2
0082CA  2001A0     MOV #0x1A, W0
0082CC  200001     MOV #0x0, W1
0082CE  072334     RCALL FRAMReadLong
0082D0  980710     MOV W0, [W14+2]
0082D2  980721     MOV W1, [W14+4]
1320:                      if (tmpu32 == 0xFFFFFFFF)
0082D4  90011E     MOV [W14+2], W2
0082D6  9001AE     MOV [W14+4], W3
0082D8  EB8000     SETM W0
0082DA  EB8080     SETM W1
0082DC  510F80     SUB W2, W0, [W15]
0082DE  598F81     SUBB W3, W1, [W15]
0082E0  3A0002     BRA NZ, .L137
1321:                      {
1322:                          return 1;
0082E2  B3C010     MOV.B #0x1, W0
0082E4  370003     BRA .L138
1323:                      }
1324:                      else 
1325:                      {
1326:                          return 0;
0082E6  EB4000     CLR.B W0
0082E8  370001     BRA .L138
1327:                      }
1328:                  }
1329:                  else 
1330:                  {
1331:                      return 0;
0082EA  EB4000     CLR.B W0
1332:                  }
1333:              }
0082EC  FA8000     ULNK
0082EE  060000     RETURN
1334:              
1335:              /**
1336:               * Reads the FRAM to check if DRSchedule has been received by reading the 
1337:               *  bitmap at the specified location
1338:               * @return 1 if if available
1339:               * @return 0 otherwise
1340:               */
1341:              uint8_t DRScheduleAvailable()
1342:              {
0082F0  FA0002     LNK #0x2
1343:                  uint8_t tmpu8;
1344:                  uint32_t tmpu32;
1345:                  tmpu8 = FRAMReadByte(memLocScheduleStart, 0);
0082F2  EB4100     CLR.B W2
0082F4  200190     MOV #0x19, W0
0082F6  200001     MOV #0x0, W1
0082F8  0722CA     RCALL FRAMReadByte
0082FA  784F00     MOV.B W0, [W14]
1346:                  if ( (tmpu8 & 0x08 ) == 0x08 )
0082FC  FB801E     ZE [W14], W0
0082FE  600068     AND W0, #0x8, W0
008300  E00000     CP0 W0
008302  320002     BRA Z, .L140
1347:                  {
1348:                      return 1;
008304  B3C010     MOV.B #0x1, W0
008306  370001     BRA .L141
1349:                  }
1350:                  else 
1351:                  {
1352:                      return 0;
008308  EB4000     CLR.B W0
1353:                  }
1354:              }
00830A  FA8000     ULNK
00830C  060000     RETURN
1355:              
1356:              
1357:              
1358:              /**
1359:               * Writes the away schedule to FRAM
1360:               * @param th_mode
1361:               * @param cool_sp
1362:               * @param heat_sp
1363:               */
1364:              void WriteAwayScheduleMode(uint8_t th_mode, uint8_t cool_sp, uint8_t heat_sp)
1365:              {
00830E  FA0004     LNK #0x4
008310  784F00     MOV.B W0, [W14]
008312  984711     MOV.B W1, [W14+1]
008314  984722     MOV.B W2, [W14+2]
1366:                  FRAMWriteByte(th_mode, memLocAwayThermostatMode, 0);
008316  EB4080     CLR.B W1
008318  200102     MOV #0x10, W2
00831A  200003     MOV #0x0, W3
00831C  78401E     MOV.B [W14], W0
00831E  072149     RCALL FRAMWriteByte
1367:                  FRAMWriteByte(cool_sp, memLocAwayCoolSetpoint, 0);
008320  EB4080     CLR.B W1
008322  200112     MOV #0x11, W2
008324  200003     MOV #0x0, W3
008326  90401E     MOV.B [W14+1], W0
008328  072144     RCALL FRAMWriteByte
1368:                  FRAMWriteByte(heat_sp, memLocAwayHeatSetpoint, 0);
00832A  EB4080     CLR.B W1
00832C  200122     MOV #0x12, W2
00832E  200003     MOV #0x0, W3
008330  90402E     MOV.B [W14+2], W0
008332  07213F     RCALL FRAMWriteByte
1369:                  
1370:              }
008334  FA8000     ULNK
008336  060000     RETURN
1371:              
1372:              /**
1373:               * Reads the away schedule mode and setpoints
1374:               * and populates the appropriate variable 
1375:               *      u8ThermostatMode, u8CoolSetpoint, u8HeatSetpoint
1376:               */
1377:              void ReadAwayScheduleMode()
1378:              {
008338  FA0002     LNK #0x2
1379:                  uint8_t tmpu8;
1380:                  tmpu8 = FRAMReadByte(memLocAwayThermostatMode, 0);
00833A  EB4100     CLR.B W2
00833C  200100     MOV #0x10, W0
00833E  200001     MOV #0x0, W1
008340  0722A6     RCALL FRAMReadByte
008342  784F00     MOV.B W0, [W14]
1381:                  u8ThermostatMode = tmpu8;
008344  78411E     MOV.B [W14], W2
008346  208BE1     MOV #0x8BE, W1
008348  784882     MOV.B W2, [W1]
1382:                  tmpu8 = FRAMReadByte(memLocAwayCoolSetpoint, 0);
00834A  EB4100     CLR.B W2
00834C  200110     MOV #0x11, W0
00834E  200001     MOV #0x0, W1
008350  07229E     RCALL FRAMReadByte
008352  784F00     MOV.B W0, [W14]
1383:                  u8CoolSetpoint = tmpu8;
008354  78411E     MOV.B [W14], W2
008356  208B51     MOV #0x8B5, W1
008358  784882     MOV.B W2, [W1]
1384:                  tmpu8 = FRAMReadByte(memLocAwayHeatSetpoint, 0);
00835A  EB4100     CLR.B W2
00835C  200120     MOV #0x12, W0
00835E  200001     MOV #0x0, W1
008360  072296     RCALL FRAMReadByte
008362  784F00     MOV.B W0, [W14]
1385:                  u8HeatSetpoint = tmpu8;
008364  78411E     MOV.B [W14], W2
008366  208B81     MOV #0x8B8, W1
008368  784882     MOV.B W2, [W1]
1386:              }
00836A  FA8000     ULNK
00836C  060000     RETURN
---  C:/Users/pvan002/Box Sync/low_income_thermostats/lita_sw/R1/main.c  --------------------------------
1:                  /*
2:                  *      
3:                  *      File:   main.c
4:                  *      Author: Madhu Annapragada
5:                  *      Company: Automation Research Group
6:                  *               3401 Grays Ferry Ave, B197, STE305
7:                  *               Philadelphia, PA 19146 
8:                  *               302-897-7776
9:                  *      Created on January 09, 2018
10:                 * 
11:                 */
12:                
13:                
14:                #include <xc.h>
15:                #include "main.h"
16:                #include "system.h" //system level functions
17:                #include "rtcc.h" //real time clock
18:                #include "RN4871.h" //Bluetooth module
19:                #include "FRAM.h" //Memory
20:                #include "epaper.h"
21:                #include "BME680.h"
22:                #include "bme680_defs.h"
23:                #include "hal.h" //all the hardware config functions + low level comms
24:                #include "memory.h"
25:                
26:                //******************
27:                // important defines
28:                //******************
29:                #define testble 1 // for testing ble comms: comment out to disable test: test will copy data to separate buffers but will not execute any values
30:                    
31:                //*****************
32:                //    Globals:
33:                //*****************
34:                
35:                // Bluetooth ADV Parameters
36:                char MODEL_NAME[] = "LYDIA";
37:                char DeviceClass[] = {0}; //6 characters for serial number, 4 for name
38:                
39:                //Misc Bluetooth parameters: 
40:                char SerialNum[] = "00000001";
41:                char MFG_UUID[] = "3e952a7a-18d4-11e9-ab14-d663bd873d93"; //generated on-line uuidgenerator.net
42:                char HARDWARE_REVISION[] = "1.0.0";
43:                char MFG_NAME[] = "EPRI";
44:                char MFG_ID[5] = "FFFF"; //TODO : change this when product is registered and MFG id is obtained
45:                char SOFTWARE_REV[] = "1.0.0";
46:                
47:                bool bTimerButtonPressed = false;
48:                bool bUpButtonPressed = false;
49:                bool bDownButtonPressed = false;
50:                bool bPowerButtonPressed = false;
51:                
52:                bool PWR_24VAC_ON = false;
53:                
54:                bool RTCCAlarmOn = false;
55:                
56:                uint8_t u8CurrentState = 0;
57:                
58:                
59:                //Generated online : 01/15/2019:12:55PM
60:                //Service UUIDs:
61:                char LITInfoServiceUUID[] = "968ec3f218ee11e9ab14d663bd873d93";
62:                
63:                //Characteristics UUID for infoService:
64:                char LITBETemperatureCharUUID[] = "968ec69a18ee11e9ab14d663bd873d93"; //Board Edge Temperature
65:                char LITBETemperatureCharHandle[] = "0072"; //RN4871 default handles start at 0x72 and increment by 0x02
66:                char LITBCTemperatureCharUUID[] = "ce01d1e619b411e9ab14d663bd873d93"; //Board Center Temperature
67:                char LITBCTemperatureCharHandle[] = "0074"; //RN4871 default handles start at 0x72 and increment by 0x02
68:                char LITACurrentSettingCharUUID[] = "ff21df2754f34790b6bf5b589358f656"; // current setting characteristic
69:                char LITACurrentSettingCharHandle[] = "0072";
70:                uint8_t LITACurrentSettingU8Length = 7;
71:                char LITATimeSynchronizeCharUUID[] = "34d64eb8cfcb4424b7b7458ac60cd7ca";
72:                char LITATimeSynchronizeCharHandle [] = "0074";
73:                uint8_t LITATimeSynchronizeU8Length = 7;
74:                char LITAUserParametersCharUUID [] = "49481a839ca64306845eeacd8528508d";
75:                char LITAUserParametersCharHandle [] = "0076";
76:                uint8_t LITAUserParametersU8Length = 12; // 11; for version 1.1 ; 12; // for ver 1.3 GATT_SPECS docucment
77:                char LITASchedulesCharUUID[] = "db468f6304dd4ae6ba1d4861137a3d46";
78:                char LITASchedulesCharHandle[] = "0078";
79:                uint8_t LITASchedulesU8Length = 20;
80:                char LITAAcknowledgementUUID[] = "a8d82b510db342a8af521bc8d7650152";
81:                char LITAAcknowledgementHandle[] = "007A";
82:                uint8_t LITAAcknowledgementLength = 1;
83:                char LITATemperatureBufferUUID[] = "5b76db2d46324a9bbb5d88d77e805980";
84:                char LITATemperatureBufferHandle[] = "007C";
85:                uint8_t LITATemperatureBufferLength = 20;
86:                char LITARuntimeBufferUUID[] = "12b874e7e64841b7a0d09b1f6a8bdcd0";
87:                char LITARuntimeBufferHandle[] = "007E";
88:                uint8_t LITARuntimeBufferLength = 20;
89:                char LITASetpointBufferUUID[] = "d802af929f4f4c1981d26398bc7a04db";
90:                char LITASetpointBufferHandle[] = "0080";
91:                uint8_t LITASetpointBufferLength = 20;
92:                
93:                #ifdef testble
94:                uint8_t dbgTimeSyncBLE[7];
95:                uint8_t dbgUserParamBLE[12];
96:                uint8_t dbgSchedulesBLE[50*5];
97:                uint8_t dbgTemperatureBuffer[200];
98:                uint8_t dbgTemperatureBufIndex = 0;
99:                uint8_t dbgRuntimeBuffer[200];
100:               uint8_t dbgRuntimeBufIndex = 0;
101:               uint8_t dbgSetpointBuffer[200];
102:               uint8_t dbgSetpointBufIndex = 0;
103:               #endif
104:               
105:               
106:               uint8_t u8ApplicationState=0;
107:               uint8_t u8CoolSetpoint=0;
108:               uint8_t u8NewCoolSetpoint;
109:               uint8_t u8SchNoneCoolSetpoint;
110:               uint8_t u8HeatSetpoint=0;
111:               uint8_t u8NewHeatSetpoint=0;
112:               uint8_t u8SchNoneHeatSetpoint;
113:               uint8_t u8Hysteresis=0;
114:               uint16_t u16PartialScreenUpdateCount=0;
115:               uint8_t u8ThermostatMode=0;
116:               uint8_t u8PrevThermostatMode=0;
117:               uint8_t u8arrTodaySchedule[] = {0};
118:               uint8_t u8arrSchedule[] = {0};
119:               uint8_t u8arrDrEvent[8] = {0};
120:               uint8_t u8CurrentTemperature=0;
121:               uint8_t u8PrevCurrentTemperature=0;
122:               uint8_t u8CurrentThermostatAction=0;
123:               uint8_t u8TimerMinutesToOff=0;
124:               uint8_t display_digit_1=0xFF;
125:               uint8_t display_digit_2=0xFF;
126:               uint8_t u8ActionOnScreen = 0; // heat or cool is written to screen
127:               uint8_t u8BatteryOnScreen = 0;
128:               uint16_t u16PartialUpdateCount;
129:               uint8_t u8TimerOnScreen=0;
130:               uint8_t u8TempArr[5]={0};
131:               int u8TempSum;
132:               float u8TempAvg;
133:               int u8TempArrIndex=0;
134:               int u8TempArrCount;
135:               uint8_t u8RelativeHumidity;
136:               uint8_t u8arrBLEChRx[BLE_CHARACTERISTIC_SIZE] = {0}; // user to write to characteristic values in rn4871
137:               uint8_t u8arrBLEChTx[BLE_CHARACTERISTIC_SIZE] = {0}; // user to write to characteristic values in rn4871
138:               uint8_t u8IndoorAirQuality = 0;
139:               uint8_t u8Schedule;
140:               uint8_t u8PrevSchedule;
141:               uint8_t u8GotoSchedule;
142:               int32_t i32DurationMins;
143:               uint8_t u8AwayThermostatMode;
144:               uint8_t u8AwayHeatSetpoint;
145:               uint8_t u8AwayCoolSetpoint;
146:               
147:               
148:               int main(void)
149:               {
00AC9A  FA006A     LNK #0x6A
150:                   //*********************
151:                   //      locals
152:                   //*********************         
153:                   uint16_t u16activityTimeout = 30; //timeout in seconds. System goes to sleep after this
00AC9C  2001E0     MOV #0x1E, W0
00AC9E  980760     MOV W0, [W14+12]
154:                   
155:                   uint32_t temp_long = 0;  
00ACA0  B80060     MUL.UU W0, #0, W0
00ACA2  980770     MOV W0, [W14+14]
00ACA4  980F01     MOV W1, [W14+16]
156:                   char tmpStr[30] = {0};
00ACA6  4700FB     ADD W14, #0x1B, W1
00ACA8  09001D     REPEAT #0x1D
00ACAA  EB5880     CLR.B [W1++]
157:                   char tmpStr2[30] = {0};
00ACAC  78010E     MOV W14, W2
00ACAE  B00392     ADD #0x39, W2
00ACB0  09001D     REPEAT #0x1D
00ACB2  EB5900     CLR.B [W2++]
158:                   bool IsBluetoothUp = false;
00ACB4  EB4000     CLR.B W0
00ACB6  985720     MOV.B W0, [W14+18]
159:                   
160:                   uint16_t battVoltage = 0; //in mv
00ACB8  EB0000     CLR W0
00ACBA  780F00     MOV W0, [W14]
161:                   
162:                   uint8_t  retval8 = 0;
00ACBC  EB4000     CLR.B W0
00ACBE  985730     MOV.B W0, [W14+19]
163:                   
164:                   uint8_t tmp_app_state;
165:                   uint8_t tmpu8;
166:                   uint8_t tmpu8_dow, tmpu8_num;
167:                   uint8_t tmpu8_count, tmpu8_idx;
168:                   uint8_t tmpu8_hsp, tmpu8_csp;
169:                   
170:                   bool goto_sleep_immediate = false;
00ACC0  EB4000     CLR.B W0
00ACC2  984770     MOV.B W0, [W14+7]
171:                   
172:                   static uint8_t u8EdgeTemperature = 0;
173:                   static uint8_t u8BoardTemperature = 0;
174:                   static uint8_t u8PreviousEdgeTemperature = 0;
175:                   static uint8_t u8PreviousBoardTemperature = 0;
176:               
177:                   int8_t BME680_rslt = BME680_OK;
00ACC4  EB4000     CLR.B W0
00ACC6  985740     MOV.B W0, [W14+20]
178:                   struct tm to_set_time;
179:                   bool exit_loop = false;
00ACC8  EB4000     CLR.B W0
00ACCA  984F00     MOV.B W0, [W14+8]
180:                   int tmpi1, tmpi2;
181:                   
182:                   /***********************
183:                   *   HARDWARE INIT:
184:                   ************************/
185:                   
186:                   OSCILLATOR_Initialize();
00ACCC  070487     RCALL OSCILLATOR_Initialize
187:                   
188:                   PIN_MANAGER_Initialize();     
00ACCE  070497     RCALL PIN_MANAGER_Initialize
189:                   
190:                   //TODO: Uncomment timers as needed - will increase power consumption
191:                   //TMR1_Initialize(); //1ms timer 
192:                   //TMR2_Initialize(); //100ms timer
193:                   TMR3_Initialize(); //1000ms timer - used for activity timeout
00ACD0  0705EB     RCALL TMR3_Initialize
194:                   //TMR4_Initialize(); //10ms timer
195:                   //TMR5_Initialize(); //100us timer 
196:                   
197:                   SPI1_Initialize(); //BME680, E-Paper, FRAM on this bus
00ACD2  07063C     RCALL SPI1_Initialize
198:                   
199:                   UART1_Initialize(); //Bluetooth  
00ACD4  0706B4     RCALL UART1_Initialize
200:                   //TODO: Init UART as needed. Will increase power consumption
201:                   //UART2_Initialize(); //LoRa Module
202:                   //UART3_Initialize(); //Digi WiFi   
203:                   
204:                   RTCC_Initialize(); //Real time clock  
00ACD6  070F1F     RCALL RTCC_Initialize
205:                   
206:                   INTERRUPT_Initialize();
00ACD8  070548     RCALL INTERRUPT_Initialize
207:               
208:                   ADC1_Initialize();
00ACDA  070816     RCALL ADC1_Initialize
209:                   
210:                   
211:                   //Reading in program memory location 0x2AF78 where the sqtp number is stored:
212:                   temp_long = ReadSerialNumber();
00ACDC  070858     RCALL ReadSerialNumber
00ACDE  980770     MOV W0, [W14+14]
00ACE0  980F01     MOV W1, [W14+16]
213:                   //TODO read nodeName from memory:
214:                   //24bits are programmed by SQTP into the program address 0x02AF78
215:                   //if there is no stored SQTP number, the program space will contain all 0xFF
216:                   if (temp_long < 0x00FFFFFF){ 
00ACE2  90017E     MOV [W14+14], W2
00ACE4  90098E     MOV [W14+16], W3
00ACE6  2FFFE0     MOV #0xFFFE, W0
00ACE8  200FF1     MOV #0xFF, W1
00ACEA  510F80     SUB W2, W0, [W15]
00ACEC  598F81     SUBB W3, W1, [W15]
00ACEE  3E0021     BRA GTU, .L2
217:                       strcpy((char*)tmpStr, (char*)MODEL_NAME);
00ACF0  47007B     ADD W14, #0x1B, W0
00ACF2  220E41     MOV #0x20E4, W1
00ACF4  07B0E8     RCALL _strcpy
218:                       strcat((char*)tmpStr,";");
00ACF6  47007B     ADD W14, #0x1B, W0
00ACF8  07B0EC     RCALL _strlen
00ACFA  4700FB     ADD W14, #0x1B, W1
00ACFC  408000     ADD W1, W0, W0
00ACFE  200022     MOV #0x2, W2
00AD00  2D5DC1     MOV #0xD5DC, W1
00AD02  07AFF6     RCALL _memcpy
219:                       //converting serial number to  string: 6 characters:
220:                       sprintf ( (char*) tmpStr2, "%.6lX", temp_long);
00AD04  200392     MOV #0x39, W2
00AD06  41010E     ADD W2, W14, W2
00AD08  90007E     MOV [W14+14], W0
00AD0A  90088E     MOV [W14+16], W1
00AD0C  BE9F80     MOV.D W0, [W15++]
00AD0E  2D5DE0     MOV #0xD5DE, W0
00AD10  781F80     MOV W0, [W15++]
00AD12  780002     MOV W2, W0
00AD14  07B40E     RCALL __sprintf_cdnopuxX, __sprintf_cdnopsuxX
00AD16  5787E6     SUB W15, #0x6, W15
221:                       strcpy((char*)SerialNum, (char*)tmpStr2);
00AD18  200390     MOV #0x39, W0
00AD1A  40000E     ADD W0, W14, W0
00AD1C  780080     MOV W0, W1
00AD1E  220F70     MOV #0x20F7, W0
00AD20  07B0D2     RCALL _strcpy
222:                       //combining node name and serial number: "NodeName;serialNumber"
223:                       strcat((char*)tmpStr,(char*)tmpStr2);
00AD22  200391     MOV #0x39, W1
00AD24  40808E     ADD W1, W14, W1
00AD26  47007B     ADD W14, #0x1B, W0
00AD28  07B0C4     RCALL _strcat
224:                       strcpy((char*)DeviceClass, (char*)tmpStr);
00AD2A  47007B     ADD W14, #0x1B, W0
00AD2C  780080     MOV W0, W1
00AD2E  218900     MOV #0x1890, W0
00AD30  07B0CA     RCALL _strcpy
225:                   }
226:                   //enabling UART1 for BLE
227:                   EnableUART1();
00AD32  A8E399     BSET 0x399, #7
228:               
229:                    //Power control: Enable power when needed
230:                   TurnOn_Bluetooth_Power();
00AD34  A8C6DA     BSET LATG, #6
00AD36  A866DA     BSET LATG, #3
231:                   TurnOn_FRAM_Power();
00AD38  A886B2     BSET LATE, #4
00AD3A  A846DA     BSET LATG, #2
232:                   TurnOn_BME680_Power();    
00AD3C  A8C6B2     BSET LATE, #6
00AD3E  A8868B     BSET 0x68B, #4
233:                   TurnOn_Display_Power();
00AD40  A806B2     BSET LATE, #0
00AD42  A8A6B2     BSET LATE, #5
00AD44  A84676     BSET LATB, #2
234:                   TurnOn_LMT70_Power();
00AD46  A8E747     BSET 0x747, #7
00AD48  A8E68B     BSET 0x68B, #7
235:                   
236:                   TurnOff_LoRa_Power();
00AD4A  A92677     BCLR 0x677, #1
00AD4C  A9A6C6     BCLR LATF, #5
00AD4E  A966B2     BCLR LATE, #3
237:                   TurnOff_WIFI_Power();
00AD50  A9E6C6     BCLR LATF, #7
00AD52  A966C6     BCLR LATF, #3
00AD54  A926B2     BCLR LATE, #1
238:                   
239:                   
240:                   //Bluetooth module init
241:                   if (RN4871_Init()) //If this is not true, the BLE module is dead
00AD56  070831     RCALL RN4871_Init
00AD58  E00400     CP0.B W0
00AD5A  320034     BRA Z, .L3
242:                   {
243:                       IsBluetoothUp = true;
00AD5C  B3C010     MOV.B #0x1, W0
00AD5E  985720     MOV.B W0, [W14+18]
244:                       //Setting up BLE services and characteristics:
245:                       RN4871_Clear_All_Services();
00AD60  070905     RCALL RN4871_Clear_All_Services
246:                       
247:                       //TODO: set up additional services (Max 3) + characteristics (Max 8 per service):        
248:                       RN4871_SetUp_Private_Service(LITInfoServiceUUID); 
00AD62  2213A0     MOV #0x213A, W0
00AD64  07090F     RCALL RN4871_SetUp_Private_Service
249:                       // for initial testing and debug
250:                       //RN4871_SetUp_Private_Characteristic(LITBETemperatureCharUUID,2,2); //read only, 2 bytes
251:                       //RN4871_SetUp_Private_Characteristic(LITBCTemperatureCharUUID,2,2); //ready only, 2 bytes
252:                       RN4871_SetUp_Private_Characteristic(LITACurrentSettingCharUUID, BLE_CH_READ, LITACurrentSettingU8Length );
00AD66  BFC8FE     MOV.B ___umoddi3, WREG
00AD68  784100     MOV.B W0, W2
00AD6A  B3C021     MOV.B #0x2, W1
00AD6C  221A70     MOV #0x21A7, W0
00AD6E  070927     RCALL RN4871_SetUp_Private_Characteristic
253:                       RN4871_SetUp_Private_Characteristic(LITATimeSynchronizeCharUUID, BLE_CH_WRITE, LITATimeSynchronizeU8Length );
00AD70  BFC8FF     MOV.B 0x8FF, WREG
00AD72  784100     MOV.B W0, W2
00AD74  B3C081     MOV.B #0x8, W1
00AD76  221CD0     MOV #0x21CD, W0
00AD78  070922     RCALL RN4871_SetUp_Private_Characteristic
254:                       RN4871_SetUp_Private_Characteristic(LITAUserParametersCharUUID, BLE_CH_WRITE, LITAUserParametersU8Length );
00AD7A  BFC900     MOV.B 0x900, WREG
00AD7C  784100     MOV.B W0, W2
00AD7E  B3C081     MOV.B #0x8, W1
00AD80  221F30     MOV #0x21F3, W0
00AD82  07091D     RCALL RN4871_SetUp_Private_Characteristic
255:                       RN4871_SetUp_Private_Characteristic(LITASchedulesCharUUID, BLE_CH_WRITE, LITASchedulesU8Length );
00AD84  BFC901     MOV.B 0x901, WREG
00AD86  784100     MOV.B W0, W2
00AD88  B3C081     MOV.B #0x8, W1
00AD8A  222190     MOV #0x2219, W0
00AD8C  070918     RCALL RN4871_SetUp_Private_Characteristic
256:                       RN4871_SetUp_Private_Characteristic(LITAAcknowledgementUUID, BLE_CH_READ | BLE_CH_WRITE, LITAAcknowledgementLength );
00AD8E  BFC902     MOV.B 0x902, WREG
00AD90  784100     MOV.B W0, W2
00AD92  B3C0A1     MOV.B #0xA, W1
00AD94  2223F0     MOV #0x223F, W0
00AD96  070913     RCALL RN4871_SetUp_Private_Characteristic
257:                       RN4871_SetUp_Private_Characteristic(LITATemperatureBufferUUID, BLE_CH_READ, LITATemperatureBufferLength );
00AD98  BFC903     MOV.B 0x903, WREG
00AD9A  784100     MOV.B W0, W2
00AD9C  B3C021     MOV.B #0x2, W1
00AD9E  222650     MOV #0x2265, W0
00ADA0  07090E     RCALL RN4871_SetUp_Private_Characteristic
258:                       RN4871_SetUp_Private_Characteristic(LITARuntimeBufferUUID, BLE_CH_READ, LITARuntimeBufferLength );
00ADA2  BFC904     MOV.B 0x904, WREG
00ADA4  784100     MOV.B W0, W2
00ADA6  B3C021     MOV.B #0x2, W1
00ADA8  2228B0     MOV #0x228B, W0
00ADAA  070909     RCALL RN4871_SetUp_Private_Characteristic
259:                       RN4871_SetUp_Private_Characteristic(LITASetpointBufferUUID, BLE_CH_READ, LITASetpointBufferLength );
00ADAC  BFC905     MOV.B 0x905, WREG
00ADAE  784100     MOV.B W0, W2
00ADB0  B3C021     MOV.B #0x2, W1
00ADB2  222B10     MOV #0x22B1, W0
00ADB4  070904     RCALL RN4871_SetUp_Private_Characteristic
260:               
261:                               
262:                       RN4871_Reboot(); //for the new GATT profiles to take effect
00ADB6  070A2F     RCALL RN4871_Reboot
263:                    
264:                       __delay_ms(750); // delay for chip reset
00ADB8  21B000     MOV #0x1B00, W0
00ADBA  200B71     MOV #0xB7, W1
00ADBC  07110A     RCALL ___delay32, .Letext0, .LFE18
265:                       //RN4871_Get_Handles_Characteristics(LITInfoServiceUUID);
266:                       //RN4871_Get_Handles_Characteristics(LITInfoServiceUUID);
267:                       //setting up the interrupt for BLE connection:
268:                       BLE_Connected = false;
00ADBE  EF690B     CLR.B BLE_Connected
269:                       BLEStatus_InterruptFlagclear();
00ADC0  A9C08E     BCLR IFS3, #6
270:                       BLEStatus_InterruptEnable();
00ADC2  A8C09E     BSET IEC3, #6
271:                   }
272:                   else
273:                   {
274:                       //TODO: display error on display?
275:                   }
276:                   
277:                   
278:                   if (P24vacGOOD_GetValue()) //Will be high if 24VAC power is present
00ADC4  8033A0     MOV PORTB, W0
00ADC6  600068     AND W0, #0x8, W0
00ADC8  E00000     CP0 W0
00ADCA  320002     BRA Z, .L4
279:                   {
280:                       PWR_24VAC_ON = true;
00ADCC  B3C010     MOV.B #0x1, W0
00ADCE  B7E8AE     MOV.B WREG, PWR_24VAC_ON
281:                   }
282:               
283:               
284:                   tmpu8 = 0;
00ADD0  EB4000     CLR.B W0
00ADD2  984720     MOV.B W0, [W14+2]
285:                   // discard first five readings on power up
286:                   while (tmpu8 < 5)
00ADD4  370009     BRA .L5
00ADE8  90402E     MOV.B [W14+2], W0
00ADEA  504FE4     SUB.B W0, #0x4, [W15]
00ADEC  36FFF4     BRA LEU, .L6
287:                   {
288:                       u8EdgeTemperature = ReadBoardTemperature(BoardEdge);
00ADD6  B3C0A0     MOV.B #0xA, W0
00ADD8  07F3AE     RCALL ReadBoardTemperature
00ADDA  B7E8E1     MOV.B WREG, u8EdgeTemperature
289:                       //u8BoardTemperature = ReadBoardTemperature(BoardMiddle);
290:                       __delay_ms(1000);
00ADDC  224000     MOV #0x2400, W0
00ADDE  200F41     MOV #0xF4, W1
00ADE0  0710F8     RCALL ___delay32, .Letext0, .LFE18
291:                       tmpu8++;
00ADE2  90402E     MOV.B [W14+2], W0
00ADE4  E84000     INC.B W0, W0
00ADE6  984720     MOV.B W0, [W14+2]
292:                   }
293:                   //u8BoardTemperature = ReadBoardTemperature(BoardMiddle);
294:                   u8PreviousEdgeTemperature = u8EdgeTemperature;
00ADEE  BFC8E1     MOV.B u8EdgeTemperature, WREG
00ADF0  B7E8E2     MOV.B WREG, u8PreviousEdgeTemperature
295:                   //u8PreviousBoardTemperature = u8BoardTemperature;
296:                   
297:                   battVoltage = ReadBatteryVoltage(); //low battery below 2400
00ADF2  07F3FA     RCALL ReadBatteryVoltage
00ADF4  780F00     MOV W0, [W14]
298:                   
299:                   EnableSPI1(); //for Display, BME and Fram
00ADF6  A8E3F5     BSET 0x3F5, #7
300:                   
301:                   //Initializing BME680:
302:                   ConfigureBME680();
00ADF8  07F30E     RCALL ConfigureBME680
303:                   tmpu8 = FRAMInitialized();
00ADFA  07E003     RCALL FRAMInitialized
00ADFC  984720     MOV.B W0, [W14+2]
304:                   if (tmpu8 == 0)
00ADFE  90402E     MOV.B [W14+2], W0
00AE00  E00400     CP0.B W0
00AE02  3A0006     BRA NZ, .L7
305:                   {
306:                       // intialize FRAM buffers, and other relevant locations for buffers and schedules
307:                       ParametersInit();
00AE04  07EA3B     RCALL ParametersInit
308:                       TemperatureBufferInit();
00AE06  07E321     RCALL TemperatureBufferInit
309:                       RuntimeBufferInit();
00AE08  07E58B     RCALL RuntimeBufferInit
310:                       SetpointBufferInit();
00AE0A  07E7E9     RCALL SetpointBufferInit
311:                       ScheduleInit();
00AE0C  07E065     RCALL ScheduleInit
312:                       WriteBuffersInitialized();
00AE0E  07E304     RCALL WriteBuffersInitialized
313:                   }
314:                   Application_Initialize();
00AE10  07F587     RCALL Application_Initialize
315:                   Heat_off();
00AE12  07F5D4     RCALL Heat_off
316:                   Cool_off();
00AE14  07F5E3     RCALL Cool_off
317:                   Fan_off();
00AE16  07F5F2     RCALL Fan_off
318:                   ReadParametersFromFRAM();
00AE18  07F56E     RCALL ReadParametersFromFRAM
319:                   //Initializing Display:
320:                   epaper_init();
00AE1A  07EAC7     RCALL epaper_init
321:                   epaper_draw_screen(u8CoolSetpoint,u8HeatSetpoint);
00AE1C  208B81     MOV #0x8B8, W1
00AE1E  784091     MOV.B [W1], W1
00AE20  BFC8B5     MOV.B u8CoolSetpoint, WREG
00AE22  07F176     RCALL epaper_draw_screen
322:                   u8CurrentTemperature = Temperature_average(u8EdgeTemperature);
00AE24  BFC8E1     MOV.B u8EdgeTemperature, WREG
00AE26  07F5FA     RCALL Temperature_average
00AE28  B7E8C0     MOV.B WREG, u8CurrentTemperature
323:                   u8PrevCurrentTemperature = u8CurrentTemperature;
00AE2A  BFC8C0     MOV.B u8CurrentTemperature, WREG
00AE2C  B7E8C1     MOV.B WREG, u8PrevCurrentTemperature
324:                   drawTemperature(u8CurrentTemperature);
00AE2E  BFC8C0     MOV.B u8CurrentTemperature, WREG
00AE30  07EFE3     RCALL drawTemperature
325:                   
326:               #ifdef testble
327:                   PopulateDebugBuffers(dbgTemperatureBuffer, dbgRuntimeBuffer, dbgSetpointBuffer, 200);
00AE32  200C83     MOV #0xC8, W3
00AE34  21B472     MOV #0x1B47, W2
00AE36  21A7F1     MOV #0x1A7F, W1
00AE38  219B70     MOV #0x19B7, W0
00AE3A  07F7BE     RCALL PopulateDebugBuffers
328:               #endif
329:                   
330:               //    __delay_ms(5000);
331:               //    tmpu8 = u8EdgeTemperature+5;
332:               //    clear_indicator(temperature_min_x, temperature_min_y, temperature_max_x, temperature_max_y);
333:               //    drawTemperature(tmpu8);
334:               //    __delay_ms(5000);
335:               //    clear_indicator(temperature_min_x, temperature_min_y, temperature_max_x, temperature_max_y);
336:               //    drawTemperature(u8EdgeTemperature);
337:               //    __delay_ms(5000);
338:               //    //epaper_draw_heatcool(0); // draws cool
339:               //    //epaper_draw_heatcool(1); // draws heat
340:               //    if (u8ActionOnScreen == 1)
341:               //    {
342:               //        epaper_draw_heatcool(DISPLAY_ACTION_NONE); // clears space
343:               //    }
344:               //    u8BatteryOnScreen = 1;
345:               //    epaper_draw_battery(1);
346:               //    __delay_ms(7000);
347:               //    if (u8BatteryOnScreen == 1) 
348:               //    {
349:               //        u8BatteryOnScreen = 0;
350:               //        epaper_draw_battery(0);
351:               //    }
352:               //    
353:               //    u8TimerOnScreen = 1;
354:               //    epaper_draw_timer(1);
355:               //    __delay_ms(7000);
356:               //    if (u8TimerOnScreen == 1)
357:               //    {
358:               //        u8TimerOnScreen = 0;
359:               //        epaper_draw_timer(0);
360:               //    }
361:                   
362:                   
363:                   
364:                   epaper_off();
00AE3C  07EB13     RCALL epaper_off
365:               
366:                   RTCC_AlarmEnable(3);
00AE3E  B3C030     MOV.B #0x3, W0
00AE40  071082     RCALL RTCC_AlarmEnable
367:                   
368:                   //going to sleep now:
369:                   ClrWdt();
00AE42  FE6000     CLRWDT
370:                   FRAMSleep(0);
00AE44  EB4000     CLR.B W0
00AE46  070B9C     RCALL FRAMSleep
371:                   RN4871_SetLowPowerMode();
00AE48  07098A     RCALL RN4871_SetLowPowerMode
372:                   
373:                   // TEST FRAM
374:                   // write to FRAM
375:                   //FRAMWake(0);
376:                   //u16PartialScreenUpdateCount = 0x4bd9;
377:                   //WritePartialScreenUpdateCount();
378:                   //FRAMSleep(0);
379:                   // power off comment out the previous 4 lines
380:                   // read from FRAM
381:                   //FRAMWake(0);
382:                   //ReadPartialScreenUpdateCount();
383:                   //FRAMSleep(0);
384:                   
385:                   
386:                   //DEBUG:
387:               //    while (1)
388:               //    {
389:               //        u8EdgeTemperature = ReadBoardTemperature(BoardEdge);
390:               //    }
391:                   
392:               //    while (1)
393:               //    {
394:               //        bme680_set_sensor_mode(&gas_sensor); //to force sensor to take readings
395:               //        BME680_delay_ms(meas_period); //delay until readings are valid
396:               //        /* temperature = data.temperature/100 f
397:               //         * pressure = data.pressure/100 hPa
398:               //         * humidity = data.humidity/1000 %rH
399:               //        */
400:               //        BME680_rslt = bme680_get_sensor_data(&data, &gas_sensor);
401:               //        __delay_ms(1000);
402:               //    }
403:                   /*************************************************************************
404:                                           APPLICATION LOOP
405:                    ************************************************************************/
406:                   while(1)
407:                   {
408:                       /**************************************************
409:                        *              SLEEP STATE
410:                        *  Only moves out of this state when a phone is connected
411:                       ***************************************************/
412:                       while (u8CurrentState == STATE_SLEEP)
00AE4A  370001     BRA .L8
00AE4E  BFC8B0     MOV.B u8CurrentState, WREG
00AE50  E00400     CP0.B W0
00AE52  32FFFC     BRA Z, .L9
00B5C0  37FC46     BRA .L8
413:                       {
414:                           
415:                           Sleep();
00AE4C  FE4000     PWRSAV #0
416:                           //Wake up from sleep can happen with any of the 
417:                           //interrupts : either button presses or BLE connection            
418:                       }
419:                       
420:                       /**************************************************
421:                        *              CONNECTED STATE
422:                        *  In this state when phone is connected
423:                        *  Goes back to sleep when phone is disconnected
424:                       ***************************************************/
425:                       while (u8CurrentState == STATE_CONNECT)
00AE54  3701E0     BRA .L10
00B216  BFC8B0     MOV.B u8CurrentState, WREG
00B218  504FE1     SUB.B W0, #0x1, [W15]
00B21A  32FE1D     BRA Z, .L38
426:                       {
427:                           ClrWdt();
00AE56  FE6000     CLRWDT
428:                           RTCC_AlarmDisable();
00AE58  071091     RCALL RTCC_AlarmDisable
429:                  
430:                           // initial code for debug
431:               //            u8EdgeTemperature = ReadBoardTemperature(BoardEdge);
432:               //            u8BoardTemperature = ReadBoardTemperature(BoardMiddle);     
433:               //            
434:               //            battVoltage = ReadBatteryVoltage(); //low battery below 2400
435:               //           
436:               //            //TODO: Read BME temperature
437:               //            //updating the temperature characteristic only if different from before:
438:               //            if (u8EdgeTemperature != u8PreviousEdgeTemperature)
439:               //            {
440:               //                //TODO : use BME temperature when available
441:               //                RN4871_Set_Characteristic_Value_Word(LITBETemperatureCharHandle,u8EdgeTemperature);
442:               //                u8PreviousEdgeTemperature = u8EdgeTemperature;
443:               //                //updating display with current temperature
444:               //                //epaper_on();
445:               //                //drawTemperature(u8EdgeTemperature);
446:               //                //epaper_off();
447:               //            }
448:               //            if (u8BoardTemperature != u8PreviousBoardTemperature)
449:               //            {
450:               //                RN4871_Set_Characteristic_Value_Word(LITBCTemperatureCharHandle,u8BoardTemperature);
451:               //                u8PreviousBoardTemperature = u8BoardTemperature;
452:               //            }
453:               
454:                           u8arrBLEChRx[0] = u8CurrentTemperature;
00AE5A  208C01     MOV #0x8C0, W1
00AE5C  784091     MOV.B [W1], W1
00AE5E  21CBC0     MOV #0x1CBC, W0
00AE60  784801     MOV.B W1, [W0]
455:                           u8arrBLEChRx[1] = u8CurrentThermostatAction;
00AE62  208C21     MOV #0x8C2, W1
00AE64  784091     MOV.B [W1], W1
00AE66  21CBD0     MOV #0x1CBD, W0
00AE68  784801     MOV.B W1, [W0]
456:                           u8arrBLEChRx[2] = u8RelativeHumidity;
00AE6A  208D41     MOV #0x8D4, W1
00AE6C  784091     MOV.B [W1], W1
00AE6E  21CBE0     MOV #0x1CBE, W0
00AE70  784801     MOV.B W1, [W0]
457:                           u8arrBLEChRx[3] = u8IndoorAirQuality;
00AE72  208D51     MOV #0x8D5, W1
00AE74  784091     MOV.B [W1], W1
00AE76  21CBF0     MOV #0x1CBF, W0
00AE78  784801     MOV.B W1, [W0]
458:                           u8arrBLEChRx[4] = u8Schedule;
00AE7A  208D61     MOV #0x8D6, W1
00AE7C  784091     MOV.B [W1], W1
00AE7E  21CC00     MOV #0x1CC0, W0
00AE80  784801     MOV.B W1, [W0]
459:                           if (battVoltage < 2400)
00AE82  2095F0     MOV #0x95F, W0
00AE84  78009E     MOV [W14], W1
00AE86  508F80     SUB W1, W0, [W15]
00AE88  3E0004     BRA GTU, .L11
460:                           {
461:                               u8arrBLEChRx[5] = 0x01;
00AE8A  21CC10     MOV #0x1CC1, W0
00AE8C  B3C011     MOV.B #0x1, W1
00AE8E  784801     MOV.B W1, [W0]
00AE90  370003     BRA .L12
462:                           }
463:                           else 
464:                           {
465:                               u8arrBLEChRx[5] = 0x00;
00AE92  21CC10     MOV #0x1CC1, W0
00AE94  EB4080     CLR.B W1
00AE96  784801     MOV.B W1, [W0]
466:                           }
467:                           u8arrBLEChRx[6] = u8ApplicationState;
00AE98  208B41     MOV #0x8B4, W1
00AE9A  784091     MOV.B [W1], W1
00AE9C  21CC20     MOV #0x1CC2, W0
00AE9E  784801     MOV.B W1, [W0]
468:                           RN4871_Write_Characteristic_Value(LITACurrentSettingCharHandle, u8arrBLEChRx, LITACurrentSettingU8Length);
00AEA0  BFC8FE     MOV.B ___umoddi3, WREG
00AEA2  FB8000     ZE W0, W0
00AEA4  780100     MOV W0, W2
00AEA6  21CBC1     MOV #0x1CBC, W1
00AEA8  221C80     MOV #0x21C8, W0
00AEAA  0709F3     RCALL RN4871_Write_Characteristic_Value
469:                           
470:               #ifdef testble  
471:                           __delay_ms(250);
00AEAC  209000     MOV #0x900, W0
00AEAE  2003D1     MOV #0x3D, W1
00AEB0  071090     RCALL ___delay32, .Letext0, .LFE18
472:                           tmpu8 = RN4871_Read_Characteristic_Value(LITATimeSynchronizeCharHandle, u8arrBLEChRx, LITATimeSynchronizeU8Length);
00AEB2  BFC8FF     MOV.B 0x8FF, WREG
00AEB4  FB8000     ZE W0, W0
00AEB6  780100     MOV W0, W2
00AEB8  21CBC1     MOV #0x1CBC, W1
00AEBA  221EE0     MOV #0x21EE, W0
00AEBC  070A37     RCALL RN4871_Read_Characteristic_Value
00AEBE  984720     MOV.B W0, [W14+2]
473:                           if (tmpu8 == 1) {
00AEC0  90402E     MOV.B [W14+2], W0
00AEC2  504FE1     SUB.B W0, #0x1, [W15]
00AEC4  3A0006     BRA NZ, .L13
474:                               memcpy(dbgTimeSyncBLE, u8arrBLEChRx, LITATimeSynchronizeU8Length);
00AEC6  BFC8FF     MOV.B 0x8FF, WREG
00AEC8  FB8000     ZE W0, W0
00AECA  780100     MOV W0, W2
00AECC  21CBC1     MOV #0x1CBC, W1
00AECE  218AA0     MOV #0x18AA, W0
00AED0  07AF0F     RCALL _memcpy
475:                           }
476:                           __delay_ms(250);
00AED2  209000     MOV #0x900, W0
00AED4  2003D1     MOV #0x3D, W1
00AED6  07107D     RCALL ___delay32, .Letext0, .LFE18
477:                           tmpu8 = RN4871_Read_Characteristic_Value(LITAUserParametersCharHandle, u8arrBLEChRx, LITAUserParametersU8Length);
00AED8  BFC900     MOV.B 0x900, WREG
00AEDA  FB8000     ZE W0, W0
00AEDC  780100     MOV W0, W2
00AEDE  21CBC1     MOV #0x1CBC, W1
00AEE0  222140     MOV #0x2214, W0
00AEE2  070A24     RCALL RN4871_Read_Characteristic_Value
00AEE4  984720     MOV.B W0, [W14+2]
478:                           if (tmpu8 == 1) 
00AEE6  90402E     MOV.B [W14+2], W0
00AEE8  504FE1     SUB.B W0, #0x1, [W15]
00AEEA  3A0006     BRA NZ, .L14
479:                           {
480:                               memcpy(dbgUserParamBLE, u8arrBLEChRx, LITAUserParametersU8Length);
00AEEC  BFC900     MOV.B 0x900, WREG
00AEEE  FB8000     ZE W0, W0
00AEF0  780100     MOV W0, W2
00AEF2  21CBC1     MOV #0x1CBC, W1
00AEF4  218B10     MOV #0x18B1, W0
00AEF6  07AEFC     RCALL _memcpy
481:                           }            
482:                           __delay_ms(250);
00AEF8  209000     MOV #0x900, W0
00AEFA  2003D1     MOV #0x3D, W1
00AEFC  07106A     RCALL ___delay32, .Letext0, .LFE18
483:                           exit_loop = false;
00AEFE  EB4000     CLR.B W0
00AF00  984F00     MOV.B W0, [W14+8]
484:                           while (!exit_loop)
00AF02  3700C4     BRA .L15
00B08C  90480E     MOV.B [W14+8], W0
00B08E  A20400     BTG.B W0, #0
00B090  E00400     CP0.B W0
00B092  3AFF38     BRA NZ, .L23
485:                           {
486:                               tmpu8_count = 0;
00AF04  EB4000     CLR.B W0
00AF06  984730     MOV.B W0, [W14+3]
487:                               tmpu8 = RN4871_Read_Characteristic_Value(LITASchedulesCharHandle, u8arrBLEChRx, 20);
00AF08  200142     MOV #0x14, W2
00AF0A  21CBC1     MOV #0x1CBC, W1
00AF0C  2223A0     MOV #0x223A, W0
00AF0E  070A0E     RCALL RN4871_Read_Characteristic_Value
00AF10  984720     MOV.B W0, [W14+2]
488:                               if (tmpu8 == 1)
00AF12  90402E     MOV.B [W14+2], W0
00AF14  504FE1     SUB.B W0, #0x1, [W15]
00AF16  3A00BA     BRA NZ, .L15
489:                               {
490:                                   tmpu8_idx = 0;
00AF18  EB4000     CLR.B W0
00AF1A  984740     MOV.B W0, [W14+4]
491:                                   while (tmpu8_idx < LITASchedulesU8Length) 
00AF1C  3700A9     BRA .L16
00B070  BFC901     MOV.B 0x901, WREG
00B072  9040CE     MOV.B [W14+4], W1
00B074  50CF80     SUB.B W1, W0, [W15]
00B076  39FF53     BRA NC, .L22
492:                                   {
493:                                       if (    (u8arrBLEChRx[tmpu8_idx] <= 0x64) || 
00AF1E  90404E     MOV.B [W14+4], W0
00AF20  FB8000     ZE W0, W0
00AF22  21CBC1     MOV #0x1CBC, W1
00AF24  7840E1     MOV.B [W1+W0], W1
00AF26  B3C640     MOV.B #0x64, W0
00AF28  50CF80     SUB.B W1, W0, [W15]
00AF2A  360012     BRA LEU, .L17
00AF34  504FEF     SUB.B W0, #0xF, [W15]
00AF36  32000C     BRA Z, .L17
494:                                               (u8arrBLEChRx[tmpu8_idx] == 0x0F) || 
00AF2C  90404E     MOV.B [W14+4], W0
00AF2E  FB8000     ZE W0, W0
00AF30  21CBC1     MOV #0x1CBC, W1
00AF32  784061     MOV.B [W1+W0], W0
00AF40  404FE1     ADD.B W0, #0x1, [W15]
00AF42  320006     BRA Z, .L17
495:                                               (u8arrBLEChRx[tmpu8_idx] == 0xFF) || 
00AF38  90404E     MOV.B [W14+4], W0
00AF3A  FB8000     ZE W0, W0
00AF3C  21CBC1     MOV #0x1CBC, W1
00AF3E  784061     MOV.B [W1+W0], W0
00AF4C  404FE1     ADD.B W0, #0x1, [W15]
00AF4E  3A008D     BRA NZ, .L18
496:                                               (u8arrBLEChRx[tmpu8_idx] == 0xFF) 
00AF44  90404E     MOV.B [W14+4], W0
00AF46  FB8000     ZE W0, W0
00AF48  21CBC1     MOV #0x1CBC, W1
00AF4A  784061     MOV.B [W1+W0], W0
497:                                           )
498:                                       {
499:                                           if (u8arrBLEChRx[tmpu8_idx] == 0x0F)
00AF50  90404E     MOV.B [W14+4], W0
00AF52  FB8000     ZE W0, W0
00AF54  21CBC1     MOV #0x1CBC, W1
00AF56  784061     MOV.B [W1+W0], W0
00AF58  504FEF     SUB.B W0, #0xF, [W15]
00AF5A  3A001D     BRA NZ, .L19
500:                                           {
501:                                               dbgSchedulesBLE[145] = u8arrBLEChRx[tmpu8_idx+1];
00AF5C  90404E     MOV.B [W14+4], W0
00AF5E  FB8000     ZE W0, W0
00AF60  E80000     INC W0, W0
00AF62  21CBC1     MOV #0x1CBC, W1
00AF64  7840E1     MOV.B [W1+W0], W1
00AF66  2194E0     MOV #0x194E, W0
00AF68  784801     MOV.B W1, [W0]
502:                                               dbgSchedulesBLE[146] = u8arrBLEChRx[tmpu8_idx+2];
00AF6A  90404E     MOV.B [W14+4], W0
00AF6C  FB8000     ZE W0, W0
00AF6E  E88000     INC2 W0, W0
00AF70  21CBC1     MOV #0x1CBC, W1
00AF72  7840E1     MOV.B [W1+W0], W1
00AF74  2194F0     MOV #0x194F, W0
00AF76  784801     MOV.B W1, [W0]
503:                                               dbgSchedulesBLE[147] = u8arrBLEChRx[tmpu8_idx+3];
00AF78  90404E     MOV.B [W14+4], W0
00AF7A  FB8000     ZE W0, W0
00AF7C  400063     ADD W0, #0x3, W0
00AF7E  21CBC1     MOV #0x1CBC, W1
00AF80  7840E1     MOV.B [W1+W0], W1
00AF82  219500     MOV #0x1950, W0
00AF84  784801     MOV.B W1, [W0]
504:                                               dbgSchedulesBLE[148] = u8arrBLEChRx[tmpu8_idx+4];
00AF86  90404E     MOV.B [W14+4], W0
00AF88  FB8000     ZE W0, W0
00AF8A  400064     ADD W0, #0x4, W0
00AF8C  21CBC1     MOV #0x1CBC, W1
00AF8E  7840E1     MOV.B [W1+W0], W1
00AF90  219510     MOV #0x1951, W0
00AF92  784801     MOV.B W1, [W0]
00AF94  37006A     BRA .L18
505:                                               
506:                                           }
507:                                           else if (u8arrBLEChRx[tmpu8_idx] == 0xF0)
00AF96  90404E     MOV.B [W14+4], W0
00AF98  FB8000     ZE W0, W0
00AF9A  21CBC1     MOV #0x1CBC, W1
00AF9C  784061     MOV.B [W1+W0], W0
00AF9E  404FF0     ADD.B W0, #0x10, [W15]
00AFA0  3A001D     BRA NZ, .L20
508:                                           {
509:                                               dbgSchedulesBLE[149] = u8arrBLEChRx[tmpu8_idx+1];
00AFA2  90404E     MOV.B [W14+4], W0
00AFA4  FB8000     ZE W0, W0
00AFA6  E80000     INC W0, W0
00AFA8  21CBC1     MOV #0x1CBC, W1
00AFAA  7840E1     MOV.B [W1+W0], W1
00AFAC  219520     MOV #0x1952, W0
00AFAE  784801     MOV.B W1, [W0]
510:                                               dbgSchedulesBLE[150] = u8arrBLEChRx[tmpu8_idx+2];
00AFB0  90404E     MOV.B [W14+4], W0
00AFB2  FB8000     ZE W0, W0
00AFB4  E88000     INC2 W0, W0
00AFB6  21CBC1     MOV #0x1CBC, W1
00AFB8  7840E1     MOV.B [W1+W0], W1
00AFBA  219530     MOV #0x1953, W0
00AFBC  784801     MOV.B W1, [W0]
511:                                               dbgSchedulesBLE[151] = u8arrBLEChRx[tmpu8_idx+3];
00AFBE  90404E     MOV.B [W14+4], W0
00AFC0  FB8000     ZE W0, W0
00AFC2  400063     ADD W0, #0x3, W0
00AFC4  21CBC1     MOV #0x1CBC, W1
00AFC6  7840E1     MOV.B [W1+W0], W1
00AFC8  219540     MOV #0x1954, W0
00AFCA  784801     MOV.B W1, [W0]
512:                                               dbgSchedulesBLE[152] = u8arrBLEChRx[tmpu8_idx+4];
00AFCC  90404E     MOV.B [W14+4], W0
00AFCE  FB8000     ZE W0, W0
00AFD0  400064     ADD W0, #0x4, W0
00AFD2  21CBC1     MOV #0x1CBC, W1
00AFD4  7840E1     MOV.B [W1+W0], W1
00AFD6  219550     MOV #0x1955, W0
00AFD8  784801     MOV.B W1, [W0]
00AFDA  370047     BRA .L18
513:                                           }
514:                                           else if (u8arrBLEChRx[tmpu8_idx] == 0xFF)
00AFDC  90404E     MOV.B [W14+4], W0
00AFDE  FB8000     ZE W0, W0
00AFE0  21CBC1     MOV #0x1CBC, W1
00AFE2  784061     MOV.B [W1+W0], W0
00AFE4  404FE1     ADD.B W0, #0x1, [W15]
00AFE6  3A0003     BRA NZ, .L21
515:                                           {
516:                                               exit_loop = true;
00AFE8  B3C010     MOV.B #0x1, W0
00AFEA  984F00     MOV.B W0, [W14+8]
00AFEC  37003E     BRA .L18
517:                                           }
518:                                           else
519:                                           {
520:                                               // valid schedule received
521:                                               tmpu8_dow = (u8arrBLEChRx[tmpu8_idx] & 0xF0) >> 4;
00AFEE  90404E     MOV.B [W14+4], W0
00AFF0  FB8000     ZE W0, W0
00AFF2  21CBC1     MOV #0x1CBC, W1
00AFF4  784061     MOV.B [W1+W0], W0
00AFF6  FB8000     ZE W0, W0
00AFF8  DE0044     LSR W0, #4, W0
00AFFA  985750     MOV.B W0, [W14+21]
522:                                               tmpu8_num = u8arrBLEChRx[tmpu8_idx] & 0x0F;
00AFFC  90404E     MOV.B [W14+4], W0
00AFFE  FB8000     ZE W0, W0
00B000  21CBC1     MOV #0x1CBC, W1
00B002  784061     MOV.B [W1+W0], W0
00B004  60406F     AND.B W0, #0xF, W0
00B006  985760     MOV.B W0, [W14+22]
523:               								tmpi1 = 5 + 20*tmpu8_dow + tmpu8_num * 4;
00B008  90505E     MOV.B [W14+21], W0
00B00A  FB8000     ZE W0, W0
00B00C  B90065     MUL.SU W0, #5, W0
00B00E  780080     MOV W0, W1
00B010  90506E     MOV.B [W14+22], W0
00B012  FB8000     ZE W0, W0
00B014  408000     ADD W1, W0, W0
00B016  DD0042     SL W0, #2, W0
00B018  400065     ADD W0, #0x5, W0
00B01A  980F40     MOV W0, [W14+24]
524:               								dbgSchedulesBLE[tmpi1] = u8arrBLEChRx[tmpu8_idx+1];
00B01C  90404E     MOV.B [W14+4], W0
00B01E  FB8000     ZE W0, W0
00B020  E80000     INC W0, W0
00B022  21CBC1     MOV #0x1CBC, W1
00B024  7840E1     MOV.B [W1+W0], W1
00B026  218BD2     MOV #0x18BD, W2
00B028  90084E     MOV [W14+24], W0
00B02A  410000     ADD W2, W0, W0
00B02C  784801     MOV.B W1, [W0]
525:               								dbgSchedulesBLE[tmpi1+1] = u8arrBLEChRx[tmpu8_idx+2];
00B02E  90084E     MOV [W14+24], W0
00B030  E80000     INC W0, W0
00B032  9040CE     MOV.B [W14+4], W1
00B034  FB8081     ZE W1, W1
00B036  E88081     INC2 W1, W1
00B038  21CBC2     MOV #0x1CBC, W2
00B03A  78C162     MOV.B [W2+W1], W2
00B03C  218BD1     MOV #0x18BD, W1
00B03E  787082     MOV.B W2, [W1+W0]
526:               								dbgSchedulesBLE[tmpi1+2] = u8arrBLEChRx[tmpu8_idx+3];
00B040  90084E     MOV [W14+24], W0
00B042  E88000     INC2 W0, W0
00B044  9040CE     MOV.B [W14+4], W1
00B046  FB8081     ZE W1, W1
00B048  4080E3     ADD W1, #0x3, W1
00B04A  21CBC2     MOV #0x1CBC, W2
00B04C  78C162     MOV.B [W2+W1], W2
00B04E  218BD1     MOV #0x18BD, W1
00B050  787082     MOV.B W2, [W1+W0]
527:               								dbgSchedulesBLE[tmpi1+3] = u8arrBLEChRx[tmpu8_idx+4];
00B052  90084E     MOV [W14+24], W0
00B054  400063     ADD W0, #0x3, W0
00B056  9040CE     MOV.B [W14+4], W1
00B058  FB8081     ZE W1, W1
00B05A  4080E4     ADD W1, #0x4, W1
00B05C  21CBC2     MOV #0x1CBC, W2
00B05E  78C162     MOV.B [W2+W1], W2
00B060  218BD1     MOV #0x18BD, W1
00B062  787082     MOV.B W2, [W1+W0]
528:                                               tmpu8_count += 1;
00B064  90403E     MOV.B [W14+3], W0
00B066  E84000     INC.B W0, W0
00B068  984730     MOV.B W0, [W14+3]
529:                                           }
530:                                       }
531:                                       tmpu8_idx += 5;
00B06A  90404E     MOV.B [W14+4], W0
00B06C  404065     ADD.B W0, #0x5, W0
00B06E  984740     MOV.B W0, [W14+4]
532:                                   }
533:                                   u8arrBLEChTx[0] = tmpu8_count;
00B078  21CD00     MOV #0x1CD0, W0
00B07A  9040BE     MOV.B [W14+3], W1
00B07C  784801     MOV.B W1, [W0]
534:                                   RN4871_Write_Characteristic_Value(LITAAcknowledgementHandle, u8arrBLEChTx, 1);
00B07E  200012     MOV #0x1, W2
00B080  21CD01     MOV #0x1CD0, W1
00B082  222600     MOV #0x2260, W0
00B084  070906     RCALL RN4871_Write_Characteristic_Value
535:                                   __delay_ms(250);
00B086  209000     MOV #0x900, W0
00B088  2003D1     MOV #0x3D, W1
00B08A  070FA3     RCALL ___delay32, .Letext0, .LFE18
536:                               }
537:                           }
538:                           
539:                           exit_loop = false;
00B094  EB4000     CLR.B W0
00B096  984F00     MOV.B W0, [W14+8]
540:               			tmpi2 = 0; 
00B098  EB0000     CLR W0
00B09A  980750     MOV W0, [W14+10]
541:                           while (!exit_loop)
00B09C  370032     BRA .L24
00B102  90480E     MOV.B [W14+8], W0
00B104  A20400     BTG.B W0, #0
00B106  E00400     CP0.B W0
00B108  3AFFCA     BRA NZ, .L27
542:                           {
543:                               // assuming that LITATemperatureBufferLength is 20
544:                               // and size of u8arrChTx is also 20
545:                               tmpi1 = (BLE_CHARACTERISTIC_SIZE - 6) / 4;
00B09E  200030     MOV #0x3, W0
00B0A0  980F40     MOV W0, [W14+24]
546:                               if (tmpi2 < 200)
00B0A2  9000DE     MOV [W14+10], W1
00B0A4  200C70     MOV #0xC7, W0
00B0A6  508F80     SUB W1, W0, [W15]
00B0A8  3C0023     BRA GT, .L25
547:                               {
548:               				    memcpy(u8arrBLEChTx, &dbgTemperatureBuffer[tmpi2], BLE_CHARACTERISTIC_SIZE);
00B0AA  9000DE     MOV [W14+10], W1
00B0AC  219B70     MOV #0x19B7, W0
00B0AE  408000     ADD W1, W0, W0
00B0B0  200142     MOV #0x14, W2
00B0B2  780080     MOV W0, W1
00B0B4  21CD00     MOV #0x1CD0, W0
00B0B6  07AE1C     RCALL _memcpy
549:                                   RN4871_Write_Characteristic_Value(LITATemperatureBufferHandle, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE);
00B0B8  200142     MOV #0x14, W2
00B0BA  21CD01     MOV #0x1CD0, W1
00B0BC  222860     MOV #0x2286, W0
00B0BE  0708E9     RCALL RN4871_Write_Characteristic_Value
550:                                   tmpu8 = RN4871_Read_Characteristic_Value(LITAAcknowledgementHandle, u8arrBLEChRx, 1);
00B0C0  200012     MOV #0x1, W2
00B0C2  21CBC1     MOV #0x1CBC, W1
00B0C4  222600     MOV #0x2260, W0
00B0C6  070932     RCALL RN4871_Read_Characteristic_Value
00B0C8  984720     MOV.B W0, [W14+2]
551:                                   if (tmpu8 == 1)
00B0CA  90402E     MOV.B [W14+2], W0
00B0CC  504FE1     SUB.B W0, #0x1, [W15]
00B0CE  3A000C     BRA NZ, .L26
552:                                   {
553:                                       // number of elements transferred was acknowledged
554:                                       if (tmpi1 == (int)u8arrBLEChRx[0])
00B0D0  21CBC0     MOV #0x1CBC, W0
00B0D2  784010     MOV.B [W0], W0
00B0D4  FB8080     ZE W0, W1
00B0D6  90084E     MOV [W14+24], W0
00B0D8  508F80     SUB W1, W0, [W15]
00B0DA  3A0006     BRA NZ, .L26
555:                                       {
556:                                           //DeleteEntriesTemperatureBuffer((int)u8arrBLEChRx[0]);
557:               							memset(&dbgTemperatureBuffer[tmpi2], 0, BLE_CHARACTERISTIC_SIZE);
00B0DC  9000DE     MOV [W14+10], W1
00B0DE  219B70     MOV #0x19B7, W0
00B0E0  408000     ADD W1, W0, W0
00B0E2  200142     MOV #0x14, W2
00B0E4  EB0080     CLR W1
00B0E6  07AE0B     RCALL _memset
558:                                       }
559:                                   }
560:               					tmpi2 += 20;
00B0E8  90005E     MOV [W14+10], W0
00B0EA  400074     ADD W0, #0x14, W0
00B0EC  980750     MOV W0, [W14+10]
00B0EE  370009     BRA .L24
561:                               }
562:                               else 
563:                               {
564:                                   u8arrBLEChTx[6] = 0x00;
00B0F0  21CD60     MOV #0x1CD6, W0
00B0F2  EB4080     CLR.B W1
00B0F4  784801     MOV.B W1, [W0]
565:                                   RN4871_Write_Characteristic_Value(LITATemperatureBufferHandle, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE);
00B0F6  200142     MOV #0x14, W2
00B0F8  21CD01     MOV #0x1CD0, W1
00B0FA  222860     MOV #0x2286, W0
00B0FC  0708CA     RCALL RN4871_Write_Characteristic_Value
566:                                   exit_loop = true;
00B0FE  B3C010     MOV.B #0x1, W0
00B100  984F00     MOV.B W0, [W14+8]
567:                               }
568:                           }
569:                   
570:                           exit_loop = false;
00B10A  EB4000     CLR.B W0
00B10C  984F00     MOV.B W0, [W14+8]
571:               			tmpi2 = 0;
00B10E  EB0000     CLR W0
00B110  980750     MOV W0, [W14+10]
572:                           while (!exit_loop)
00B112  370032     BRA .L28
00B178  90480E     MOV.B [W14+8], W0
00B17A  A20400     BTG.B W0, #0
00B17C  E00400     CP0.B W0
00B17E  3AFFCA     BRA NZ, .L31
573:                           {
574:                               // assuming that LITARuntimeBufferLength is 20 
575:                               // and size of u8arrChRx is 20
576:                               tmpi1 = (BLE_CHARACTERISTIC_SIZE - 6) / 4;
00B114  200030     MOV #0x3, W0
00B116  980F40     MOV W0, [W14+24]
577:                               if (tmpi2 < 200)
00B118  9000DE     MOV [W14+10], W1
00B11A  200C70     MOV #0xC7, W0
00B11C  508F80     SUB W1, W0, [W15]
00B11E  3C0023     BRA GT, .L29
578:                               {
579:               				    memcpy(u8arrBLEChTx, &dbgRuntimeBuffer[tmpi2], BLE_CHARACTERISTIC_SIZE);
00B120  9000DE     MOV [W14+10], W1
00B122  21A7F0     MOV #0x1A7F, W0
00B124  408000     ADD W1, W0, W0
00B126  200142     MOV #0x14, W2
00B128  780080     MOV W0, W1
00B12A  21CD00     MOV #0x1CD0, W0
00B12C  07ADE1     RCALL _memcpy
580:                                   RN4871_Write_Characteristic_Value(LITARuntimeBufferHandle, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE);
00B12E  200142     MOV #0x14, W2
00B130  21CD01     MOV #0x1CD0, W1
00B132  222AC0     MOV #0x22AC, W0
00B134  0708AE     RCALL RN4871_Write_Characteristic_Value
581:                                   tmpu8 = RN4871_Read_Characteristic_Value(LITAAcknowledgementHandle, u8arrBLEChRx, 1);
00B136  200012     MOV #0x1, W2
00B138  21CBC1     MOV #0x1CBC, W1
00B13A  222600     MOV #0x2260, W0
00B13C  0708F7     RCALL RN4871_Read_Characteristic_Value
00B13E  984720     MOV.B W0, [W14+2]
582:                                   if (tmpu8 == 1)
00B140  90402E     MOV.B [W14+2], W0
00B142  504FE1     SUB.B W0, #0x1, [W15]
00B144  3A000C     BRA NZ, .L30
583:                                   {
584:                                       // number of elements transferred was acknowledged
585:                                       if (tmpi1 == (int)u8arrBLEChRx[0])
00B146  21CBC0     MOV #0x1CBC, W0
00B148  784010     MOV.B [W0], W0
00B14A  FB8080     ZE W0, W1
00B14C  90084E     MOV [W14+24], W0
00B14E  508F80     SUB W1, W0, [W15]
00B150  3A0006     BRA NZ, .L30
586:                                       {
587:               							memset(&dbgRuntimeBuffer[tmpi2], 0, BLE_CHARACTERISTIC_SIZE);
00B152  9000DE     MOV [W14+10], W1
00B154  21A7F0     MOV #0x1A7F, W0
00B156  408000     ADD W1, W0, W0
00B158  200142     MOV #0x14, W2
00B15A  EB0080     CLR W1
00B15C  07ADD0     RCALL _memset
588:                                           //DeleteEntriesRuntimeBuffer((int)u8arrBLEChRx[0]);
589:                                       }
590:                                   }
591:               					tmpi2 += 20;
00B15E  90005E     MOV [W14+10], W0
00B160  400074     ADD W0, #0x14, W0
00B162  980750     MOV W0, [W14+10]
00B164  370009     BRA .L28
592:                               }
593:                               else 
594:                               {
595:                                   u8arrBLEChTx[6] = 0x00;
00B166  21CD60     MOV #0x1CD6, W0
00B168  EB4080     CLR.B W1
00B16A  784801     MOV.B W1, [W0]
596:                                   RN4871_Write_Characteristic_Value(LITARuntimeBufferHandle, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE);
00B16C  200142     MOV #0x14, W2
00B16E  21CD01     MOV #0x1CD0, W1
00B170  222AC0     MOV #0x22AC, W0
00B172  07088F     RCALL RN4871_Write_Characteristic_Value
597:                                   exit_loop = true;
00B174  B3C010     MOV.B #0x1, W0
00B176  984F00     MOV.B W0, [W14+8]
598:                               }
599:                           }
600:               
601:                           exit_loop = false;
00B180  EB4000     CLR.B W0
00B182  984F00     MOV.B W0, [W14+8]
602:               			tmpi2 = 0;
00B184  EB0000     CLR W0
00B186  980750     MOV W0, [W14+10]
603:                           while (!exit_loop)
00B188  370031     BRA .L32
00B1EC  90480E     MOV.B [W14+8], W0
00B1EE  A20400     BTG.B W0, #0
00B1F0  E00400     CP0.B W0
00B1F2  3AFFCB     BRA NZ, .L35
604:                           {
605:                               // assuming that LITASetpointBufferLength is 20 
606:                               // and size of u8arrChRx is 20
607:                               tmpi1 = (BLE_CHARACTERISTIC_SIZE - 6) / 4;
00B18A  200030     MOV #0x3, W0
00B18C  980F40     MOV W0, [W14+24]
608:                               if (tmpi2 > 0)
00B18E  90005E     MOV [W14+10], W0
00B190  E00000     CP0 W0
00B192  340023     BRA LE, .L33
609:                               {
610:               				    memcpy(u8arrBLEChTx, &dbgSetpointBuffer[tmpi2], BLE_CHARACTERISTIC_SIZE);
00B194  9000DE     MOV [W14+10], W1
00B196  21B470     MOV #0x1B47, W0
00B198  408000     ADD W1, W0, W0
00B19A  200142     MOV #0x14, W2
00B19C  780080     MOV W0, W1
00B19E  21CD00     MOV #0x1CD0, W0
00B1A0  07ADA7     RCALL _memcpy
611:                                   RN4871_Write_Characteristic_Value(LITASetpointBufferHandle, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE);
00B1A2  200142     MOV #0x14, W2
00B1A4  21CD01     MOV #0x1CD0, W1
00B1A6  222D20     MOV #0x22D2, W0
00B1A8  070874     RCALL RN4871_Write_Characteristic_Value
612:                                   tmpu8 = RN4871_Read_Characteristic_Value(LITAAcknowledgementHandle, u8arrBLEChRx, 1);
00B1AA  200012     MOV #0x1, W2
00B1AC  21CBC1     MOV #0x1CBC, W1
00B1AE  222600     MOV #0x2260, W0
00B1B0  0708BD     RCALL RN4871_Read_Characteristic_Value
00B1B2  984720     MOV.B W0, [W14+2]
613:                                   if (tmpu8 == 1)
00B1B4  90402E     MOV.B [W14+2], W0
00B1B6  504FE1     SUB.B W0, #0x1, [W15]
00B1B8  3A000C     BRA NZ, .L34
614:                                   {
615:                                       // number of elements transferred was acknowledged
616:                                       if (tmpi1 == (int)u8arrBLEChRx[0])
00B1BA  21CBC0     MOV #0x1CBC, W0
00B1BC  784010     MOV.B [W0], W0
00B1BE  FB8080     ZE W0, W1
00B1C0  90084E     MOV [W14+24], W0
00B1C2  508F80     SUB W1, W0, [W15]
00B1C4  3A0006     BRA NZ, .L34
617:                                       {
618:               							memset(&dbgSetpointBuffer[tmpi2], 0, BLE_CHARACTERISTIC_SIZE);
00B1C6  9000DE     MOV [W14+10], W1
00B1C8  21B470     MOV #0x1B47, W0
00B1CA  408000     ADD W1, W0, W0
00B1CC  200142     MOV #0x14, W2
00B1CE  EB0080     CLR W1
00B1D0  07AD96     RCALL _memset
619:                                           //DeleteEntriesSetpointBuffer((int)u8arrBLEChRx[0]);
620:                                       }
621:                                   }
622:               					tmpi2 += 20;
00B1D2  90005E     MOV [W14+10], W0
00B1D4  400074     ADD W0, #0x14, W0
00B1D6  980750     MOV W0, [W14+10]
00B1D8  370009     BRA .L32
623:                               }
624:                               else 
625:                               {
626:                                   u8arrBLEChTx[6] = 0x00;
00B1DA  21CD60     MOV #0x1CD6, W0
00B1DC  EB4080     CLR.B W1
00B1DE  784801     MOV.B W1, [W0]
627:                                   RN4871_Write_Characteristic_Value(LITASetpointBufferHandle, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE);
00B1E0  200142     MOV #0x14, W2
00B1E2  21CD01     MOV #0x1CD0, W1
00B1E4  222D20     MOV #0x22D2, W0
00B1E6  070855     RCALL RN4871_Write_Characteristic_Value
628:                                   exit_loop = true;
00B1E8  B3C010     MOV.B #0x1, W0
00B1EA  984F00     MOV.B W0, [W14+8]
629:                               }
630:                           }
631:                           
632:                           
633:               #else
634:                           tmpu8 = RN4871_Read_Characteristic_Value(LITATimeSynchronizeCharHandle, u8arrBLEChRx, LITATimeSynchronizeU8Length);
635:                           if (tmpu8 == 1)
636:                           {
637:                               ReadRTCInitializedMemory();
638:                               if (rtccTimeInitialized == false)
639:                               {
640:                                   to_set_time.tm_year = u8arrBLEChRx[0];
641:                                   to_set_time.tm_mon = u8arrBLEChRx[1];
642:                                   to_set_time.tm_mday = u8arrBLEChRx[2];
643:                                   to_set_time.tm_hour = u8arrBLEChRx[3];
644:                                   to_set_time.tm_min = u8arrBLEChRx[4];
645:                                   to_set_time.tm_sec = u8arrBLEChRx[5];
646:                                   to_set_time.tm_isdst = u8arrBLEChRx[6];
647:                                   RTCC_TimeSet(&to_set_time);
648:                                   WriteRTCInitializedMemory();
649:                                   WriteRTCSetupTime(&to_set_time);
650:                               }
651:                           }
652:                           tmpu8 = RN4871_Read_Characteristic_Value(LITAUserParametersCharHandle, u8arrBLEChRx, 10);
653:                           if (tmpu8 == 1)
654:                           {
655:                               if ( ( u8arrBLEChRx[0] & 0x01) == 0x01 )
656:                               {
657:                                   if ( ( (u8arrBLEChRx[5] > 0) && (u8arrBLEChRx[5] <= 60) ) && (u8ApplicationState == APP_STATE_ON) )
658:                                   {
659:                                       u8TimerMinutesToOff = u8arrBLEChRx[5];
660:                                   }
661:                                   else if ( (u8arrBLEChRx[5] == 0xFF) && (u8ApplicationState == APP_STATE_OFF) )
662:                                   {
663:                                       u8ApplicationState = APP_STATE_ON;
664:                                       ReadAwayScheduleMode();
665:                                   }
666:                                       
667:                               }
668:                               if ( ( u8arrBLEChRx[0] & 0x02) == 0x02 )
669:                               {
670:                                   if ( ( (u8arrBLEChRx[3] > MIN_COOL_SETPOINT_DEGF) && (u8arrBLEChRx[3] <= MAX_COOL_SETPOINT_DEGF) ) && (u8ApplicationState == APP_STATE_ON) )
671:                                   {
672:                                       u8CoolSetpoint = u8arrBLEChRx[3];
673:                                   }
674:                                   if ( ( (u8arrBLEChRx[4] > MIN_HEAT_SETPOINT_DEGF) && (u8arrBLEChRx[4] <= MAX_HEAT_SETPOINT_DEGF) ) && (u8ApplicationState == APP_STATE_ON) )
675:                                   {
676:                                       u8HeatSetpoint = u8arrBLEChRx[3];
677:                                   }
678:                               }
679:                               if ( ( u8arrBLEChRx[0] & 0x04) == 0x04 )
680:                               {
681:                                   if ( (u8arrBLEChRx[2] > 0) && (u8arrBLEChRx[2] <= 3 ) )  
682:                                   {
683:                                       u8Hysteresis = u8arrBLEChRx[2];
684:                                   }
685:                               }                
686:                               if ( ( u8arrBLEChRx[0] & 0x08) == 0x08 )
687:                               {
688:                                   if ( ( u8arrBLEChRx[1] >= MODE_HEAT_ONLY ) && (u8arrBLEChRx[1] <= MODE_HEATCOOL) )
689:                                   {
690:                                       u8ThermostatMode = u8arrBLEChRx[1];
691:                                       WriteThermostatMode();
692:                                   }
693:                               }                
694:                               if ( (u8arrBLEChRx[0] & 0x10) == 0x10)
695:                               {
696:                                   if (u8arrBLEChRx[6] == SCHEDULE_AWAY)
697:                                   {
698:                                       if ( !( ( u8arrBLEChRx[7] >= MODE_HEAT_ONLY ) && (u8arrBLEChRx[1] <= MODE_HEATCOOL) ) )
699:                                       {
700:                                           u8arrBLEChRx[7] = MODE_HEATCOOL;
701:                                       }
702:                                       if ( !( (u8arrBLEChRx[8] > MIN_COOL_SETPOINT_DEGF) && (u8arrBLEChRx[8] <= MAX_COOL_SETPOINT_DEGF) )  )
703:                                       {
704:                                           u8arrBLEChRx[8] = COOL_SETPOINT_DEFAULT_DEGF;
705:                                       }
706:                                       if ( !( (u8arrBLEChRx[9] > MIN_HEAT_SETPOINT_DEGF) && (u8arrBLEChRx[9] <= MAX_HEAT_SETPOINT_DEGF) ) )
707:                                       {
708:                                           u8arrBLEChRx[9] = HEAT_SETPOINT_DEFAULT_DEGF;
709:                                       }
710:                                       WriteAwayScheduleMode(u8arrBLEChRx[7], u8arrBLEChRx[8], u8arrBLEChRx[9]);
711:                                   }
712:                                   if (u8ApplicationState == APP_STATE_OFF)
713:                                   {
714:                                           
715:                                   } 
716:                                   else // u8ApplicationState == APP_STATE_ON
717:                                   {
718:                                       if ( (u8arrBLEChRx[6] == SCHEDULE_HOME) || (u8arrBLEChRx[6] == SCHEDULE_NONE) || ((u8arrBLEChRx[6] == SCHEDULE_AWAY)) )
719:                                       {
720:                                           u8GotoSchedule = u8arrBLEChRx[6];
721:                                       }
722:                                   }
723:                               }
724:                           }            
725:                           exit_loop = false;
726:                           while (!exit_loop)
727:                           {
728:                               tmpu8_count = 0;
729:                               tmpu8 = RN4871_Read_Characteristic_Value(LITASchedulesCharHandle, u8arrBLEChRx, 20);
730:                               if (tmpu8 == 1)
731:                               {
732:                                   tmpu8_idx = 0;
733:                                   while (tmpu8_idx < LITASchedulesU8Length) 
734:                                   {
735:                                       if (    (u8arrBLEChRx[tmpu8_idx] <= 0x64) || 
736:                                               (u8arrBLEChRx[tmpu8_idx] == 0x0F) || 
737:                                               (u8arrBLEChRx[tmpu8_idx] == 0xFF) || 
738:                                               (u8arrBLEChRx[tmpu8_idx] == 0xFF) 
739:                                           )
740:                                       {
741:                                           if (u8arrBLEChRx[tmpu8_idx] == 0x0F)
742:                                           {
743:                                               u8arrDrEvent[0] = u8arrBLEChRx[tmpu8_idx+1];
744:                                               u8arrDrEvent[1] = u8arrBLEChRx[tmpu8_idx+2];
745:                                               u8arrDrEvent[2] = u8arrBLEChRx[tmpu8_idx+3];
746:                                               u8arrDrEvent[3] = u8arrBLEChRx[tmpu8_idx+4];
747:                                               
748:                                           }
749:                                           else if (u8arrBLEChRx[tmpu8_idx] == 0xF0)
750:                                           {
751:                                               u8arrDrEvent[4] = u8arrBLEChRx[tmpu8_idx+1];
752:                                               u8arrDrEvent[5] = u8arrBLEChRx[tmpu8_idx+2];
753:                                               u8arrDrEvent[6] = u8arrBLEChRx[tmpu8_idx+3];
754:                                               u8arrDrEvent[7] = u8arrBLEChRx[tmpu8_idx+4];
755:                                               WriteDRSchedule();
756:                                           }
757:                                           else if (u8arrBLEChRx[tmpu8_idx] == 0xFF)
758:                                           {
759:                                               exit_loop = true;
760:                                           }
761:                                           else
762:                                           {
763:                                               // valid schedule received
764:                                               tmpu8_dow = (u8arrBLEChRx[tmpu8_idx] & 0xF0) >> 4;
765:                                               tmpu8_num = u8arrBLEChRx[tmpu8_idx] & 0x0F;
766:                                               WriteSingleSchedule(tmpu8_dow, tmpu8_num, 
767:                                                      u8arrBLEChRx[tmpu8_idx+1], u8arrBLEChRx[tmpu8_idx+2],
768:                                                       u8arrBLEChRx[tmpu8_idx+3], u8arrBLEChRx[tmpu8_idx+4]);
769:                                               tmpu8_count += 1;
770:                                           }
771:                                       }
772:                                       tmpu8_idx += 5;
773:                                   }
774:                                   u8arrBLEChTx[0] = tmpu8_count;
775:                                   RN4871_Write_Characteristic_Value(LITAAcknowledgementHandle, u8arrBLEChTx, 1);
776:                                   
777:                               }
778:                           }
779:                           
780:                           exit_loop = false;
781:                           while (!exit_loop)
782:                           {
783:                               // assuming that LITATemperatureBufferLength is 20
784:                               // and size of u8arrChTx is also 20
785:                               tmpi1 = (BLE_CHARACTERISTIC_SIZE - 6) / 4;
786:                               tmpi2 = ReadTemperatureBuffer(tmpi1, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE); 
787:                               if (tmpi2 > 0)
788:                               {
789:                                   RN4871_Write_Characteristic_Value(LITATemperatureBufferHandle, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE);
790:                                   tmpu8 = RN4871_Read_Characteristic_Value(LITAAcknowledgementHandle, u8arrBLEChRx, 1);
791:                                   if (tmpu8 == 1)
792:                                   {
793:                                       // number of elements transferred was acknowledged
794:                                       if (tmpi1 == (int)u8arrBLEChRx[0])
795:                                       {
796:                                           DeleteEntriesTemperatureBuffer((int)u8arrBLEChRx[0]);
797:                                       }
798:                                   }
799:                               }
800:                               else 
801:                               {
802:                                   u8arrBLEChTx[6] = 0x00;
803:                                   RN4871_Write_Characteristic_Value(LITATemperatureBufferHandle, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE);
804:                                   exit_loop = true;
805:                               }
806:                           }
807:               
808:                           exit_loop = false;
809:                           while (!exit_loop)
810:                           {
811:                               // assuming that LITARuntimeBufferLength is 20 
812:                               // and size of u8arrChRx is 20
813:                               tmpi1 = (BLE_CHARACTERISTIC_SIZE - 6) / 4;
814:                               tmpi2 = ReadRuntimeBuffer(tmpi1, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE); 
815:                               if (tmpi2 > 0)
816:                               {
817:                                   RN4871_Write_Characteristic_Value(LITARuntimeBufferHandle, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE);
818:                                   tmpu8 = RN4871_Read_Characteristic_Value(LITAAcknowledgementHandle, u8arrBLEChRx, 1);
819:                                   if (tmpu8 == 1)
820:                                   {
821:                                       // number of elements transferred was acknowledged
822:                                       if (tmpi1 == (int)u8arrBLEChRx[0])
823:                                       {
824:                                           DeleteEntriesRuntimeBuffer((int)u8arrBLEChRx[0]);
825:                                       }
826:                                   }
827:                               }
828:                               else 
829:                               {
830:                                   u8arrBLEChTx[6] = 0x00;
831:                                   RN4871_Write_Characteristic_Value(LITARuntimeBufferHandle, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE);
832:                                   exit_loop = true;
833:                               }
834:                           }
835:               
836:                           exit_loop = false;
837:                           while (!exit_loop)
838:                           {
839:                               // assuming that LITASetpointBufferLength is 20 
840:                               // and size of u8arrChRx is 20
841:                               tmpi1 = (BLE_CHARACTERISTIC_SIZE - 6) / 4;
842:                               tmpi2 = ReadSetpointBuffer(tmpi1, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE); 
843:                               if (tmpi2 > 0)
844:                               {
845:                                   RN4871_Write_Characteristic_Value(LITASetpointBufferHandle, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE);
846:                                   tmpu8 = RN4871_Read_Characteristic_Value(LITAAcknowledgementHandle, u8arrBLEChRx, 1);
847:                                   if (tmpu8 == 1)
848:                                   {
849:                                       // number of elements transferred was acknowledged
850:                                       if (tmpi1 == (int)u8arrBLEChRx[0])
851:                                       {
852:                                           DeleteEntriesSetpointBuffer((int)u8arrBLEChRx[0]);
853:                                       }
854:                                   }
855:                               }
856:                               else 
857:                               {
858:                                   u8arrBLEChTx[6] = 0x00;
859:                                   RN4871_Write_Characteristic_Value(LITASetpointBufferHandle, u8arrBLEChTx, BLE_CHARACTERISTIC_SIZE);
860:                                   exit_loop = true;
861:                               }
862:                           }
863:               #endif           
864:                           if (!BLE_Connected)
00B1F4  BFC90B     MOV.B BLE_Connected, WREG
00B1F6  A20400     BTG.B W0, #0
00B1F8  E00400     CP0.B W0
00B1FA  320005     BRA Z, .L36
865:                           {                
866:                               RN4871_SetLowPowerMode();
00B1FC  0707B0     RCALL RN4871_SetLowPowerMode
867:                               u8CurrentState = STATE_SLEEP;                
00B1FE  EF68B0     CLR.B u8CurrentState
868:                               RTCC_AlarmEnable(3);
00B200  B3C030     MOV.B #0x3, W0
00B202  070EA1     RCALL RTCC_AlarmEnable
00B204  370005     BRA .L37
869:                           }
870:                           else 
871:                           {
872:                               // since everything is done, simply disconnect
873:                               RN4871_Disconnect();
00B206  0707B1     RCALL RN4871_Disconnect
874:                               RN4871_SetLowPowerMode();
00B208  0707AA     RCALL RN4871_SetLowPowerMode
875:                               u8CurrentState = STATE_SLEEP;                
00B20A  EF68B0     CLR.B u8CurrentState
876:                               RTCC_AlarmEnable(3);
00B20C  B3C030     MOV.B #0x3, W0
00B20E  070E9B     RCALL RTCC_AlarmEnable
877:                           }
878:                           
879:                           __delay_ms(1000); //loop at 1 second rate
00B210  224000     MOV #0x2400, W0
00B212  200F41     MOV #0xF4, W1
00B214  070EDE     RCALL ___delay32, .Letext0, .LFE18
880:                       }
881:                       
882:                       /**************************************************
883:                        *              ACTIVE STATE
884:                        *  In this state when user has pressed the power button in sleep state
885:                        *  should go back to sleep after a activity timeout
886:                       ***************************************************/
887:                       while (u8CurrentState == STATE_ACTIVE)
00B21C  3701CD     BRA .L39
00B5B8  BFC8B0     MOV.B u8CurrentState, WREG
00B5BA  504FE2     SUB.B W0, #0x2, [W15]
00B5BC  32FE30     BRA Z, .L87
888:                       {
889:                           ClrWdt();
00B21E  FE6000     CLRWDT
890:                           RTCC_AlarmDisable();
00B220  070EAD     RCALL RTCC_AlarmDisable
891:                           //Starting up the 1s timer to keep track of user activity
892:                           TMR3_Start();
00B222  07034C     RCALL TMR3_Start
893:                           goto_sleep_immediate = false;
00B224  EB4000     CLR.B W0
00B226  984770     MOV.B W0, [W14+7]
894:                           if (bPowerButtonPressed == true)
00B228  BFC8AD     MOV.B bPowerButtonPressed, WREG
00B22A  E00400     CP0.B W0
00B22C  32000F     BRA Z, .L40
895:                           {
896:                               bPowerButtonPressed = false;
00B22E  EF68AD     CLR.B bPowerButtonPressed
897:                               //ReadApplicationState();
898:                               if (u8ApplicationState == (uint8_t) APP_STATE_ON) 
00B230  BFC8B4     MOV.B u8ApplicationState, WREG
00B232  504FE1     SUB.B W0, #0x1, [W15]
00B234  3A0003     BRA NZ, .L41
899:                               {
900:                                   u8ApplicationState = (uint8_t) APP_STATE_OFF;
00B236  B3C020     MOV.B #0x2, W0
00B238  B7E8B4     MOV.B WREG, u8ApplicationState
00B23A  370005     BRA .L42
901:                               }
902:                               else if (u8ApplicationState == (uint8_t) APP_STATE_OFF) 
00B23C  BFC8B4     MOV.B u8ApplicationState, WREG
00B23E  504FE2     SUB.B W0, #0x2, [W15]
00B240  3A0002     BRA NZ, .L42
903:                               {
904:                                   u8ApplicationState = (uint8_t) APP_STATE_ON;
00B242  B3C010     MOV.B #0x1, W0
00B244  B7E8B4     MOV.B WREG, u8ApplicationState
905:                               }
906:                               goto_sleep_immediate = true;
00B246  B3C010     MOV.B #0x1, W0
00B248  984770     MOV.B W0, [W14+7]
00B24A  3701A7     BRA .L43
907:                           }
908:                           else if (bUpButtonPressed == true)
00B24C  BFC8AB     MOV.B bUpButtonPressed, WREG
00B24E  E00400     CP0.B W0
00B250  32003F     BRA Z, .L44
909:                           {
910:                               bUpButtonPressed = false;
00B252  EF68AB     CLR.B bUpButtonPressed
911:                               if (u8ThermostatMode == MODE_HEATCOOL)
00B254  BFC8BE     MOV.B u8ThermostatMode, WREG
00B256  504FE3     SUB.B W0, #0x3, [W15]
00B258  3A0019     BRA NZ, .L45
912:                               {
913:                                   tmpu8_hsp = u8NewHeatSetpoint + 1;
00B25A  BFC8B9     MOV.B u8NewHeatSetpoint, WREG
00B25C  E84000     INC.B W0, W0
00B25E  984750     MOV.B W0, [W14+5]
914:                                   tmpu8_csp = u8NewCoolSetpoint + 1;
00B260  BFC8B6     MOV.B u8NewCoolSetpoint, WREG
00B262  E84000     INC.B W0, W0
00B264  984760     MOV.B W0, [W14+6]
915:                                   if (tmpu8_hsp > MAX_HEAT_SETPOINT_DEGF)
00B266  9040DE     MOV.B [W14+5], W1
00B268  B3C4A0     MOV.B #0x4A, W0
00B26A  50CF80     SUB.B W1, W0, [W15]
00B26C  360002     BRA LEU, .L46
916:                                   {
917:                                       tmpu8_hsp = MAX_HEAT_SETPOINT_DEGF;
00B26E  B3C4A0     MOV.B #0x4A, W0
00B270  984750     MOV.B W0, [W14+5]
918:                                   }
919:                                   if (tmpu8_csp > MAX_COOL_SETPOINT_DEGF)
00B272  9040EE     MOV.B [W14+6], W1
00B274  B3C5A0     MOV.B #0x5A, W0
00B276  50CF80     SUB.B W1, W0, [W15]
00B278  360002     BRA LEU, .L47
920:                                   {
921:                                       tmpu8_csp = MAX_COOL_SETPOINT_DEGF;
00B27A  B3C5A0     MOV.B #0x5A, W0
00B27C  984760     MOV.B W0, [W14+6]
922:                                   }
923:                                   u8NewHeatSetpoint = tmpu8_hsp;
00B27E  9040DE     MOV.B [W14+5], W1
00B280  208B92     MOV #0x8B9, W2
00B282  784901     MOV.B W1, [W2]
924:                                   u8NewCoolSetpoint = tmpu8_csp;
00B284  9040EE     MOV.B [W14+6], W1
00B286  208B62     MOV #0x8B6, W2
00B288  784901     MOV.B W1, [W2]
00B28A  37001F     BRA .L48
925:                               }
926:                               else if (u8ThermostatMode == MODE_COOL_ONLY)
00B28C  BFC8BE     MOV.B u8ThermostatMode, WREG
00B28E  504FE2     SUB.B W0, #0x2, [W15]
00B290  3A000D     BRA NZ, .L49
927:                               {
928:                                   tmpu8_csp = u8NewCoolSetpoint + 1;
00B292  BFC8B6     MOV.B u8NewCoolSetpoint, WREG
00B294  E84000     INC.B W0, W0
00B296  984760     MOV.B W0, [W14+6]
929:                                   if (tmpu8_csp > MAX_COOL_SETPOINT_DEGF)
00B298  9040EE     MOV.B [W14+6], W1
00B29A  B3C5A0     MOV.B #0x5A, W0
00B29C  50CF80     SUB.B W1, W0, [W15]
00B29E  360002     BRA LEU, .L50
930:                                   {
931:                                       tmpu8_csp = MAX_COOL_SETPOINT_DEGF;
00B2A0  B3C5A0     MOV.B #0x5A, W0
00B2A2  984760     MOV.B W0, [W14+6]
932:                                   }
933:                                   u8NewCoolSetpoint = tmpu8_csp;
00B2A4  9040EE     MOV.B [W14+6], W1
00B2A6  208B62     MOV #0x8B6, W2
00B2A8  784901     MOV.B W1, [W2]
00B2AA  37000F     BRA .L48
934:                               }
935:                               else if (u8ThermostatMode == MODE_HEAT_ONLY)
00B2AC  BFC8BE     MOV.B u8ThermostatMode, WREG
00B2AE  504FE1     SUB.B W0, #0x1, [W15]
00B2B0  3A000C     BRA NZ, .L48
936:                               {
937:                                   tmpu8_hsp = u8NewHeatSetpoint + 1;
00B2B2  BFC8B9     MOV.B u8NewHeatSetpoint, WREG
00B2B4  E84000     INC.B W0, W0
00B2B6  984750     MOV.B W0, [W14+5]
938:                                   if (tmpu8_hsp > MAX_HEAT_SETPOINT_DEGF)
00B2B8  9040DE     MOV.B [W14+5], W1
00B2BA  B3C4A0     MOV.B #0x4A, W0
00B2BC  50CF80     SUB.B W1, W0, [W15]
00B2BE  360002     BRA LEU, .L51
939:                                   {
940:                                       tmpu8_hsp = MAX_HEAT_SETPOINT_DEGF;
00B2C0  B3C4A0     MOV.B #0x4A, W0
00B2C2  984750     MOV.B W0, [W14+5]
941:                                   }
942:                                   u8NewHeatSetpoint = tmpu8_hsp;
00B2C4  9040DE     MOV.B [W14+5], W1
00B2C6  208B92     MOV #0x8B9, W2
00B2C8  784901     MOV.B W1, [W2]
943:                               }
944:                               goto_sleep_immediate = true;
00B2CA  B3C010     MOV.B #0x1, W0
00B2CC  984770     MOV.B W0, [W14+7]
00B2CE  370165     BRA .L43
945:                           }
946:                           else if (bDownButtonPressed == true)
00B2D0  BFC8AC     MOV.B bDownButtonPressed, WREG
00B2D2  E00400     CP0.B W0
00B2D4  32003F     BRA Z, .L52
947:                           {
948:                               bDownButtonPressed = false;
00B2D6  EF68AC     CLR.B bDownButtonPressed
949:                               if (u8ThermostatMode == MODE_HEATCOOL)
00B2D8  BFC8BE     MOV.B u8ThermostatMode, WREG
00B2DA  504FE3     SUB.B W0, #0x3, [W15]
00B2DC  3A0019     BRA NZ, .L53
950:                               {
951:                                   tmpu8_hsp = u8NewHeatSetpoint - 1;
00B2DE  BFC8B9     MOV.B u8NewHeatSetpoint, WREG
00B2E0  E94000     DEC.B W0, W0
00B2E2  984750     MOV.B W0, [W14+5]
952:                                   tmpu8_csp = u8NewCoolSetpoint - 1;
00B2E4  BFC8B6     MOV.B u8NewCoolSetpoint, WREG
00B2E6  E94000     DEC.B W0, W0
00B2E8  984760     MOV.B W0, [W14+6]
953:                                   if (tmpu8_hsp < MIN_HEAT_SETPOINT_DEGF)
00B2EA  9040DE     MOV.B [W14+5], W1
00B2EC  B3C310     MOV.B #0x31, W0
00B2EE  50CF80     SUB.B W1, W0, [W15]
00B2F0  3E0002     BRA GTU, .L54
954:                                   {
955:                                       tmpu8_hsp = MIN_HEAT_SETPOINT_DEGF;
00B2F2  B3C320     MOV.B #0x32, W0
00B2F4  984750     MOV.B W0, [W14+5]
956:                                   }
957:                                   if (tmpu8_csp < MIN_COOL_SETPOINT_DEGF)
00B2F6  9040EE     MOV.B [W14+6], W1
00B2F8  B3C4A0     MOV.B #0x4A, W0
00B2FA  50CF80     SUB.B W1, W0, [W15]
00B2FC  3E0002     BRA GTU, .L55
958:                                   {
959:                                       tmpu8_csp = MIN_COOL_SETPOINT_DEGF;
00B2FE  B3C4B0     MOV.B #0x4B, W0
00B300  984760     MOV.B W0, [W14+6]
960:                                   }
961:                                   u8NewHeatSetpoint = tmpu8_hsp;
00B302  9040DE     MOV.B [W14+5], W1
00B304  208B92     MOV #0x8B9, W2
00B306  784901     MOV.B W1, [W2]
962:                                   u8NewCoolSetpoint = tmpu8_csp;
00B308  9040EE     MOV.B [W14+6], W1
00B30A  208B62     MOV #0x8B6, W2
00B30C  784901     MOV.B W1, [W2]
00B30E  37001F     BRA .L56
963:                               }
964:                               else if (u8ThermostatMode == MODE_COOL_ONLY)
00B310  BFC8BE     MOV.B u8ThermostatMode, WREG
00B312  504FE2     SUB.B W0, #0x2, [W15]
00B314  3A000D     BRA NZ, .L57
965:                               {
966:                                   tmpu8_csp = u8NewCoolSetpoint + 1;
00B316  BFC8B6     MOV.B u8NewCoolSetpoint, WREG
00B318  E84000     INC.B W0, W0
00B31A  984760     MOV.B W0, [W14+6]
967:                                   if (tmpu8_csp < MIN_COOL_SETPOINT_DEGF)
00B31C  9040EE     MOV.B [W14+6], W1
00B31E  B3C4A0     MOV.B #0x4A, W0
00B320  50CF80     SUB.B W1, W0, [W15]
00B322  3E0002     BRA GTU, .L58
968:                                   {
969:                                       tmpu8_csp = MIN_COOL_SETPOINT_DEGF;
00B324  B3C4B0     MOV.B #0x4B, W0
00B326  984760     MOV.B W0, [W14+6]
970:                                   }
971:                                   u8NewCoolSetpoint = tmpu8_csp;
00B328  9040EE     MOV.B [W14+6], W1
00B32A  208B62     MOV #0x8B6, W2
00B32C  784901     MOV.B W1, [W2]
00B32E  37000F     BRA .L56
972:                               }
973:                               else if (u8ThermostatMode == MODE_HEAT_ONLY)
00B330  BFC8BE     MOV.B u8ThermostatMode, WREG
00B332  504FE1     SUB.B W0, #0x1, [W15]
00B334  3A000C     BRA NZ, .L56
974:                               {
975:                                   tmpu8_hsp = u8NewHeatSetpoint + 1;
00B336  BFC8B9     MOV.B u8NewHeatSetpoint, WREG
00B338  E84000     INC.B W0, W0
00B33A  984750     MOV.B W0, [W14+5]
976:                                   if (tmpu8_hsp < MIN_HEAT_SETPOINT_DEGF)
00B33C  9040DE     MOV.B [W14+5], W1
00B33E  B3C310     MOV.B #0x31, W0
00B340  50CF80     SUB.B W1, W0, [W15]
00B342  3E0002     BRA GTU, .L59
977:                                   {
978:                                       tmpu8_hsp = MIN_HEAT_SETPOINT_DEGF;
00B344  B3C320     MOV.B #0x32, W0
00B346  984750     MOV.B W0, [W14+5]
979:                                   }
980:                                   u8NewHeatSetpoint = tmpu8_hsp;
00B348  9040DE     MOV.B [W14+5], W1
00B34A  208B92     MOV #0x8B9, W2
00B34C  784901     MOV.B W1, [W2]
981:                               }
982:                               goto_sleep_immediate = true;
00B34E  B3C010     MOV.B #0x1, W0
00B350  984770     MOV.B W0, [W14+7]
00B352  370123     BRA .L43
983:                           }
984:                           else if (bTimerButtonPressed == true)
00B354  BFC8AA     MOV.B bTimerButtonPressed, WREG
00B356  E00400     CP0.B W0
00B358  320019     BRA Z, .L60
985:                           {
986:                               bTimerButtonPressed = false;
00B35A  EF68AA     CLR.B bTimerButtonPressed
987:                               if (u8ApplicationState != (uint8_t) APP_STATE_TIMER)
00B35C  BFC8B4     MOV.B u8ApplicationState, WREG
00B35E  504FE3     SUB.B W0, #0x3, [W15]
00B360  320005     BRA Z, .L61
988:                               {
989:                                   u8ApplicationState = (uint8_t) APP_STATE_TIMER;
00B362  B3C030     MOV.B #0x3, W0
00B364  B7E8B4     MOV.B WREG, u8ApplicationState
990:                                   u8TimerMinutesToOff = 15;
00B366  B3C0F0     MOV.B #0xF, W0
00B368  B7E8C3     MOV.B WREG, u8TimerMinutesToOff
00B36A  37000D     BRA .L62
991:                               }
992:                               else 
993:                               {
994:                                   if ( (u8TimerMinutesToOff >= 0 ) && (u8TimerMinutesToOff < 60) )
00B36C  208C31     MOV #0x8C3, W1
00B36E  784091     MOV.B [W1], W1
00B370  B3C3B0     MOV.B #0x3B, W0
00B372  50CF80     SUB.B W1, W0, [W15]
00B374  3E0008     BRA GTU, .L62
995:                                   {
996:                                       if ( (uint8_t)(u8TimerMinutesToOff + 15) < (uint8_t)MAX_TIMER_OFF_MINUTES )
00B376  BFC8C3     MOV.B u8TimerMinutesToOff, WREG
00B378  4040EF     ADD.B W0, #0xF, W1
00B37A  B3C3B0     MOV.B #0x3B, W0
00B37C  50CF80     SUB.B W1, W0, [W15]
00B37E  3E0003     BRA GTU, .L62
997:                                       {
998:                                           u8TimerMinutesToOff += 15;
00B380  BFC8C3     MOV.B u8TimerMinutesToOff, WREG
00B382  40406F     ADD.B W0, #0xF, W0
00B384  B7E8C3     MOV.B WREG, u8TimerMinutesToOff
999:                                       }
1000:                                  }
1001:                              }
1002:                              goto_sleep_immediate = true;
00B386  B3C010     MOV.B #0x1, W0
00B388  984770     MOV.B W0, [W14+7]
00B38A  370107     BRA .L43
1003:                          }
1004:                          else if (RTCCAlarmOn == true) 
00B38C  BFC8AF     MOV.B RTCCAlarmOn, WREG
00B38E  E00400     CP0.B W0
00B390  320104     BRA Z, .L43
1005:                          {
1006:                              RTCCAlarmOn = false;
00B392  EF68AF     CLR.B RTCCAlarmOn
1007:                              tmp_app_state = u8ApplicationState;
00B394  208B42     MOV #0x8B4, W2
00B396  784112     MOV.B [W2], W2
00B398  985F22     MOV.B W2, [W14+26]
1008:                              //read temperature and update display
1009:                              //Going to sleep after a period of no activity (user buttons or ble)
1010:                              u8EdgeTemperature = ReadBoardTemperature(BoardEdge);
00B39A  B3C0A0     MOV.B #0xA, W0
00B39C  07F0CC     RCALL ReadBoardTemperature
00B39E  B7E8E1     MOV.B WREG, u8EdgeTemperature
1011:                              // TODO: if using algorithms to compute based on edge/ center temperature it needs to be done here
1012:                              // and set to the variable u8CurrenetTemperature
1013:                              u8PrevCurrentTemperature = u8CurrentTemperature;
00B3A0  BFC8C0     MOV.B u8CurrentTemperature, WREG
00B3A2  B7E8C1     MOV.B WREG, u8PrevCurrentTemperature
1014:                              u8CurrentTemperature =  Temperature_average(u8EdgeTemperature) ;
00B3A4  BFC8E1     MOV.B u8EdgeTemperature, WREG
00B3A6  07F33A     RCALL Temperature_average
00B3A8  B7E8C0     MOV.B WREG, u8CurrentTemperature
1015:                              if (u16PartialScreenUpdateCount >= SCREEN_REFRESH_AFTER_PARTIAL_UPDATES)
00B3AA  8045E1     MOV u16PartialScreenUpdateCount, W1
00B3AC  207CF0     MOV #0x7CF, W0
00B3AE  508F80     SUB W1, W0, [W15]
00B3B0  36001C     BRA LEU, .L63
1016:                              {
1017:                                  // redraw the screen
1018:                                  epaper_on();
00B3B2  07E84E     RCALL epaper_on
1019:                                  epaper_draw_screen(u8CoolSetpoint,u8HeatSetpoint);
00B3B4  208B81     MOV #0x8B8, W1
00B3B6  784091     MOV.B [W1], W1
00B3B8  BFC8B5     MOV.B u8CoolSetpoint, WREG
00B3BA  07EEAA     RCALL epaper_draw_screen
1020:                                  if (u8ActionOnScreen == 1)
00B3BC  BFC8C4     MOV.B u8ActionOnScreen, WREG
00B3BE  504FE1     SUB.B W0, #0x1, [W15]
00B3C0  3A000B     BRA NZ, .L64
1021:                                  {
1022:                                      if (u8CurrentThermostatAction == (uint8_t) ACTION_HEATING) 
00B3C2  BFC8C2     MOV.B u8CurrentThermostatAction, WREG
00B3C4  504FE1     SUB.B W0, #0x1, [W15]
00B3C6  3A0003     BRA NZ, .L65
1023:                                      {
1024:                                          epaper_draw_heatcool(DISPLAY_ACTION_HEAT);
00B3C8  B3C010     MOV.B #0x1, W0
00B3CA  07EEAC     RCALL epaper_draw_heatcool
00B3CC  370005     BRA .L64
1025:                                      }
1026:                                      else if (u8CurrentThermostatAction == (uint8_t) ACTION_COOLING)
00B3CE  BFC8C2     MOV.B u8CurrentThermostatAction, WREG
00B3D0  504FE2     SUB.B W0, #0x2, [W15]
00B3D2  3A0002     BRA NZ, .L64
1027:                                      {
1028:                                          epaper_draw_heatcool(DISPLAY_ACTION_COOL);
00B3D4  EB4000     CLR.B W0
00B3D6  07EEA6     RCALL epaper_draw_heatcool
1029:                                      }
1030:                                  }
1031:                                  if (u8BatteryOnScreen == 1)
00B3D8  BFC8C5     MOV.B u8BatteryOnScreen, WREG
00B3DA  504FE1     SUB.B W0, #0x1, [W15]
00B3DC  3A0002     BRA NZ, .L66
1032:                                  {
1033:                                      epaper_draw_battery(1);
00B3DE  B3C010     MOV.B #0x1, W0
00B3E0  07EF36     RCALL epaper_draw_battery
1034:                                  }
1035:                                  drawTemperature(u8CurrentTemperature);
00B3E2  BFC8C0     MOV.B u8CurrentTemperature, WREG
00B3E4  07ED09     RCALL drawTemperature
1036:                                  epaper_off();
00B3E6  07E83E     RCALL epaper_off
00B3E8  370037     BRA .L67
1037:                              }
1038:                              else 
1039:                              {
1040:                                  if (u8PrevCurrentTemperature != u8CurrentTemperature)
00B3EA  208C11     MOV #0x8C1, W1
00B3EC  784091     MOV.B [W1], W1
00B3EE  BFC8C0     MOV.B u8CurrentTemperature, WREG
00B3F0  50CF80     SUB.B W1, W0, [W15]
00B3F2  320009     BRA Z, .L68
1041:                                  {
1042:                                      // TODO: CHECK AND WRITE THE TEMPERATURE BUFFER
1043:                                      //WriteTemperatureBuffer();
1044:                                      epaper_on();
00B3F4  07E82D     RCALL epaper_on
1045:                                      clear_indicator(temperature_min_x, temperature_min_y, temperature_max_x, temperature_max_y);
00B3F6  804503     MOV temperature_max_y, W3
00B3F8  8044F2     MOV temperature_max_x, W2
00B3FA  8044E1     MOV temperature_min_y, W1
00B3FC  8044D0     MOV temperature_min_x, W0
00B3FE  07EADE     RCALL clear_indicator
1046:                                      drawTemperature(u8CurrentTemperature);
00B400  BFC8C0     MOV.B u8CurrentTemperature, WREG
00B402  07ECFA     RCALL drawTemperature
1047:                                      epaper_off();
00B404  07E82F     RCALL epaper_off
1048:                                  }
1049:                                  if ( (u8NewHeatSetpoint != u8HeatSetpoint) || (u8NewCoolSetpoint != u8CoolSetpoint) )
00B406  208B91     MOV #0x8B9, W1
00B408  784091     MOV.B [W1], W1
00B40A  BFC8B8     MOV.B u8HeatSetpoint, WREG
00B40C  50CF80     SUB.B W1, W0, [W15]
00B40E  3A0005     BRA NZ, .L69
00B410  208B61     MOV #0x8B6, W1
00B412  784091     MOV.B [W1], W1
00B414  BFC8B5     MOV.B u8CoolSetpoint, WREG
00B416  50CF80     SUB.B W1, W0, [W15]
00B418  320001     BRA Z, .L70
1050:                                  {
1051:                                      WriteSetpointBuffer(); // writes the u8NewHeatSetpoint and u8NewCoolSetpoint
00B41A  07E51C     RCALL WriteSetpointBuffer
1052:                                  }
1053:                                  if (u8NewHeatSetpoint != u8HeatSetpoint)
00B41C  208B91     MOV #0x8B9, W1
00B41E  784091     MOV.B [W1], W1
00B420  BFC8B8     MOV.B u8HeatSetpoint, WREG
00B422  50CF80     SUB.B W1, W0, [W15]
00B424  32000A     BRA Z, .L71
1054:                                  {
1055:                                      clear_indicator(heat_sp_min_x, heat_sp_min_y, heat_sp_max_x, heat_sp_max_y);
00B426  8044C3     MOV heat_sp_max_y, W3
00B428  8044B2     MOV heat_sp_max_x, W2
00B42A  8044A1     MOV heat_sp_min_y, W1
00B42C  804490     MOV heat_sp_min_x, W0
00B42E  07EAC6     RCALL clear_indicator
1056:                                      //TODO: Write updated setpoint to FRAM  
1057:                                      u8HeatSetpoint = u8NewHeatSetpoint;
00B430  BFC8B9     MOV.B u8NewHeatSetpoint, WREG
00B432  B7E8B8     MOV.B WREG, u8HeatSetpoint
1058:                                      draw_heat_sp_indicator(u8HeatSetpoint);
00B434  BFC8B8     MOV.B u8HeatSetpoint, WREG
00B436  FB8000     ZE W0, W0
00B438  07EC63     RCALL draw_heat_sp_indicator
1059:                                  }
1060:                                  if (u8NewCoolSetpoint != u8CoolSetpoint)
00B43A  208B61     MOV #0x8B6, W1
00B43C  784091     MOV.B [W1], W1
00B43E  BFC8B5     MOV.B u8CoolSetpoint, WREG
00B440  50CF80     SUB.B W1, W0, [W15]
00B442  32000A     BRA Z, .L67
1061:                                  {
1062:                                      clear_indicator(cool_sp_min_x, cool_sp_min_y, cool_sp_max_x, cool_sp_max_y);
00B444  804483     MOV cool_sp_max_y, W3
00B446  804472     MOV cool_sp_max_x, W2
00B448  804461     MOV cool_sp_min_y, W1
00B44A  804450     MOV cool_sp_min_x, W0
00B44C  07EAB7     RCALL clear_indicator
1063:                                      //TODO:  Write updated setpoint to FRAM  
1064:                                      u8CoolSetpoint = u8NewCoolSetpoint;
00B44E  BFC8B6     MOV.B u8NewCoolSetpoint, WREG
00B450  B7E8B5     MOV.B WREG, u8CoolSetpoint
1065:                                      draw_cool_sp_indicator(u8CoolSetpoint);
00B452  BFC8B5     MOV.B u8CoolSetpoint, WREG
00B454  FB8000     ZE W0, W0
00B456  07EC80     RCALL draw_cool_sp_indicator
1066:                                  }
1067:                              }
1068:              
1069:                              battVoltage = ReadBatteryVoltage(); //low battery below 2400
00B458  07F0C7     RCALL ReadBatteryVoltage
00B45A  780F00     MOV W0, [W14]
1070:                              if (battVoltage < 2400) // i.e. less than 2.4 V
00B45C  2095F0     MOV #0x95F, W0
00B45E  78009E     MOV [W14], W1
00B460  508F80     SUB W1, W0, [W15]
00B462  3E000A     BRA GTU, .L72
1071:                              {
1072:                                  // user needs to replace battery, draw battery icon
1073:                                  if (u8BatteryOnScreen == 0)
00B464  BFC8C5     MOV.B u8BatteryOnScreen, WREG
00B466  E00400     CP0.B W0
00B468  3A000F     BRA NZ, .L73
1074:                                  {
1075:                                      epaper_on();
00B46A  07E7F2     RCALL epaper_on
1076:                                      epaper_draw_battery(1);
00B46C  B3C010     MOV.B #0x1, W0
00B46E  07EEEF     RCALL epaper_draw_battery
1077:                                      epaper_off();
00B470  07E7F9     RCALL epaper_off
1078:                                      u8BatteryOnScreen = 1;
00B472  B3C010     MOV.B #0x1, W0
00B474  B7E8C5     MOV.B WREG, u8BatteryOnScreen
00B476  370008     BRA .L73
1079:                                  }
1080:                              }
1081:                              else 
1082:                              {
1083:                                  if (u8BatteryOnScreen == 1)
00B478  BFC8C5     MOV.B u8BatteryOnScreen, WREG
00B47A  504FE1     SUB.B W0, #0x1, [W15]
00B47C  3A0005     BRA NZ, .L73
1084:                                  {
1085:                                      epaper_on();
00B47E  07E7E8     RCALL epaper_on
1086:                                      epaper_draw_battery(0);
00B480  EB4000     CLR.B W0
00B482  07EEE5     RCALL epaper_draw_battery
1087:                                      epaper_off();
00B484  07E7EF     RCALL epaper_off
1088:                                      u8BatteryOnScreen = 0;
00B486  EF68C5     CLR.B u8BatteryOnScreen
1089:                                  }
1090:                              }
1091:                              
1092:                              if (u8ApplicationState == (uint8_t) APP_STATE_ON )
00B488  BFC8B4     MOV.B u8ApplicationState, WREG
00B48A  504FE1     SUB.B W0, #0x1, [W15]
00B48C  3A0084     BRA NZ, .L84
1093:                              {
1094:                                  ExecuteSchedule();
00B48E  07F456     RCALL ExecuteSchedule
1095:                                  if (u8CurrentThermostatAction == (uint8_t) ACTION_HEATING) 
00B490  BFC8C2     MOV.B u8CurrentThermostatAction, WREG
00B492  504FE1     SUB.B W0, #0x1, [W15]
00B494  3A001A     BRA NZ, .L75
1096:                                  {
1097:                                      if (  (u8CurrentTemperature >= (u8HeatSetpoint + u8Hysteresis)) ||
00B496  BFC8C0     MOV.B u8CurrentTemperature, WREG
00B498  FB8080     ZE W0, W1
00B49A  BFC8B8     MOV.B u8HeatSetpoint, WREG
00B49C  FB8100     ZE W0, W2
00B49E  BFC8BB     MOV.B u8Hysteresis, WREG
00B4A0  FB8000     ZE W0, W0
00B4A2  410000     ADD W2, W0, W0
00B4A4  508F80     SUB W1, W0, [W15]
00B4A6  3D0003     BRA GE, .L76
00B4AA  504FE2     SUB.B W0, #0x2, [W15]
00B4AC  3A0069     BRA NZ, .L77
1098:                                             (u8ThermostatMode == MODE_COOL_ONLY) ) // this condition could be triggered by changing the mode in ble comms
00B4A8  BFC8BE     MOV.B u8ThermostatMode, WREG
1099:                                      {
1100:                                          u8CurrentThermostatAction = (uint8_t) ACTION_NONE;
00B4AE  B3C030     MOV.B #0x3, W0
00B4B0  B7E8C2     MOV.B WREG, u8CurrentThermostatAction
1101:                                          // turn off heating relay
1102:                                          Heat_off();
00B4B2  07F284     RCALL Heat_off
1103:                                          Fan_off();
00B4B4  07F2A3     RCALL Fan_off
1104:                                          WriteRuntimeBuffer();
00B4B6  07E26F     RCALL WriteRuntimeBuffer
1105:                                          if (u8ActionOnScreen == 1)
00B4B8  BFC8C4     MOV.B u8ActionOnScreen, WREG
00B4BA  504FE1     SUB.B W0, #0x1, [W15]
00B4BC  3A0061     BRA NZ, .L77
1106:                                          {
1107:                                              epaper_on();
00B4BE  07E7C8     RCALL epaper_on
1108:                                              epaper_draw_heatcool(DISPLAY_ACTION_NONE);
00B4C0  B3C020     MOV.B #0x2, W0
00B4C2  07EE30     RCALL epaper_draw_heatcool
1109:                                              epaper_off();
00B4C4  07E7CF     RCALL epaper_off
1110:                                              u8ActionOnScreen = 0;
00B4C6  EF68C4     CLR.B u8ActionOnScreen
00B4C8  37005B     BRA .L77
1111:                                          }
1112:                                      }
1113:                                  }
1114:                                  else if (u8CurrentThermostatAction == (uint8_t) ACTION_COOLING )
00B4CA  BFC8C2     MOV.B u8CurrentThermostatAction, WREG
00B4CC  504FE2     SUB.B W0, #0x2, [W15]
00B4CE  3A001A     BRA NZ, .L78
1115:                                  {
1116:                                      if ( (u8CurrentTemperature <= (u8CoolSetpoint - u8Hysteresis)) || 
00B4D0  BFC8C0     MOV.B u8CurrentTemperature, WREG
00B4D2  FB8080     ZE W0, W1
00B4D4  BFC8B5     MOV.B u8CoolSetpoint, WREG
00B4D6  FB8100     ZE W0, W2
00B4D8  BFC8BB     MOV.B u8Hysteresis, WREG
00B4DA  FB8000     ZE W0, W0
00B4DC  510000     SUB W2, W0, W0
00B4DE  508F80     SUB W1, W0, [W15]
00B4E0  340003     BRA LE, .L79
00B4E4  504FE1     SUB.B W0, #0x1, [W15]
00B4E6  3A004C     BRA NZ, .L77
1117:                                            (u8ThermostatMode == MODE_HEAT_ONLY) ) // this would happen if there is a mode change
00B4E2  BFC8BE     MOV.B u8ThermostatMode, WREG
1118:                                      {
1119:                                          u8CurrentThermostatAction = (uint8_t)ACTION_NONE;
00B4E8  B3C030     MOV.B #0x3, W0
00B4EA  B7E8C2     MOV.B WREG, u8CurrentThermostatAction
1120:                                          // turn off cooling relay
1121:                                          Cool_off();
00B4EC  07F277     RCALL Cool_off
1122:                                          Fan_off();
00B4EE  07F286     RCALL Fan_off
1123:                                          WriteRuntimeBuffer();
00B4F0  07E252     RCALL WriteRuntimeBuffer
1124:                                          if (u8ActionOnScreen == 1)
00B4F2  BFC8C4     MOV.B u8ActionOnScreen, WREG
00B4F4  504FE1     SUB.B W0, #0x1, [W15]
00B4F6  3A0044     BRA NZ, .L77
1125:                                          {
1126:                                              epaper_on();
00B4F8  07E7AB     RCALL epaper_on
1127:                                              epaper_draw_heatcool(DISPLAY_ACTION_NONE);
00B4FA  B3C020     MOV.B #0x2, W0
00B4FC  07EE13     RCALL epaper_draw_heatcool
1128:                                              epaper_off();
00B4FE  07E7B2     RCALL epaper_off
1129:                                              u8ActionOnScreen = 0;
00B500  EF68C4     CLR.B u8ActionOnScreen
00B502  37003E     BRA .L77
1130:                                          }
1131:                                      }
1132:                                  }
1133:                                  else if (u8CurrentThermostatAction == (uint8_t) ACTION_NONE)
00B504  BFC8C2     MOV.B u8CurrentThermostatAction, WREG
00B506  504FE3     SUB.B W0, #0x3, [W15]
00B508  3A003B     BRA NZ, .L77
1134:                                  {
1135:                                      if ( (u8CurrentTemperature < (u8HeatSetpoint - u8Hysteresis) ) && 
00B50A  BFC8C0     MOV.B u8CurrentTemperature, WREG
00B50C  FB8080     ZE W0, W1
00B50E  BFC8B8     MOV.B u8HeatSetpoint, WREG
00B510  FB8100     ZE W0, W2
00B512  BFC8BB     MOV.B u8Hysteresis, WREG
00B514  FB8000     ZE W0, W0
00B516  510000     SUB W2, W0, W0
00B518  508F80     SUB W1, W0, [W15]
00B51A  3D0015     BRA GE, .L80
00B51E  504FE3     SUB.B W0, #0x3, [W15]
00B520  320003     BRA Z, .L81
1136:                                              ( (u8ThermostatMode == MODE_HEATCOOL ) || (u8ThermostatMode == MODE_HEAT_ONLY) )
00B51C  BFC8BE     MOV.B u8ThermostatMode, WREG
00B522  BFC8BE     MOV.B u8ThermostatMode, WREG
00B524  504FE1     SUB.B W0, #0x1, [W15]
00B526  3A000F     BRA NZ, .L80
1137:                                          )
1138:                                          
1139:                                      {
1140:                                          u8CurrentThermostatAction = (uint8_t) ACTION_HEATING;
00B528  B3C010     MOV.B #0x1, W0
00B52A  B7E8C2     MOV.B WREG, u8CurrentThermostatAction
1141:                                          // TURN ON RELAY TO HEAT
1142:                                          Heat_on();
00B52C  07F24F     RCALL Heat_on
1143:                                          Fan_on();
00B52E  07F26E     RCALL Fan_on
1144:                                          WriteRuntimeBuffer();
00B530  07E232     RCALL WriteRuntimeBuffer
1145:                                          if (u8ActionOnScreen == 0)
00B532  BFC8C4     MOV.B u8ActionOnScreen, WREG
00B534  E00400     CP0.B W0
00B536  3A0024     BRA NZ, .L77
00B544  37001D     BRA .L77
1146:                                          {
1147:                                              epaper_on();
00B538  07E78B     RCALL epaper_on
1148:                                              epaper_draw_heatcool(DISPLAY_ACTION_HEAT);
00B53A  B3C010     MOV.B #0x1, W0
00B53C  07EDF3     RCALL epaper_draw_heatcool
1149:                                              epaper_off();
00B53E  07E792     RCALL epaper_off
1150:                                              u8ActionOnScreen = 1;
00B540  B3C010     MOV.B #0x1, W0
00B542  B7E8C4     MOV.B WREG, u8ActionOnScreen
1151:                                          }
1152:                                          
1153:                                      } 
1154:                                      else if ( (u8CurrentTemperature > (u8CoolSetpoint + u8Hysteresis) ) &&
00B546  BFC8C0     MOV.B u8CurrentTemperature, WREG
00B548  FB8080     ZE W0, W1
00B54A  BFC8B5     MOV.B u8CoolSetpoint, WREG
00B54C  FB8100     ZE W0, W2
00B54E  BFC8BB     MOV.B u8Hysteresis, WREG
00B550  FB8000     ZE W0, W0
00B552  410000     ADD W2, W0, W0
00B554  508F80     SUB W1, W0, [W15]
00B556  340014     BRA LE, .L77
00B55A  504FE3     SUB.B W0, #0x3, [W15]
00B55C  320003     BRA Z, .L83
1155:                                                  ( (u8ThermostatMode == MODE_HEATCOOL) || (u8ThermostatMode == MODE_COOL_ONLY) ) 
00B558  BFC8BE     MOV.B u8ThermostatMode, WREG
00B55E  BFC8BE     MOV.B u8ThermostatMode, WREG
00B560  504FE2     SUB.B W0, #0x2, [W15]
00B562  3A000E     BRA NZ, .L77
1156:                                              )
1157:                                      {
1158:                                          u8CurrentThermostatAction = (uint8_t) ACTION_COOLING;
00B564  B3C020     MOV.B #0x2, W0
00B566  B7E8C2     MOV.B WREG, u8CurrentThermostatAction
1159:                                          // TURN ON RELAY TO cool
1160:                                          Cool_on();
00B568  07F241     RCALL Cool_on
1161:                                          Fan_on();
00B56A  07F250     RCALL Fan_on
1162:                                          WriteRuntimeBuffer();
00B56C  07E214     RCALL WriteRuntimeBuffer
1163:                                          if (u8ActionOnScreen == 0)
00B56E  BFC8C4     MOV.B u8ActionOnScreen, WREG
00B570  E00400     CP0.B W0
00B572  3A0006     BRA NZ, .L77
1164:                                          {
1165:                                              epaper_on();
00B574  07E76D     RCALL epaper_on
1166:                                              epaper_draw_heatcool(DISPLAY_ACTION_COOL);
00B576  EB4000     CLR.B W0
00B578  07EDD5     RCALL epaper_draw_heatcool
1167:                                              epaper_off();
00B57A  07E774     RCALL epaper_off
1168:                                              u8ActionOnScreen = 1;
00B57C  B3C010     MOV.B #0x1, W0
00B57E  B7E8C4     MOV.B WREG, u8ActionOnScreen
1169:                                          }
1170:                                      }
1171:                                  }
1172:                                  // decrement timer and turn off
1173:                                  if (u8TimerMinutesToOff > 0)
00B580  BFC8C3     MOV.B u8TimerMinutesToOff, WREG
00B582  E00400     CP0.B W0
00B584  320008     BRA Z, .L84
1174:                                  {
1175:                                      u8TimerMinutesToOff --;
00B586  BFC8C3     MOV.B u8TimerMinutesToOff, WREG
00B588  E94000     DEC.B W0, W0
00B58A  B7E8C3     MOV.B WREG, u8TimerMinutesToOff
1176:                                      if (u8TimerMinutesToOff == 0)
00B58C  BFC8C3     MOV.B u8TimerMinutesToOff, WREG
00B58E  E00400     CP0.B W0
00B590  3A0002     BRA NZ, .L84
1177:                                      {
1178:                                          u8ApplicationState = (uint8_t)APP_STATE_OFF;
00B592  B3C020     MOV.B #0x2, W0
00B594  B7E8B4     MOV.B WREG, u8ApplicationState
1179:                                          if (u8Schedule == SCHEDULE_HOME)
1180:                                          {
1181:                                              //WriteScheduleMode(0,0,0);
1182:                                          }
1183:                                          else if (u8Schedule == SCHEDULE_DREVENT)
1184:                                          {
1185:                                              //WriteScheduleMode(0xFF, 0xFF, 0xFF);
1186:                                          }
1187:                                          else if (u8Schedule == SCHEDULE_NONE)
1188:                                          {
1189:                                              //WriteScheduleMode(0x0F, 0x0F, 0x0F);
1190:                                          }
1191:                                          else
1192:                                          {
1193:                                              //WriteScheduleMode(SCHEDULE_AWAY, u8CoolSetpoint, u8HeatSetpoint);
1194:                                          }
1195:                                      }
1196:                                  }
1197:              
1198:                              }
1199:                              else if (u8ApplicationState == (uint8_t) APP_STATE_OFF)
1200:                              {
1201:                                  // nothing to do here
1202:                              }
1203:                              else if (u8ApplicationState == (uint8_t) APP_STATE_TIMER)
1204:                              {
1205:                                  // 
1206:                              }
1207:                              else 
1208:                              {
1209:                                  // do nothing
1210:                                  // code should never reach here
1211:                              }
1212:                              if (tmp_app_state != u8ApplicationState)
1213:                              {
1214:                                  //WriteApplicationState();
1215:                                  // state change occurred
1216:                                  // TODO: state change actions to be done here
1217:                              }
1218:                              goto_sleep_immediate = true;
00B596  B3C010     MOV.B #0x1, W0
00B598  984770     MOV.B W0, [W14+7]
1219:                          }
1220:                          
1221:                          
1222:                          if ( ( goto_sleep_immediate == true) || (u16Timer3Tick1s >= u16activityTimeout) )
00B59A  90407E     MOV.B [W14+7], W0
00B59C  E00400     CP0.B W0
00B59E  3A0004     BRA NZ, .L85
00B5A0  804751     MOV u16Timer3Tick1s, W1
00B5A2  90006E     MOV [W14+12], W0
00B5A4  508F80     SUB W1, W0, [W15]
00B5A6  390003     BRA NC, .L86
1223:                          {
1224:                              RTCC_AlarmEnable(3);
00B5A8  B3C030     MOV.B #0x3, W0
00B5AA  070CCD     RCALL RTCC_AlarmEnable
1225:                              u8CurrentState = STATE_SLEEP;
00B5AC  EF68B0     CLR.B u8CurrentState
1226:                          }
1227:                          
1228:                          //If a phone is connected, go to connected state
1229:                          if (BLE_Connected)
00B5AE  BFC90B     MOV.B BLE_Connected, WREG
00B5B0  E00400     CP0.B W0
00B5B2  320002     BRA Z, .L39
1230:                          {
1231:                              u8CurrentState = STATE_CONNECT;                
00B5B4  B3C010     MOV.B #0x1, W0
00B5B6  B7E8B0     MOV.B WREG, u8CurrentState
1232:                          }
1233:                      }
1234:                       
1235:                      
1236:                  } //END APPLICATION LOOP
00B5BE  000000     NOP
00B5C0  37FC46     BRA .L8
1237:                  
1238:                  return 1;
1239:              }
1240:              
1241:              
---  C:/Users/pvan002/Box Sync/low_income_thermostats/lita_sw/R1/epaper.c  ------------------------------
1:                 /* 
2:                  * File:   epaper.c
3:                  * Author: Viswanath
4:                  *
5:                  * Created on January 21, 2019, 7:12 AM
6:                  */
7:                 
8:                 #include <xc.h>
9:                 #include "main.h"
10:                #include "hal.h"
11:                #include "epaper.h"
12:                
13:                // global vars
14:                 int vert_x[]; // (0) vertex a, (1)vertex b, (2) vertex c vertices of triangle
15:                int vert_y[]; // (0) vertex a, (1)vertex b, (2) vertex c vertices of triangle
16:                int b_vert_x[]; // bounding rectangle x coords for triangle drawn by vertices
17:                int b_vert_y[]; // bounding rectangle y coords for triangle drawn by vertices
18:                int line_x[];
19:                int line_y[];
20:                int thick_line_x[];
21:                int thick_line_y[];
22:                int u_rect_x[];
23:                int u_rect_y[];
24:                int digit_pos_x[];
25:                int digit_pos_y[];
26:                int d_pt[];
27:                int d_pt_count;
28:                int up_screen_b[];
29:                int action_pos_x=96;
30:                int action_pos_y=172;
31:                int batt_pos_x = 30;
32:                int batt_pos_y = 166;
33:                int cool_sp_min_x;
34:                int cool_sp_min_y;
35:                int cool_sp_max_x;
36:                int cool_sp_max_y;
37:                int heat_sp_min_x;
38:                int heat_sp_min_y;
39:                int heat_sp_max_x;
40:                int heat_sp_max_y;
41:                int temperature_min_x;
42:                int temperature_min_y;
43:                int temperature_max_x;
44:                int temperature_max_y;
45:                int draw_rect_min_x;
46:                int draw_rect_min_y;
47:                int draw_rect_max_x;
48:                int draw_rect_max_y;
49:                int timer_icon_x = 2;
50:                int timer_icon_y = 2;
51:                
52:                
53:                static const uint8_t Mono_1BPP[] =
54:                  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
55:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
56:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
57:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
58:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
59:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
60:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
61:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
62:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
63:                   0x00,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
64:                   0x00,0x00,0x00,0x00,0x38,0x0F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
65:                   0x00,0x00,0x00,0x00,0x38,0x0F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
66:                   0x00,0x00,0x00,0x00,0x38,0x0E,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
67:                   0x00,0x00,0x00,0x00,0x38,0x0C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
68:                   0x00,0x00,0x00,0x00,0x38,0x0C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
69:                   0x00,0x00,0x00,0x00,0x38,0x1C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
70:                   0x00,0x00,0x00,0x00,0x3C,0x1C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
71:                   0x00,0x00,0x00,0x00,0x1E,0x7C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
72:                   0x00,0x00,0x00,0x00,0x1F,0xFC,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
73:                   0x00,0x00,0x00,0x00,0x0F,0xF8,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
74:                   0x00,0x00,0x00,0x00,0x07,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
75:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
76:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
77:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
78:                   0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
79:                   0x00,0x00,0x00,0x00,0x07,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
80:                   0x00,0x00,0x00,0x00,0x1F,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
81:                   0x00,0x00,0x00,0x00,0x1F,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
82:                   0x00,0x00,0x00,0x00,0x3C,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
83:                   0x00,0x00,0x00,0x00,0x38,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
84:                   0x00,0x00,0x00,0x00,0x38,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
85:                   0x00,0x00,0x00,0x00,0x38,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
86:                   0x00,0x00,0x00,0x00,0x38,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
87:                   0x00,0x00,0x00,0x00,0x3C,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
88:                   0x00,0x00,0x00,0x00,0x1F,0xC3,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
89:                   0x00,0x00,0x00,0x00,0x1F,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
90:                   0x00,0x00,0x00,0x00,0x07,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
91:                   0x00,0x00,0x00,0x00,0x01,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
92:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
93:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
94:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
95:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
96:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
97:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
98:                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
99:                   0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
100:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
101:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
102:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
103:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x08,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
104:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x08,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
105:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x08,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
106:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x08,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
107:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x10,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
108:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x10,0x00,0x80,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
109:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x10,0x00,0x80,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
110:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
111:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
112:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
113:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
114:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
115:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
116:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
117:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
118:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
119:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
120:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
121:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
122:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
123:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
124:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
125:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
126:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
127:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
128:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
129:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
130:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
131:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
132:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
133:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
134:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
135:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
136:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
137:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
138:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
139:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
140:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
141:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
142:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
143:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
144:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
145:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
146:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,
147:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,
148:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
149:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
150:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
151:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
152:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
153:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
154:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
155:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
156:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
157:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
158:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x00,
159:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,0x00,0x00,
160:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,
161:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,
162:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
163:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
164:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
165:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
166:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
167:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
168:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
169:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
170:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
171:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,
172:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xF0,0x00,0x00,0x00,0x00,0x00,
173:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,
174:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
175:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
176:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
177:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
178:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
179:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
180:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
181:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
182:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
183:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
184:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
185:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0x00,0x00,0x00,0x00,0x00,
186:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
187:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
188:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
189:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
190:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
191:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
192:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
193:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
194:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
195:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
196:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,
197:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xF0,0x00,0x00,0x00,0x00,0x00,
198:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,
199:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
200:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
201:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
202:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
203:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
204:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
205:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
206:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
207:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
208:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,
209:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,
210:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,0x00,0x00,
211:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x00,
212:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
213:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
214:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
215:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
216:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
217:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
218:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
219:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
220:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
221:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
222:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,
223:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,
224:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
225:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
226:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
227:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
228:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
229:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
230:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
231:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
232:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
233:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
234:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
235:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
236:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
237:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
238:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
239:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
240:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
241:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
242:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
243:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
244:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
245:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
246:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
247:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
248:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
249:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
250:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
251:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
252:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
253:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
254:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
255:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
256:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
257:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
258:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
259:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
260:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x80,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
261:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x10,0x00,0x80,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
262:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x10,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
263:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x08,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
264:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x08,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
265:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x08,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
266:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x08,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
267:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
268:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
269:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
270:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
271:                  0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
272:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
273:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
274:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
275:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
276:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
277:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
278:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
279:                  0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
280:                  0x00,0x00,0x00,0x00,0x03,0x03,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
281:                  0x00,0x00,0x00,0x00,0x07,0x03,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
282:                  0x00,0x00,0x00,0x00,0x07,0x07,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
283:                  0x00,0x00,0x00,0x00,0x06,0x07,0x07,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
284:                  0x00,0x00,0x00,0x00,0x06,0x07,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
285:                  0x00,0x00,0x00,0x00,0x07,0x06,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
286:                  0x00,0x00,0x00,0x00,0x07,0x06,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
287:                  0x00,0x00,0x00,0x00,0x07,0x87,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
288:                  0x00,0x00,0x00,0x00,0x03,0xC3,0x07,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
289:                  0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
290:                  0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
291:                  0x00,0x00,0x00,0x00,0x00,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
292:                  0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
293:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
294:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
295:                  0x00,0x00,0x00,0x00,0x00,0x1F,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
296:                  0x00,0x00,0x00,0x00,0x00,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
297:                  0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
298:                  0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
299:                  0x00,0x00,0x00,0x00,0x07,0x80,0x07,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
300:                  0x00,0x00,0x00,0x00,0x07,0x00,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
301:                  0x00,0x00,0x00,0x00,0x07,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
302:                  0x00,0x00,0x00,0x00,0x07,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
303:                  0x00,0x00,0x00,0x00,0x07,0x00,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
304:                  0x00,0x00,0x00,0x00,0x07,0x80,0x07,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
305:                  0x00,0x00,0x00,0x00,0x03,0xF8,0x7F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
306:                  0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
307:                  0x00,0x00,0x00,0x00,0x00,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
308:                  0x00,0x00,0x00,0x00,0x00,0x3F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
309:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
310:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
311:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
312:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
313:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
314:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
315:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
316:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
317:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
318:               
319:               static const uint8_t Red_1BPP[] =
320:                 {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
321:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
322:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
323:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
324:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
325:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
326:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
327:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
328:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
329:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
330:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
331:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
332:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
333:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
334:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
335:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
336:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
337:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
338:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
339:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
340:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
341:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
342:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
343:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
344:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
345:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
346:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
347:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
348:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
349:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
350:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
351:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
352:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
353:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
354:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
355:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
356:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
357:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
358:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
359:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
360:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
361:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
362:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
363:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
364:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
365:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
366:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
367:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
368:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
369:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
370:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
371:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
372:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
373:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
374:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
375:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
376:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
377:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
378:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
379:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
380:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
381:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
382:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
383:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
384:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
385:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
386:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
387:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
388:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
389:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
390:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
391:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
392:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
393:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
394:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
395:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
396:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
397:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
398:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
399:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
400:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
401:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
402:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
403:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
404:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
405:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
406:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
407:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
408:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
409:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
410:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
411:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
412:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
413:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
414:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
415:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
416:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
417:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
418:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
419:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
420:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
421:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
422:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
423:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
424:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
425:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
426:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
427:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
428:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
429:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
430:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
431:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
432:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
433:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
434:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
435:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
436:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
437:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
438:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
439:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
440:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
441:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
442:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
443:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
444:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
445:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
446:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
447:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
448:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
449:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
450:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
451:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
452:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
453:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
454:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
455:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
456:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
457:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
458:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
459:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
460:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
461:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
462:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
463:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
464:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
465:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
466:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
467:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
468:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
469:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
470:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
471:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
472:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
473:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
474:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
475:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
476:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
477:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
478:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
479:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
480:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
481:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
482:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
483:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
484:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
485:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
486:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
487:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
488:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
489:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
490:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
491:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
492:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
493:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
494:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
495:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
496:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
497:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
498:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
499:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
500:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
501:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
502:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
503:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
504:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
505:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
506:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
507:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
508:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
509:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
510:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
511:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
512:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
513:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
514:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
515:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
516:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
517:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
518:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
519:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
520:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
521:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
522:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
523:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
524:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
525:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
526:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
527:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
528:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
529:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
530:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
531:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
532:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
533:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
534:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
535:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
536:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
537:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
538:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
539:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
540:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
541:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
542:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
543:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
544:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
545:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
546:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
547:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
548:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
549:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
550:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
551:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
552:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
553:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
554:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
555:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
556:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
557:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
558:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
559:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
560:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
561:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
562:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
563:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
564:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
565:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
566:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
567:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
568:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
569:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
570:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
571:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
572:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
573:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
574:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
575:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
576:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
577:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
578:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
579:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
580:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
581:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
582:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
583:                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
584:               
585:               static unsigned char Mono_Letter_0[] = {
586:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
587:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
588:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
589:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
590:                   0x00, 0x03, 0xFF, 0xE0, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00, 
591:                   0x00, 0x1F, 0xFF, 0xFC, 0x00, 0x00, 0x3F, 0xFF, 0xFE, 0x00, 
592:                   0x00, 0x7F, 0xFF, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0x00, 
593:                   0x00, 0x7C, 0x00, 0x1F, 0x00, 0x00, 0x78, 0x00, 0x0F, 0x00, 
594:                   0x00, 0x78, 0x00, 0x0F, 0x00, 0x00, 0x7E, 0x00, 0x3F, 0x00, 
595:                   0x00, 0x7F, 0xFF, 0xFF, 0x00, 0x00, 0x3F, 0xFF, 0xFE, 0x00, 
596:                   0x00, 0x3F, 0xFF, 0xFE, 0x00, 0x00, 0x1F, 0xFF, 0xFC, 0x00, 
597:                   0x00, 0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x01, 0xFF, 0xC0, 0x00, 
598:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
599:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
600:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
601:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
602:               
603:               };
604:               
605:               static unsigned char Mono_Letter_1[] = {
606:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
607:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
608:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
609:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
610:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x00, 
611:                   0x00, 0x00, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x00, 
612:                   0x00, 0x00, 0x01, 0xF0, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x00, 
613:                   0x00, 0x7F, 0xFF, 0xFC, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0x00, 
614:                   0x00, 0x7F, 0xFF, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0x00, 
615:                   0x00, 0x7F, 0xFF, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0x00, 
616:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
617:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
618:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
619:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
620:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
621:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
622:               
623:               };
624:               
625:               static unsigned char Mono_Letter_2[] = {
626:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
627:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
628:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
629:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
630:                   0x00, 0x78, 0x00, 0x78, 0x00, 0x00, 0x7E, 0x00, 0x7C, 0x00, 
631:                   0x00, 0x7F, 0x00, 0x7E, 0x00, 0x00, 0x7F, 0x80, 0x7E, 0x00, 
632:                   0x00, 0x7F, 0xC0, 0x7F, 0x00, 0x00, 0x7F, 0xE0, 0x7F, 0x00, 
633:                   0x00, 0x7F, 0xF0, 0x1F, 0x00, 0x00, 0x7B, 0xF8, 0x0F, 0x00, 
634:                   0x00, 0x79, 0xFC, 0x0F, 0x00, 0x00, 0x78, 0xFE, 0x1F, 0x00, 
635:                   0x00, 0x78, 0x7F, 0xFF, 0x00, 0x00, 0x78, 0x3F, 0xFF, 0x00, 
636:                   0x00, 0x78, 0x3F, 0xFE, 0x00, 0x00, 0x78, 0x1F, 0xFE, 0x00, 
637:                   0x00, 0x78, 0x07, 0xFC, 0x00, 0x00, 0x78, 0x01, 0xF0, 0x00, 
638:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
639:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
640:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
641:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
642:               
643:               };
644:               
645:               static unsigned char Mono_Letter_3[] = {
646:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
647:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
648:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
649:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
650:                   0x00, 0x07, 0x00, 0x20, 0x00, 0x00, 0x1F, 0x00, 0x78, 0x00, 
651:                   0x00, 0x3F, 0x00, 0x7E, 0x00, 0x00, 0x3F, 0x00, 0x7E, 0x00, 
652:                   0x00, 0x7F, 0x00, 0x7F, 0x00, 0x00, 0x7F, 0x08, 0x7F, 0x00, 
653:                   0x00, 0x7C, 0x0E, 0x1F, 0x00, 0x00, 0x78, 0x0E, 0x0F, 0x00, 
654:                   0x00, 0x78, 0x0F, 0x1F, 0x00, 0x00, 0x7C, 0x1F, 0xFF, 0x00, 
655:                   0x00, 0x7F, 0xFF, 0xFF, 0x00, 0x00, 0x3F, 0xFF, 0xFE, 0x00, 
656:                   0x00, 0x3F, 0xFB, 0xFE, 0x00, 0x00, 0x1F, 0xF9, 0xFC, 0x00, 
657:                   0x00, 0x0F, 0xF0, 0xF8, 0x00, 0x00, 0x07, 0xE0, 0x00, 0x00, 
658:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
659:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
660:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
661:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
662:               
663:               };
664:               
665:               static  unsigned char Mono_Letter_4[] = {
666:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
667:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
668:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
669:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x00, 0x00, 
670:                   0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x03, 0xFC, 0x00, 0x00, 
671:                   0x00, 0x03, 0xFE, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x80, 0x00, 
672:                   0x00, 0x03, 0xFF, 0xC0, 0x00, 0x00, 0x03, 0xDF, 0xF0, 0x00, 
673:                   0x00, 0x03, 0xC7, 0xF8, 0x00, 0x00, 0x03, 0xC3, 0xFC, 0x00, 
674:                   0x00, 0x7F, 0xFF, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0x00, 
675:                   0x00, 0x7F, 0xFF, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0x00, 
676:                   0x00, 0x7F, 0xFF, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0x00, 
677:                   0x00, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 
678:                   0x00, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
679:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
680:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
681:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
682:               
683:               };
684:               
685:               static  unsigned char Mono_Letter_5[] = {
686:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
687:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
688:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
689:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
690:                   0x00, 0x07, 0x0C, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0xF0, 0x00, 
691:                   0x00, 0x3F, 0x1F, 0xFF, 0x00, 0x00, 0x3F, 0x1F, 0xFF, 0x00, 
692:                   0x00, 0x7F, 0x1F, 0xFF, 0x00, 0x00, 0x7F, 0x1F, 0xFF, 0x00, 
693:                   0x00, 0x7C, 0x0F, 0xFF, 0x00, 0x00, 0x78, 0x07, 0x8F, 0x00, 
694:                   0x00, 0x78, 0x07, 0x8F, 0x00, 0x00, 0x7C, 0x0F, 0x8F, 0x00, 
695:                   0x00, 0x7F, 0xFF, 0x8F, 0x00, 0x00, 0x7F, 0xFF, 0x8F, 0x00, 
696:                   0x00, 0x3F, 0xFF, 0x0F, 0x00, 0x00, 0x1F, 0xFF, 0x0F, 0x00, 
697:                   0x00, 0x0F, 0xFE, 0x0F, 0x00, 0x00, 0x07, 0xF8, 0x00, 0x00, 
698:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
699:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
700:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
701:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
702:               
703:               };
704:               
705:               static unsigned char Mono_Letter_6[] = {
706:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
707:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
708:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
709:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
710:                   0x00, 0x03, 0xFF, 0xE0, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00, 
711:                   0x00, 0x1F, 0xFF, 0xFC, 0x00, 0x00, 0x3F, 0xFF, 0xFE, 0x00, 
712:                   0x00, 0x3F, 0xFF, 0xFE, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0x00, 
713:                   0x00, 0x7C, 0x3E, 0x3F, 0x00, 0x00, 0x78, 0x1E, 0x1F, 0x00, 
714:                   0x00, 0x78, 0x1E, 0x0F, 0x00, 0x00, 0x7C, 0x3E, 0x1F, 0x00, 
715:                   0x00, 0x7F, 0xFE, 0x7F, 0x00, 0x00, 0x7F, 0xFE, 0x7F, 0x00, 
716:                   0x00, 0x3F, 0xFC, 0x7E, 0x00, 0x00, 0x3F, 0xFC, 0x7E, 0x00, 
717:                   0x00, 0x1F, 0xF8, 0x78, 0x00, 0x00, 0x0F, 0xF0, 0x60, 0x00, 
718:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
719:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
720:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
721:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
722:               
723:               };
724:               
725:                static unsigned char Mono_Letter_7[] = {
726:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
727:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
728:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
729:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
730:                   0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 
731:                   0x00, 0x40, 0x00, 0x0F, 0x00, 0x00, 0x7F, 0x00, 0x0F, 0x00, 
732:                   0x00, 0x7F, 0xE0, 0x0F, 0x00, 0x00, 0x7F, 0xF8, 0x0F, 0x00, 
733:                   0x00, 0x7F, 0xFE, 0x0F, 0x00, 0x00, 0x7F, 0xFF, 0x8F, 0x00, 
734:                   0x00, 0x1F, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x00, 
735:                   0x00, 0x00, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 
736:                   0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 
737:                   0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 
738:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
739:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
740:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
741:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
742:               
743:               };
744:               
745:               static unsigned char Mono_Letter_8[] = {
746:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
747:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
748:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
749:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
750:                   0x00, 0x0F, 0xC1, 0xF0, 0x00, 0x00, 0x1F, 0xF3, 0xFC, 0x00, 
751:                   0x00, 0x3F, 0xF7, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xFE, 0x00, 
752:                   0x00, 0x7F, 0xFF, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0x00, 
753:                   0x00, 0x78, 0x3E, 0x0F, 0x00, 0x00, 0x70, 0x1C, 0x07, 0x00, 
754:                   0x00, 0x70, 0x1E, 0x07, 0x00, 0x00, 0x78, 0x3F, 0x1F, 0x00, 
755:                   0x00, 0x7F, 0xFF, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0xFE, 0x00, 
756:                   0x00, 0x3F, 0xF7, 0xFE, 0x00, 0x00, 0x3F, 0xF7, 0xFC, 0x00, 
757:                   0x00, 0x1F, 0xE1, 0xF8, 0x00, 0x00, 0x07, 0xC0, 0x00, 0x00, 
758:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
759:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
760:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
761:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
762:               
763:               };
764:               
765:               static unsigned char Mono_Letter_9[] = {
766:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
767:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
768:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
769:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xE0, 0x00, 
770:                   0x00, 0x07, 0x07, 0xF8, 0x00, 0x00, 0x1F, 0x0F, 0xFC, 0x00, 
771:                   0x00, 0x3F, 0x1F, 0xFE, 0x00, 0x00, 0x3F, 0x3F, 0xFE, 0x00, 
772:                   0x00, 0x7F, 0x3F, 0xFF, 0x00, 0x00, 0x7F, 0x3E, 0x1F, 0x00, 
773:                   0x00, 0x7C, 0x3C, 0x0F, 0x00, 0x00, 0x78, 0x3C, 0x0F, 0x00, 
774:                   0x00, 0x7C, 0x3E, 0x1F, 0x00, 0x00, 0x7F, 0x3F, 0x3F, 0x00, 
775:                   0x00, 0x7F, 0xFF, 0xFF, 0x00, 0x00, 0x3F, 0xFF, 0xFE, 0x00, 
776:                   0x00, 0x1F, 0xFF, 0xFE, 0x00, 0x00, 0x1F, 0xFF, 0xFC, 0x00, 
777:                   0x00, 0x07, 0xFF, 0xF0, 0x00, 0x00, 0x01, 0xFF, 0xC0, 0x00, 
778:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
779:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
780:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
781:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
782:               
783:               };
784:               
785:               #define Cool_HEIGHT_PIXELS    (72)
786:               #define Cool_WIDTH_PIXELS (32)
787:               #define Cool_WIDTH_MONO_BYTES (8)
788:               static unsigned char IMG_Cool[288] = {
789:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
790:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF8, 0x00, 
791:                   0x00, 0x7F, 0xFE, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x01, 0xFF, 
792:                   0xFF, 0x80, 0x03, 0xFF, 0xFF, 0xC0, 0x07, 0xE0, 0x07, 0xE0, 
793:                   0x07, 0xC0, 0x03, 0xE0, 0x0F, 0x80, 0x01, 0xF0, 0x0F, 0x00, 
794:                   0x00, 0xF0, 0x0E, 0x00, 0x00, 0x70, 0x0E, 0x00, 0x00, 0x70, 
795:                   0x0E, 0x00, 0x00, 0x70, 0x0E, 0x00, 0x00, 0x70, 0x0E, 0x00, 
796:                   0x00, 0x70, 0x0F, 0x00, 0x00, 0xF0, 0x0F, 0x80, 0x01, 0xF0, 
797:                   0x07, 0xC0, 0x03, 0xE0, 0x07, 0xF0, 0x0F, 0xE0, 0x03, 0xF8, 
798:                   0x0F, 0xC0, 0x01, 0xF8, 0x07, 0x80, 0x00, 0xF0, 0x07, 0x00, 
799:                   0x00, 0x30, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
800:                   0x00, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x01, 0xFF, 0xE0, 0x00, 
801:                   0x03, 0xFF, 0xF0, 0x00, 0x07, 0xFF, 0xF8, 0x00, 0x0F, 0xC0, 
802:                   0xF8, 0x00, 0x0F, 0x00, 0x3C, 0x00, 0x0F, 0x00, 0x3C, 0x00, 
803:                   0x0E, 0x00, 0x1C, 0x00, 0x0E, 0x00, 0x1C, 0x00, 0x0E, 0x00, 
804:                   0x1C, 0x00, 0x0F, 0x00, 0x3C, 0x00, 0x0F, 0x80, 0x7C, 0x00, 
805:                   0x07, 0xFF, 0xF8, 0x00, 0x07, 0xFF, 0xF8, 0x00, 0x03, 0xFF, 
806:                   0xF0, 0x00, 0x01, 0xFF, 0xE0, 0x00, 0x00, 0x3F, 0x00, 0x00, 
807:                   0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x01, 0xFF, 
808:                   0xE0, 0x00, 0x03, 0xFF, 0xF0, 0x00, 0x07, 0xFF, 0xF8, 0x00, 
809:                   0x0F, 0xC0, 0xF8, 0x00, 0x0F, 0x00, 0x3C, 0x00, 0x0F, 0x00, 
810:                   0x3C, 0x00, 0x0E, 0x00, 0x1C, 0x00, 0x0E, 0x00, 0x1C, 0x00, 
811:                   0x0E, 0x00, 0x1C, 0x00, 0x0F, 0x00, 0x3C, 0x00, 0x0F, 0x80, 
812:                   0x7C, 0x00, 0x07, 0xFF, 0xF8, 0x00, 0x07, 0xFF, 0xF8, 0x00, 
813:                   0x03, 0xFF, 0xF0, 0x00, 0x01, 0xFF, 0xE0, 0x00, 0x00, 0x3F, 
814:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 
815:                   0x0F, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 
816:                   0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 
817:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
818:               };
819:               
820:               #define Heat_HEIGHT_PIXELS    (72)
821:               #define Heat_WIDTH_PIXELS (32)
822:               #define Heat_WIDTH_MONO_BYTES (8)
823:               static unsigned char IMG_Heat[288] = {
824:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
825:                   0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0xF0, 
826:                   0x0F, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0x01, 
827:                   0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 
828:                   0x00, 0x01, 0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x01, 
829:                   0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 
830:                   0x00, 0x01, 0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x01, 
831:                   0xC0, 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0xF0, 
832:                   0x0F, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 
833:                   0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
834:                   0x00, 0x3F, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x03, 0xFF, 
835:                   0xF0, 0x00, 0x07, 0xFF, 0xF0, 0x00, 0x07, 0xFF, 0xF8, 0x00, 
836:                   0x0F, 0x8E, 0x7C, 0x00, 0x0F, 0x0E, 0x3C, 0x00, 0x0F, 0x0E, 
837:                   0x1C, 0x00, 0x0E, 0x0E, 0x1C, 0x00, 0x0E, 0x0E, 0x1C, 0x00, 
838:                   0x0E, 0x0E, 0x1C, 0x00, 0x0F, 0x0E, 0x3C, 0x00, 0x0F, 0x0E, 
839:                   0x7C, 0x00, 0x07, 0x8F, 0xF8, 0x00, 0x07, 0x8F, 0xF8, 0x00, 
840:                   0x03, 0x8F, 0xF0, 0x00, 0x01, 0x8F, 0xC0, 0x00, 0x00, 0x0F, 
841:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x60, 0x00, 
842:                   0x07, 0xF8, 0x70, 0x00, 0x07, 0xFC, 0x78, 0x00, 0x0F, 0xFC, 
843:                   0x78, 0x00, 0x0F, 0x1E, 0x7C, 0x00, 0x0E, 0x1E, 0x3C, 0x00, 
844:                   0x0E, 0x0E, 0x1C, 0x00, 0x0E, 0x0E, 0x1C, 0x00, 0x0E, 0x0E, 
845:                   0x1C, 0x00, 0x0F, 0x0E, 0x1C, 0x00, 0x07, 0x8F, 0x3C, 0x00, 
846:                   0x07, 0xE7, 0x7C, 0x00, 0x0F, 0xFF, 0xFC, 0x00, 0x0F, 0xFF, 
847:                   0xF8, 0x00, 0x0F, 0xFF, 0xF8, 0x00, 0x0F, 0xFF, 0xE0, 0x00, 
848:                   0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 
849:                   0x1C, 0x00, 0x07, 0xFF, 0xFF, 0xE0, 0x07, 0xFF, 0xFF, 0xE0, 
850:                   0x0F, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0xF0, 0x0F, 0x00, 
851:                   0x1C, 0x00, 0x0E, 0x00, 0x1C, 0x00, 0x0E, 0x00, 0x1C, 0x00, 
852:                   0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
853:               };
854:               
855:               
856:               
857:               static uint8_t VCOM_LUT_LUTC[] =
858:               {
859:               	0x00	,0x00,
860:               	0x00	,0x1A	,0x1A	,0x00	,0x00	,0x01,
861:               	0x00	,0x0A	,0x0A	,0x00	,0x00	,0x08,
862:               	0x00	,0x0E	,0x01	,0x0E	,0x01	,0x10,
863:               	0x00	,0x0A	,0x0A	,0x00	,0x00	,0x08,
864:               	0x00	,0x04	,0x10	,0x00	,0x00	,0x05,
865:               	0x00	,0x03	,0x0E	,0x00	,0x00	,0x0A,
866:               	0x00	,0x23	,0x00	,0x00	,0x00	,0x01
867:               };
868:               static uint8_t W2W_LUT_LUTWW[] =
869:               {
870:               	0x90	,0x1A	,0x1A	,0x00	,0x00	,0x01,
871:               	0x40	,0x0A	,0x0A	,0x00	,0x00	,0x08,
872:               	0x84	,0x0E	,0x01	,0x0E	,0x01	,0x10,
873:               	0x80	,0x0A	,0x0A	,0x00	,0x00	,0x08,
874:               	0x00	,0x04	,0x10	,0x00	,0x00	,0x05,
875:               	0x00	,0x03	,0x0E	,0x00	,0x00	,0x0A,
876:               	0x00	,0x23	,0x00	,0x00	,0x00	,0x01
877:               };
878:               static uint8_t B2W_LUT_LUTBW_LUTR[] =
879:               {
880:               	0xA0	,0x1A	,0x1A	,0x00	,0x00	,0x01,
881:               	0x00	,0x0A	,0x0A	,0x00	,0x00	,0x08,
882:               	0x84	,0x0E	,0x01	,0x0E	,0x01	,0x10,
883:               	0x90	,0x0A	,0x0A	,0x00	,0x00	,0x08,
884:               	0xB0	,0x04	,0x10	,0x00	,0x00	,0x05,
885:               	0xB0	,0x03	,0x0E	,0x00	,0x00	,0x0A,
886:               	0xC0	,0x23	,0x00	,0x00	,0x00	,0x01
887:               };
888:               static uint8_t B2B_LUT_LUTBB_LUTB[] =
889:               {
890:               	0x90	,0x1A	,0x1A	,0x00	,0x00	,0x01,
891:               	0x40	,0x0A	,0x0A	,0x00	,0x00	,0x08,
892:               	0x84	,0x0E	,0x01	,0x0E	,0x01	,0x10,
893:               	0x80	,0x0A	,0x0A	,0x00	,0x00	,0x08,
894:               	0x00	,0x04	,0x10	,0x00	,0x00	,0x05,
895:               	0x00	,0x03	,0x0E	,0x00	,0x00	,0x0A,
896:               	0x00	,0x23	,0x00	,0x00	,0x00	,0x01
897:               };
898:               static uint8_t W2B_LUT_LUTWB_LUTW[] =
899:               {
900:               	0x90	,0x1A	,0x1A	,0x00	,0x00	,0x01,
901:               	0x20	,0x0A	,0x0A	,0x00	,0x00	,0x08,
902:               	0x84	,0x0E	,0x01	,0x0E	,0x01	,0x10,
903:               	0x10	,0x0A	,0x0A	,0x00	,0x00	,0x08,
904:               	0x00	,0x04	,0x10	,0x00	,0x00	,0x05,
905:               	0x00	,0x03	,0x0E	,0x00	,0x00	,0x0A,
906:               	0x00	,0x23	,0x00	,0x00	,0x00	,0x01
907:               };
908:               
909:               
910:               #define Battery_HEIGHT_PIXELS    (48)
911:               #define Battery_WIDTH_PIXELS     (24)
912:               #define Battery_WIDTH_MONO_BYTES  (8)
913:               static uint8_t IMG_Battery[144] = {
914:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
915:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x01, 0xFF, 
916:                   0x80, 0x01, 0x81, 0x80, 0x01, 0x81, 0x80, 0x0F, 0x81, 0xF0, 
917:                   0x1F, 0x81, 0xF8, 0x38, 0x00, 0x38, 0x38, 0x00, 0x18, 0x38, 
918:                   0x00, 0x18, 0x39, 0x00, 0x98, 0x38, 0x11, 0x18, 0x38, 0x0A, 
919:                   0x18, 0x38, 0x00, 0x18, 0x38, 0x20, 0x18, 0x38, 0x00, 0x18, 
920:                   0x38, 0x02, 0x18, 0x38, 0x00, 0x18, 0x38, 0x20, 0x18, 0x38, 
921:                   0x00, 0x18, 0x38, 0x00, 0x18, 0x39, 0x00, 0x98, 0x38, 0x00, 
922:                   0x18, 0x38, 0x00, 0x18, 0x39, 0xFF, 0x98, 0x39, 0xFF, 0x98, 
923:                   0x39, 0xFF, 0x98, 0x39, 0xFF, 0x98, 0x39, 0xFF, 0x98, 0x39, 
924:                   0xFF, 0x98, 0x39, 0xFF, 0x98, 0x38, 0xFF, 0x18, 0x38, 0x00, 
925:                   0x18, 0x3F, 0xFF, 0xF8, 0x1F, 0xFF, 0xF8, 0x0F, 0xFF, 0xE0, 
926:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
927:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
928:                   0x00, 0x00, 0x00, 0x00
929:               };
930:               
931:               
932:               #define Timer_HEIGHT_PIXELS    (24)
933:               #define Timer_WIDTH_PIXELS     (24)
934:               #define Timer_WIDTH_MONO_BYTES (8)
935:               static unsigned char IMG_Timer[72] = {
936:                   0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x01, 0xFF, 0x80, 0x07, 
937:                   0xFF, 0xE0, 0x0F, 0xC3, 0xF0, 0x1F, 0x00, 0xF8, 0x1F, 0x00, 
938:                   0xF8, 0x3E, 0x00, 0x7C, 0x38, 0x00, 0x1C, 0x70, 0x00, 0x0E, 
939:                   0x70, 0x00, 0x0E, 0x70, 0x3F, 0xFE, 0x70, 0x7F, 0xFE, 0x70, 
940:                   0x7F, 0xFE, 0x70, 0x38, 0x0E, 0x70, 0x1C, 0x0E, 0x38, 0x1E, 
941:                   0x1C, 0x3E, 0x0C, 0x7C, 0x3E, 0x0C, 0x7C, 0x1F, 0x00, 0xF8, 
942:                   0x0F, 0xC7, 0xF0, 0x07, 0xFF, 0xE0, 0x01, 0xFF, 0x80, 0x00, 
943:                   0x3C, 0x00
944:               };
945:               
946:               //=============================================================================
947:               //this function will take in a byte and send it to the display with the 
948:               //command bit low for command transmission
949:               void writeCMD(uint8_t command)
950:               {
00836E  FA0002     LNK #0x2
008370  784F00     MOV.B W0, [W14]
951:               	//command to set DC low //ePaper_DC_0;
952:                   DC_DISP_SetLow();
008372  A9E6B2     BCLR LATE, #7
953:                   
954:                   CS_DISP_SetLow();
008374  A9A6B2     BCLR LATE, #5
955:                   __delay_us(1);
008376  200100     MOV #0x10, W0
008378  200001     MOV #0x0, W1
00837A  07262B     RCALL ___delay32, .Letext0, .LFE18
956:               	SPI1_Write8bit(command); 
00837C  78401E     MOV.B [W14], W0
00837E  071AF8     RCALL SPI1_Write8bit
957:                   __delay_us(1);
008380  200100     MOV #0x10, W0
008382  200001     MOV #0x0, W1
008384  072626     RCALL ___delay32, .Letext0, .LFE18
958:                   CS_DISP_SetHigh();
008386  A8A6B2     BSET LATE, #5
959:                   
960:               }
008388  FA8000     ULNK
00838A  060000     RETURN
961:               
962:               //this function will take in a byte and send it to the display with the 
963:               //command bit high for data transmission
964:               void writeData(uint8_t data)
965:               {
00838C  FA0002     LNK #0x2
00838E  784F00     MOV.B W0, [W14]
966:               	//command to set DC High //ePaper_DC_1;
967:                   DC_DISP_SetHigh();
008390  A8E6B2     BSET LATE, #7
968:               
969:                   CS_DISP_SetLow();
008392  A9A6B2     BCLR LATE, #5
970:                   __delay_us(1);
008394  200100     MOV #0x10, W0
008396  200001     MOV #0x0, W1
008398  07261C     RCALL ___delay32, .Letext0, .LFE18
971:               	SPI1_Write8bit(data);
00839A  78401E     MOV.B [W14], W0
00839C  071AE9     RCALL SPI1_Write8bit
972:                   __delay_us(1);
00839E  200100     MOV #0x10, W0
0083A0  200001     MOV #0x0, W1
0083A2  072617     RCALL ___delay32, .Letext0, .LFE18
973:                   CS_DISP_SetHigh();
0083A4  A8A6B2     BSET LATE, #5
974:               }
0083A6  FA8000     ULNK
0083A8  060000     RETURN
975:               
976:               //===========================================================================
977:               void epaper_init(void)
978:               {
0083AA  FA0000     LNK #0x0
979:                   
980:               	//// Configure the pin directions   
981:               	//pinMode(EPD_CS, OUTPUT);
982:               	//pinMode(EPD_RESET, OUTPUT);
983:               	//pinMode(EPD_DC, OUTPUT);
984:               	//pinMode(EPD_READY, INPUT);
985:               
986:               	//Set up SPI interface
987:               	//SPI.beginTransaction(SPISettings(2000000, MSBFIRST, SPI_MODE0));
988:               	//SPI.begin();
989:                   /*
990:                    first param: speedMaximum: The maximum speed of communication. For a SPI chip rated up to 20 MHz, use 20000000.
991:                   dataOrder: MSBFIRST or LSBFIRST
992:                   dataMode : SPI_MODE0, SPI_MODE1, SPI_MODE2, or SPI_MODE3 
993:                    */
994:               
995:               
996:               	//reset driver
997:               	DISP_Reset_SetLow(); //ePaper_RST_0;
0083AC  A906B2     BCLR LATE, #0
998:               	__delay_ms(200); //delay(200);
0083AE  2D4000     MOV #0xD400, W0
0083B0  200301     MOV #0x30, W1
0083B2  07260F     RCALL ___delay32, .Letext0, .LFE18
999:               	DISP_Reset_SetHigh(); //ePaper_RST_1;
0083B4  A806B2     BSET LATE, #0
1000:              	__delay_ms(200); //delay(200);
0083B6  2D4000     MOV #0xD400, W0
0083B8  200301     MOV #0x30, W1
0083BA  07260B     RCALL ___delay32, .Letext0, .LFE18
1001:              
1002:              	//-----------------------------------------------------------------------------
1003:              	//more detail on the following commands and additional commands not used here	
1004:              	//can be found on the CFAP176264A0-0270 datasheet on the Crystalfontz website	
1005:              	//-----------------------------------------------------------------------------
1006:              
1007:              	//Power Setting
1008:              	writeCMD(0x01);
0083BC  B3C010     MOV.B #0x1, W0
0083BE  07FFD7     RCALL writeCMD
1009:              	writeData(0x03);
0083C0  B3C030     MOV.B #0x3, W0
0083C2  07FFE4     RCALL writeData
1010:              	writeData(0x00);
0083C4  EB4000     CLR.B W0
0083C6  07FFE2     RCALL writeData
1011:              	writeData(0x2B);
0083C8  B3C2B0     MOV.B #0x2B, W0
0083CA  07FFE0     RCALL writeData
1012:              	writeData(0x2B);
0083CC  B3C2B0     MOV.B #0x2B, W0
0083CE  07FFDE     RCALL writeData
1013:              	writeData(0x09);
0083D0  B3C090     MOV.B #0x9, W0
0083D2  07FFDC     RCALL writeData
1014:              
1015:              	//Power On
1016:              	epaper_on();
0083D4  07003D     RCALL epaper_on
1017:              
1018:              	//Booster Soft Start
1019:              	writeCMD(0x06);
0083D6  B3C060     MOV.B #0x6, W0
0083D8  07FFCA     RCALL writeCMD
1020:              	writeData(0x07);
0083DA  B3C070     MOV.B #0x7, W0
0083DC  07FFD7     RCALL writeData
1021:              	writeData(0x07);
0083DE  B3C070     MOV.B #0x7, W0
0083E0  07FFD5     RCALL writeData
1022:              	writeData(0x17);
0083E2  B3C170     MOV.B #0x17, W0
0083E4  07FFD3     RCALL writeData
1023:              	
1024:              	//Power optimization
1025:              	writeCMD(0xF8);
0083E6  B3CF80     MOV.B #0xF8, W0
0083E8  07FFC2     RCALL writeCMD
1026:              	writeData(0x60);
0083EA  B3C600     MOV.B #0x60, W0
0083EC  07FFCF     RCALL writeData
1027:              	writeData(0xA5);
0083EE  B3CA50     MOV.B #0xA5, W0
0083F0  07FFCD     RCALL writeData
1028:              
1029:              	writeCMD(0xF8);
0083F2  B3CF80     MOV.B #0xF8, W0
0083F4  07FFBC     RCALL writeCMD
1030:              	writeData(0x89);
0083F6  B3C890     MOV.B #0x89, W0
0083F8  07FFC9     RCALL writeData
1031:              	writeData(0xA5);
0083FA  B3CA50     MOV.B #0xA5, W0
0083FC  07FFC7     RCALL writeData
1032:              
1033:              	writeCMD(0xF8);
0083FE  B3CF80     MOV.B #0xF8, W0
008400  07FFB6     RCALL writeCMD
1034:              	writeData(0x90);
008402  B3C900     MOV.B #0x90, W0
008404  07FFC3     RCALL writeData
1035:              	writeData(0x00);
008406  EB4000     CLR.B W0
008408  07FFC1     RCALL writeData
1036:              
1037:              	writeCMD(0xF8);
00840A  B3CF80     MOV.B #0xF8, W0
00840C  07FFB0     RCALL writeCMD
1038:              	writeData(0x93);
00840E  B3C930     MOV.B #0x93, W0
008410  07FFBD     RCALL writeData
1039:              	writeData(0x2A);
008412  B3C2A0     MOV.B #0x2A, W0
008414  07FFBB     RCALL writeData
1040:              	
1041:              	//Reset DFV_EN
1042:              	//this command resets the DFV_EN by sending a partial refresh command
1043:              	writeCMD(0x16);
008416  B3C160     MOV.B #0x16, W0
008418  07FFAA     RCALL writeCMD
1044:              	writeData(0x00);
00841A  EB4000     CLR.B W0
00841C  07FFB7     RCALL writeData
1045:              
1046:              	//PLL Control
1047:              	writeCMD(0x30);
00841E  B3C300     MOV.B #0x30, W0
008420  07FFA6     RCALL writeCMD
1048:              	writeData(0x3A);
008422  B3C3A0     MOV.B #0x3A, W0
008424  07FFB3     RCALL writeData
1049:              
1050:              	
1051:              	//VCM DS Settings
1052:              	writeCMD(0x82);
008426  B3C820     MOV.B #0x82, W0
008428  07FFA2     RCALL writeCMD
1053:              	writeData(0x12);
00842A  B3C120     MOV.B #0x12, W0
00842C  07FFAF     RCALL writeData
1054:              
1055:              	writeCMD(0x50);
00842E  B3C500     MOV.B #0x50, W0
008430  07FF9E     RCALL writeCMD
1056:              	writeData(0x87);
008432  B3C870     MOV.B #0x87, W0
008434  07FFAB     RCALL writeData
1057:              
1058:              	//set LUTs and panel setting
1059:              	//setRegisterLUT();
1060:              	setOTPLUT();
008436  070068     RCALL setOTPLUT
1061:              
1062:              	//Resolution
1063:              	writeCMD(0x61);
008438  B3C610     MOV.B #0x61, W0
00843A  07FF99     RCALL writeCMD
1064:              	writeData(0x00);	//first half of 2 bytes:  0		
00843C  EB4000     CLR.B W0
00843E  07FFA6     RCALL writeData
1065:              	writeData(0xB0);	//second half of 2 bytes: 176
008440  B3CB00     MOV.B #0xB0, W0
008442  07FFA4     RCALL writeData
1066:              	writeData(0x01);	//first half of 2 bytes:  256
008444  B3C010     MOV.B #0x1, W0
008446  07FFA2     RCALL writeData
1067:              	writeData(0x08);	//second half of 2 bytes: 8
008448  B3C080     MOV.B #0x8, W0
00844A  07FFA0     RCALL writeData
1068:              						//	176	 x	264
1069:                  
1070:                  
1071:              }
00844C  FA8000     ULNK
00844E  060000     RETURN
1072:              
1073:              void epaper_on() {
008450  FA0000     LNK #0x0
1074:                  //Power On
1075:              	writeCMD(0x04);
008452  B3C040     MOV.B #0x4, W0
008454  07FF8C     RCALL writeCMD
1076:              	//wait until powered on
1077:                  // since we will be doing some computation before sending the command
1078:                  // we may not need to wait: To investigate
1079:              	while (BSY_DISP_GetValue()==0) {};
008456  000000     NOP
008458  803620     MOV PORTF, W0
00845A  600061     AND W0, #0x1, W0
00845C  E00000     CP0 W0
00845E  32FFFC     BRA Z, .L5
1080:              }
008460  FA8000     ULNK
008462  060000     RETURN
1081:              
1082:              void epaper_off() {
008464  FA0000     LNK #0x0
1083:              	//Power On
1084:              	writeCMD(0x02);
008466  B3C020     MOV.B #0x2, W0
008468  07FF82     RCALL writeCMD
1085:              	//wait until powered off
1086:              	//while (0 == BSY_DISP_GetValue());
1087:                  
1088:              }
00846A  FA8000     ULNK
00846C  060000     RETURN
1089:              
1090:              void setRegisterLUT()
1091:              {
00846E  FA0002     LNK #0x2
1092:                  int i;
1093:              	//set LUTs
1094:              	//The following block allows the LUTs to be changed.
1095:              	//In order for these LUTs to take effect, command 0x00 must have bit 5 set to "1"
1096:              	//set panel setting to call LUTs from the register
1097:              	writeCMD(0x00);
008470  EB4000     CLR.B W0
008472  07FF7D     RCALL writeCMD
1098:              	writeData(0xEF); //11101111
008474  B3CEF0     MOV.B #0xEF, W0
008476  07FF8A     RCALL writeData
1099:              
1100:              	//VCOM_LUT_LUTC
1101:              	writeCMD(0x20);
008478  B3C200     MOV.B #0x20, W0
00847A  07FF79     RCALL writeCMD
1102:              	for (i = 0; i < 44; i++)
00847C  EB0000     CLR W0
00847E  780F00     MOV W0, [W14]
008480  370005     BRA .L8
00848A  E80F1E     INC [W14], [W14]
00848C  2002B0     MOV #0x2B, W0
00848E  78009E     MOV [W14], W1
008490  508F80     SUB W1, W0, [W15]
008492  34FFF7     BRA LE, .L9
1103:              	{
1104:              		writeData(VCOM_LUT_LUTC[i]);
008482  211920     MOV #0x1192, W0
008484  40001E     ADD W0, [W14], W0
008486  784010     MOV.B [W0], W0
008488  07FF81     RCALL writeData
1105:              	}
1106:              	//W2W_LUT_LUTWW
1107:              	writeCMD(0x21);
008494  B3C210     MOV.B #0x21, W0
008496  07FF6B     RCALL writeCMD
1108:              	for (i = 0; i < 42; i++)
008498  EB0000     CLR W0
00849A  780F00     MOV W0, [W14]
00849C  370005     BRA .L10
0084A6  E80F1E     INC [W14], [W14]
0084A8  200290     MOV #0x29, W0
0084AA  78009E     MOV [W14], W1
0084AC  508F80     SUB W1, W0, [W15]
0084AE  34FFF7     BRA LE, .L11
1109:              	{
1110:              		writeData(W2W_LUT_LUTWW[i]);
00849E  211BE0     MOV #0x11BE, W0
0084A0  40001E     ADD W0, [W14], W0
0084A2  784010     MOV.B [W0], W0
0084A4  07FF73     RCALL writeData
1111:              	}
1112:              	//B2W_LUT_LUTBW_LUTR
1113:              	writeCMD(0x22);
0084B0  B3C220     MOV.B #0x22, W0
0084B2  07FF5D     RCALL writeCMD
1114:              	for (i = 0; i < 42; i++)
0084B4  EB0000     CLR W0
0084B6  780F00     MOV W0, [W14]
0084B8  370005     BRA .L12
0084C2  E80F1E     INC [W14], [W14]
0084C4  200290     MOV #0x29, W0
0084C6  78009E     MOV [W14], W1
0084C8  508F80     SUB W1, W0, [W15]
0084CA  34FFF7     BRA LE, .L13
1115:              	{
1116:              		writeData(B2W_LUT_LUTBW_LUTR[i]);
0084BA  211E80     MOV #0x11E8, W0
0084BC  40001E     ADD W0, [W14], W0
0084BE  784010     MOV.B [W0], W0
0084C0  07FF65     RCALL writeData
1117:              	}
1118:              	//B2B_LUT_LUTBB_LUTB
1119:              	writeCMD(0x23);
0084CC  B3C230     MOV.B #0x23, W0
0084CE  07FF4F     RCALL writeCMD
1120:              	for (i = 0; i < 42; i++)
0084D0  EB0000     CLR W0
0084D2  780F00     MOV W0, [W14]
0084D4  370005     BRA .L14
0084DE  E80F1E     INC [W14], [W14]
0084E0  200290     MOV #0x29, W0
0084E2  78009E     MOV [W14], W1
0084E4  508F80     SUB W1, W0, [W15]
0084E6  34FFF7     BRA LE, .L15
1121:              	{
1122:              		writeData(B2B_LUT_LUTBB_LUTB[i]);
0084D6  212120     MOV #0x1212, W0
0084D8  40001E     ADD W0, [W14], W0
0084DA  784010     MOV.B [W0], W0
0084DC  07FF57     RCALL writeData
1123:              	}
1124:              	//W2B_LUT_LUTWB_LUTW
1125:              	writeCMD(0x24);
0084E8  B3C240     MOV.B #0x24, W0
0084EA  07FF41     RCALL writeCMD
1126:              	for (i = 0; i < 42; i++)
0084EC  EB0000     CLR W0
0084EE  780F00     MOV W0, [W14]
0084F0  370005     BRA .L16
0084FA  E80F1E     INC [W14], [W14]
0084FC  200290     MOV #0x29, W0
0084FE  78009E     MOV [W14], W1
008500  508F80     SUB W1, W0, [W15]
008502  34FFF7     BRA LE, .L17
1127:              	{
1128:              		writeData(W2B_LUT_LUTWB_LUTW[i]);
0084F2  2123C0     MOV #0x123C, W0
0084F4  40001E     ADD W0, [W14], W0
0084F6  784010     MOV.B [W0], W0
0084F8  07FF49     RCALL writeData
1129:              	}
1130:              }
008504  FA8000     ULNK
008506  060000     RETURN
1131:              
1132:              void setOTPLUT()
1133:              {
008508  FA0000     LNK #0x0
1134:              	//set panel setting to call LUTs from OTP
1135:              	writeCMD(0x00);
00850A  EB4000     CLR.B W0
00850C  07FF30     RCALL writeCMD
1136:              	writeData(0xCF); //11001111
00850E  B3CCF0     MOV.B #0xCF, W0
008510  07FF3D     RCALL writeData
1137:              }
008512  FA8000     ULNK
008514  060000     RETURN
1138:              
1139:              // ===========================================================================
1140:              // draw functions: begin
1141:              float cp_sign(int p1_x, int p1_y, int p2_x, int p2_y, int p3_x, int p3_y) {
008516  FA0010     LNK #0x10
008518  980720     MOV W0, [W14+4]
00851A  980731     MOV W1, [W14+6]
00851C  980742     MOV W2, [W14+8]
00851E  980753     MOV W3, [W14+10]
008520  980764     MOV W4, [W14+12]
008522  980775     MOV W5, [W14+14]
1142:                float tmpf;
1143:                tmpf = (float) ( (p1_x - p3_x) * ( p2_y - p3_y) );
008524  9000AE     MOV [W14+4], W1
008526  90006E     MOV [W14+12], W0
008528  508080     SUB W1, W0, W1
00852A  90015E     MOV [W14+10], W2
00852C  90007E     MOV [W14+14], W0
00852E  510000     SUB W2, W0, W0
008530  B98800     MUL.SS W1, W0, W0
008532  780000     MOV W0, W0
008534  DE80CF     ASR W0, #15, W1
008536  07C040     RCALL ___floatsisf
008538  BE8F00     MOV.D W0, [W14]
1144:                tmpf = tmpf - ( (p2_x - p3_x) * ( p1_y - p3_y) );
00853A  9000CE     MOV [W14+8], W1
00853C  90006E     MOV [W14+12], W0
00853E  508080     SUB W1, W0, W1
008540  90013E     MOV [W14+6], W2
008542  90007E     MOV [W14+14], W0
008544  510000     SUB W2, W0, W0
008546  B98800     MUL.SS W1, W0, W0
008548  780000     MOV W0, W0
00854A  DE80CF     ASR W0, #15, W1
00854C  07C035     RCALL ___floatsisf
00854E  BE0100     MOV.D W0, W2
008550  BE001E     MOV.D [W14], W0
008552  07BF43     RCALL ___subsf3
008554  BE8F00     MOV.D W0, [W14]
1145:                return tmpf;
008556  BE001E     MOV.D [W14], W0
1146:              }
008558  FA8000     ULNK
00855A  060000     RETURN
1147:              
1148:              int pointInTriangle(int pt_x, int pt_y, int v1_x, int v1_y, int v2_x, int v2_y, int v3_x, int v3_y) {
00855C  FA0016     LNK #0x16
00855E  781F88     MOV W8, [W15++]
008560  980730     MOV W0, [W14+6]
008562  980741     MOV W1, [W14+8]
008564  980752     MOV W2, [W14+10]
008566  980763     MOV W3, [W14+12]
008568  980774     MOV W4, [W14+14]
00856A  980F05     MOV W5, [W14+16]
00856C  980F16     MOV W6, [W14+18]
00856E  980F27     MOV W7, [W14+20]
1149:                // return 1 if true, 0 otherwise
1150:                int tmp1, tmp2, tmp3;
1151:                if ( cp_sign(pt_x, pt_y, v1_x, v1_y, v2_x, v2_y)  < 0.0f ) {
008570  900A8E     MOV [W14+16], W5
008572  90027E     MOV [W14+14], W4
008574  9001EE     MOV [W14+12], W3
008576  90015E     MOV [W14+10], W2
008578  9000CE     MOV [W14+8], W1
00857A  90003E     MOV [W14+6], W0
00857C  07FFCC     RCALL cp_sign
00857E  B3C018     MOV.B #0x1, W8
008580  B81160     MUL.UU W2, #0, W2
008582  07BFDA     RCALL ___ltsf2, ___eqsf2, ___lesf2
008584  E00000     CP0 W0
008586  350001     BRA LT, .L21
008588  EB4400     CLR.B W8
00858A  E00408     CP0.B W8
00858C  320003     BRA Z, .L22
1152:                  tmp1 = -1;
00858E  EB8000     SETM W0
008590  780F00     MOV W0, [W14]
008592  370002     BRA .L23
1153:                }
1154:                else {
1155:                  tmp1 = 1;
008594  200010     MOV #0x1, W0
008596  780F00     MOV W0, [W14]
1156:                }
1157:                if ( cp_sign(pt_x, pt_y, v2_x, v2_y, v3_x, v3_y)  < 0.0f ) {
008598  900AAE     MOV [W14+20], W5
00859A  900A1E     MOV [W14+18], W4
00859C  90098E     MOV [W14+16], W3
00859E  90017E     MOV [W14+14], W2
0085A0  9000CE     MOV [W14+8], W1
0085A2  90003E     MOV [W14+6], W0
0085A4  07FFB8     RCALL cp_sign
0085A6  B3C018     MOV.B #0x1, W8
0085A8  B81160     MUL.UU W2, #0, W2
0085AA  07BFC6     RCALL ___ltsf2, ___eqsf2, ___lesf2
0085AC  E00000     CP0 W0
0085AE  350001     BRA LT, .L24
0085B0  EB4400     CLR.B W8
0085B2  E00408     CP0.B W8
0085B4  320003     BRA Z, .L25
1158:                  tmp2 = -1;
0085B6  EB8000     SETM W0
0085B8  980710     MOV W0, [W14+2]
0085BA  370002     BRA .L26
1159:                }
1160:                else {
1161:                  tmp2 = 1;
0085BC  200010     MOV #0x1, W0
0085BE  980710     MOV W0, [W14+2]
1162:                }
1163:                if ( cp_sign(pt_x, pt_y, v3_x, v3_y, v1_x, v1_y)  < 0.0f ) {
0085C0  9002EE     MOV [W14+12], W5
0085C2  90025E     MOV [W14+10], W4
0085C4  9009AE     MOV [W14+20], W3
0085C6  90091E     MOV [W14+18], W2
0085C8  9000CE     MOV [W14+8], W1
0085CA  90003E     MOV [W14+6], W0
0085CC  07FFA4     RCALL cp_sign
0085CE  B3C018     MOV.B #0x1, W8
0085D0  B81160     MUL.UU W2, #0, W2
0085D2  07BFB2     RCALL ___ltsf2, ___eqsf2, ___lesf2
0085D4  E00000     CP0 W0
0085D6  350001     BRA LT, .L27
0085D8  EB4400     CLR.B W8
0085DA  E00408     CP0.B W8
0085DC  320003     BRA Z, .L28
1164:                  tmp3 = -1;
0085DE  EB8000     SETM W0
0085E0  980720     MOV W0, [W14+4]
0085E2  370002     BRA .L29
1165:                }
1166:                else {
1167:                  tmp3 = 1;
0085E4  200010     MOV #0x1, W0
0085E6  980720     MOV W0, [W14+4]
1168:                }
1169:                if ( (tmp1 == tmp2) && (tmp2 == tmp3) ) {
0085E8  90001E     MOV [W14+2], W0
0085EA  78009E     MOV [W14], W1
0085EC  508F80     SUB W1, W0, [W15]
0085EE  3A0006     BRA NZ, .L30
0085F0  90009E     MOV [W14+2], W1
0085F2  90002E     MOV [W14+4], W0
0085F4  508F80     SUB W1, W0, [W15]
0085F6  3A0002     BRA NZ, .L30
1170:                  return 1;
0085F8  200010     MOV #0x1, W0
0085FA  370001     BRA .L31
1171:                }
1172:                else {
1173:                  return 0;
0085FC  EB0000     CLR W0
1174:                }
1175:              }
0085FE  78044F     MOV [--W15], W8
008600  FA8000     ULNK
008602  060000     RETURN
1176:              
1177:              
1178:              void app_clear_triangle(int t0_x, int t0_y, int t1_x, int t1_y, int t2_x, int t2_y)
1179:              {
008604  FA0014     LNK #0x14
008606  980740     MOV W0, [W14+8]
008608  980751     MOV W1, [W14+10]
00860A  980762     MOV W2, [W14+12]
00860C  980773     MOV W3, [W14+14]
00860E  980F04     MOV W4, [W14+16]
008610  980F15     MOV W5, [W14+18]
1180:                // find bounding rectangle
1181:                  // then do not forget to call clear indicato
1182:                int min_x, max_x, min_y, max_y;
1183:                  // variables for filling pixel values into array
1184:                min_x = t0_x;
008612  9000CE     MOV [W14+8], W1
008614  780F01     MOV W1, [W14]
1185:                max_x = t0_x;
008616  9000CE     MOV [W14+8], W1
008618  980711     MOV W1, [W14+2]
1186:                if (t1_x < min_x) {
00861A  90006E     MOV [W14+12], W0
00861C  500F9E     SUB W0, [W14], [W15]
00861E  3D0002     BRA GE, .L33
1187:                  min_x = t1_x;
008620  9000EE     MOV [W14+12], W1
008622  780F01     MOV W1, [W14]
1188:                }
1189:                if (t1_x > max_x) {
008624  9000EE     MOV [W14+12], W1
008626  90001E     MOV [W14+2], W0
008628  508F80     SUB W1, W0, [W15]
00862A  340002     BRA LE, .L34
1190:                  max_x = t1_x;
00862C  9000EE     MOV [W14+12], W1
00862E  980711     MOV W1, [W14+2]
1191:                }
1192:                if (t2_x < min_x) {
008630  90080E     MOV [W14+16], W0
008632  500F9E     SUB W0, [W14], [W15]
008634  3D0002     BRA GE, .L35
1193:                  min_x = t2_x;
008636  90088E     MOV [W14+16], W1
008638  780F01     MOV W1, [W14]
1194:                }
1195:                if (t2_x > max_x) {
00863A  90088E     MOV [W14+16], W1
00863C  90001E     MOV [W14+2], W0
00863E  508F80     SUB W1, W0, [W15]
008640  340002     BRA LE, .L36
1196:                  max_x = t2_x;
008642  90088E     MOV [W14+16], W1
008644  980711     MOV W1, [W14+2]
1197:                }
1198:                min_y = t0_y;
008646  9000DE     MOV [W14+10], W1
008648  980721     MOV W1, [W14+4]
1199:                max_y = t0_y;
00864A  9000DE     MOV [W14+10], W1
00864C  980731     MOV W1, [W14+6]
1200:                if (t1_y < min_y) {
00864E  9000FE     MOV [W14+14], W1
008650  90002E     MOV [W14+4], W0
008652  508F80     SUB W1, W0, [W15]
008654  3D0002     BRA GE, .L37
1201:                  min_y = t1_y;
008656  9000FE     MOV [W14+14], W1
008658  980721     MOV W1, [W14+4]
1202:                }
1203:                if (t1_y > max_y) {
00865A  9000FE     MOV [W14+14], W1
00865C  90003E     MOV [W14+6], W0
00865E  508F80     SUB W1, W0, [W15]
008660  340002     BRA LE, .L38
1204:                  max_y = t1_y;
008662  9000FE     MOV [W14+14], W1
008664  980731     MOV W1, [W14+6]
1205:                }
1206:                if (t2_y < min_y) {
008666  90089E     MOV [W14+18], W1
008668  90002E     MOV [W14+4], W0
00866A  508F80     SUB W1, W0, [W15]
00866C  3D0002     BRA GE, .L39
1207:                  min_y = t2_y;
00866E  90089E     MOV [W14+18], W1
008670  980721     MOV W1, [W14+4]
1208:                }
1209:                if (t2_y > max_y) {
008672  90089E     MOV [W14+18], W1
008674  90003E     MOV [W14+6], W0
008676  508F80     SUB W1, W0, [W15]
008678  340002     BRA LE, .L40
1210:                  max_y = t2_y;
00867A  90089E     MOV [W14+18], W1
00867C  980731     MOV W1, [W14+6]
1211:                }
1212:              
1213:                b_vert_x[0] = min_x;
00867E  208500     MOV #0x850, W0
008680  78081E     MOV [W14], [W0]
1214:                b_vert_y[0] = min_y;
008682  208580     MOV #0x858, W0
008684  9000AE     MOV [W14+4], W1
008686  780801     MOV W1, [W0]
1215:                b_vert_x[1] = min_x;
008688  208500     MOV #0x850, W0
00868A  78009E     MOV [W14], W1
00868C  980011     MOV W1, [W0+2]
1216:                b_vert_y[1] = max_y;
00868E  208580     MOV #0x858, W0
008690  9000BE     MOV [W14+6], W1
008692  980011     MOV W1, [W0+2]
1217:                b_vert_x[2] = max_x;
008694  208500     MOV #0x850, W0
008696  90009E     MOV [W14+2], W1
008698  980021     MOV W1, [W0+4]
1218:                b_vert_y[2] = max_y;
00869A  208580     MOV #0x858, W0
00869C  9000BE     MOV [W14+6], W1
00869E  980021     MOV W1, [W0+4]
1219:                b_vert_x[3] = max_x;
0086A0  208500     MOV #0x850, W0
0086A2  90009E     MOV [W14+2], W1
0086A4  980031     MOV W1, [W0+6]
1220:                b_vert_y[3] = min_y;
0086A6  208580     MOV #0x858, W0
0086A8  9000AE     MOV [W14+4], W1
0086AA  980031     MOV W1, [W0+6]
1221:              }
0086AC  FA8000     ULNK
0086AE  060000     RETURN
1222:              
1223:              void app_fill_triangle(int t0_x, int t0_y, int t1_x, int t1_y, int t2_x, int t2_y, int append) {
0086B0  FA001E     LNK #0x1E
0086B2  980F00     MOV W0, [W14+16]
0086B4  980F11     MOV W1, [W14+18]
0086B6  980F22     MOV W2, [W14+20]
0086B8  980F33     MOV W3, [W14+22]
0086BA  980F44     MOV W4, [W14+24]
0086BC  980F55     MOV W5, [W14+26]
0086BE  980F66     MOV W6, [W14+28]
1224:                // v1.2
1225:                // find bounding rectangle
1226:                int min_x, max_x, min_y, max_y;
1227:                  // variables for filling pixel values into array
1228:                int t_index = 0;
0086C0  EB0000     CLR W0
0086C2  980740     MOV W0, [W14+8]
1229:                int index;
1230:                int x, y;
1231:                min_x = t0_x;
0086C4  90088E     MOV [W14+16], W1
0086C6  780F01     MOV W1, [W14]
1232:                max_x = t0_x;
0086C8  90088E     MOV [W14+16], W1
0086CA  980711     MOV W1, [W14+2]
1233:                if (t1_x < min_x) {
0086CC  90082E     MOV [W14+20], W0
0086CE  500F9E     SUB W0, [W14], [W15]
0086D0  3D0002     BRA GE, .L42
1234:                  min_x = t1_x;
0086D2  9008AE     MOV [W14+20], W1
0086D4  780F01     MOV W1, [W14]
1235:                }
1236:                if (t1_x > max_x) {
0086D6  9008AE     MOV [W14+20], W1
0086D8  90001E     MOV [W14+2], W0
0086DA  508F80     SUB W1, W0, [W15]
0086DC  340002     BRA LE, .L43
1237:                  max_x = t1_x;
0086DE  9008AE     MOV [W14+20], W1
0086E0  980711     MOV W1, [W14+2]
1238:                }
1239:                if (t2_x < min_x) {
0086E2  90084E     MOV [W14+24], W0
0086E4  500F9E     SUB W0, [W14], [W15]
0086E6  3D0002     BRA GE, .L44
1240:                  min_x = t2_x;
0086E8  9008CE     MOV [W14+24], W1
0086EA  780F01     MOV W1, [W14]
1241:                }
1242:                if (t2_x > max_x) {
0086EC  9008CE     MOV [W14+24], W1
0086EE  90001E     MOV [W14+2], W0
0086F0  508F80     SUB W1, W0, [W15]
0086F2  340002     BRA LE, .L45
1243:                  max_x = t2_x;
0086F4  9008CE     MOV [W14+24], W1
0086F6  980711     MOV W1, [W14+2]
1244:                }
1245:                min_y = t0_y;
0086F8  90089E     MOV [W14+18], W1
0086FA  980721     MOV W1, [W14+4]
1246:                max_y = t0_y;
0086FC  90089E     MOV [W14+18], W1
0086FE  980731     MOV W1, [W14+6]
1247:                if (t1_y < min_y) {
008700  9008BE     MOV [W14+22], W1
008702  90002E     MOV [W14+4], W0
008704  508F80     SUB W1, W0, [W15]
008706  3D0002     BRA GE, .L46
1248:                  min_y = t1_y;
008708  9008BE     MOV [W14+22], W1
00870A  980721     MOV W1, [W14+4]
1249:                }
1250:                if (t1_y > max_y) {
00870C  9008BE     MOV [W14+22], W1
00870E  90003E     MOV [W14+6], W0
008710  508F80     SUB W1, W0, [W15]
008712  340002     BRA LE, .L47
1251:                  max_y = t1_y;
008714  9008BE     MOV [W14+22], W1
008716  980731     MOV W1, [W14+6]
1252:                }
1253:                if (t2_y < min_y) {
008718  9008DE     MOV [W14+26], W1
00871A  90002E     MOV [W14+4], W0
00871C  508F80     SUB W1, W0, [W15]
00871E  3D0002     BRA GE, .L48
1254:                  min_y = t2_y;
008720  9008DE     MOV [W14+26], W1
008722  980721     MOV W1, [W14+4]
1255:                }
1256:                if (t2_y > max_y) {
008724  9008DE     MOV [W14+26], W1
008726  90003E     MOV [W14+6], W0
008728  508F80     SUB W1, W0, [W15]
00872A  340002     BRA LE, .L49
1257:                  max_y = t2_y;
00872C  9008DE     MOV [W14+26], W1
00872E  980731     MOV W1, [W14+6]
1258:                }
1259:              
1260:                b_vert_x[0] = min_x;
008730  208500     MOV #0x850, W0
008732  78081E     MOV [W14], [W0]
1261:                b_vert_y[0] = min_y;
008734  208580     MOV #0x858, W0
008736  9000AE     MOV [W14+4], W1
008738  780801     MOV W1, [W0]
1262:                b_vert_x[1] = min_x;
00873A  208500     MOV #0x850, W0
00873C  78009E     MOV [W14], W1
00873E  980011     MOV W1, [W0+2]
1263:                b_vert_y[1] = max_y;
008740  208580     MOV #0x858, W0
008742  9000BE     MOV [W14+6], W1
008744  980011     MOV W1, [W0+2]
1264:                b_vert_x[2] = max_x;
008746  208500     MOV #0x850, W0
008748  90009E     MOV [W14+2], W1
00874A  980021     MOV W1, [W0+4]
1265:                b_vert_y[2] = max_y;
00874C  208580     MOV #0x858, W0
00874E  9000BE     MOV [W14+6], W1
008750  980021     MOV W1, [W0+4]
1266:                b_vert_x[3] = max_x;
008752  208500     MOV #0x850, W0
008754  90009E     MOV [W14+2], W1
008756  980031     MOV W1, [W0+6]
1267:                b_vert_y[3] = min_y;
008758  208580     MOV #0x858, W0
00875A  9000AE     MOV [W14+4], W1
00875C  980031     MOV W1, [W0+6]
1268:                  
1269:                if (append == 1) {
00875E  90086E     MOV [W14+28], W0
008760  500FE1     SUB W0, #0x1, [W15]
008762  3A0003     BRA NZ, .L50
1270:                  t_index = d_pt_count;
008764  804441     MOV d_pt_count, W1
008766  980741     MOV W1, [W14+8]
008768  370002     BRA .L51
1271:                }
1272:                else {
1273:                  t_index = 0;
00876A  EB0000     CLR W0
00876C  980740     MOV W0, [W14+8]
1274:                }
1275:                for (x = min_x; x <= max_x; x++) {
00876E  78009E     MOV [W14], W1
008770  980751     MOV W1, [W14+10]
008772  37002C     BRA .L52
0087C6  90005E     MOV [W14+10], W0
0087C8  E80000     INC W0, W0
0087CA  980750     MOV W0, [W14+10]
0087CC  9000DE     MOV [W14+10], W1
0087CE  90001E     MOV [W14+2], W0
0087D0  508F80     SUB W1, W0, [W15]
0087D2  34FFD0     BRA LE, .L56
1276:                  for (y = min_y; y <= max_y; y++ ) {
008774  9000AE     MOV [W14+4], W1
008776  980761     MOV W1, [W14+12]
008778  370022     BRA .L53
0087B8  90006E     MOV [W14+12], W0
0087BA  E80000     INC W0, W0
0087BC  980760     MOV W0, [W14+12]
0087BE  9000EE     MOV [W14+12], W1
0087C0  90003E     MOV [W14+6], W0
0087C2  508F80     SUB W1, W0, [W15]
0087C4  34FFDA     BRA LE, .L55
1277:                    if (pointInTriangle(x,y, t0_x, t0_y, t1_x, t1_y, t2_x, t2_y) == 1) {
00877A  900BDE     MOV [W14+26], W7
00877C  900B4E     MOV [W14+24], W6
00877E  900ABE     MOV [W14+22], W5
008780  900A2E     MOV [W14+20], W4
008782  90099E     MOV [W14+18], W3
008784  90090E     MOV [W14+16], W2
008786  9000EE     MOV [W14+12], W1
008788  90005E     MOV [W14+10], W0
00878A  07FEE8     RCALL pointInTriangle
00878C  500FE1     SUB W0, #0x1, [W15]
00878E  3A0014     BRA NZ, .L54
1278:                     // draw pixel at x,y
1279:                      index = x + y* EP_WIDTH;
008790  9000EE     MOV [W14+12], W1
008792  200B00     MOV #0xB0, W0
008794  B98800     MUL.SS W1, W0, W0
008796  780080     MOV W0, W1
008798  90005E     MOV [W14+10], W0
00879A  408000     ADD W1, W0, W0
00879C  980770     MOV W0, [W14+14]
1280:                      if (t_index < D_PT_LENGTH) {
00879E  9000CE     MOV [W14+8], W1
0087A0  202570     MOV #0x257, W0
0087A2  508F80     SUB W1, W0, [W15]
0087A4  3C0009     BRA GT, .L54
1281:                        d_pt[t_index] = index;
0087A6  90004E     MOV [W14+8], W0
0087A8  400080     ADD W0, W0, W1
0087AA  2134A0     MOV #0x134A, W0
0087AC  408000     ADD W1, W0, W0
0087AE  9000FE     MOV [W14+14], W1
0087B0  780801     MOV W1, [W0]
1282:                        t_index++;
0087B2  90004E     MOV [W14+8], W0
0087B4  E80000     INC W0, W0
0087B6  980740     MOV W0, [W14+8]
1283:                      }
1284:                    }
1285:                  }
1286:                }
1287:                d_pt_count = t_index;
0087D4  9000CE     MOV [W14+8], W1
0087D6  884441     MOV W1, d_pt_count
1288:              }
0087D8  FA8000     ULNK
0087DA  060000     RETURN
1289:              
1290:              /*
1291:               * rotates the coordinates of vert_x, vert_y of the triangle about the 
1292:               * centerX, centerY and by an angle of "angle_deg"
1293:               */
1294:              void rotate_triangle(int angle_deg, int centerX, int centerY) {
0087DC  FA0034     LNK #0x34
0087DE  981770     MOV W0, [W14+46]
0087E0  981F01     MOV W1, [W14+48]
0087E2  981F12     MOV W2, [W14+50]
1295:                float x0, y0, x1,y1, x2, y2, x3, y3;
1296:                float ang_rad = (2.0*(22.0/7.0)*angle_deg)/360.0;
0087E4  90107E     MOV [W14+46], W0
0087E6  DE80CF     ASR W0, #15, W1
0087E8  07BEE7     RCALL ___floatsisf
0087EA  224922     MOV #0x2492, W2
0087EC  240C93     MOV #0x40C9, W3
0087EE  07BF44     RCALL ___mulsf3
0087F0  200002     MOV #0x0, W2
0087F2  243B43     MOV #0x43B4, W3
0087F4  07BE50     RCALL ___divsf3
0087F6  980710     MOV W0, [W14+2]
0087F8  980721     MOV W1, [W14+4]
1297:                double alpha_gamma = - tan(ang_rad/2);
0087FA  200002     MOV #0x0, W2
0087FC  240003     MOV #0x4000, W3
0087FE  90001E     MOV [W14+2], W0
008800  9000AE     MOV [W14+4], W1
008802  07BE49     RCALL ___divsf3
008804  07BF6F     RCALL _tanf
008806  A2F001     BTG W1, #15
008808  980730     MOV W0, [W14+6]
00880A  980741     MOV W1, [W14+8]
1298:                double beta = sin(ang_rad);
00880C  90001E     MOV [W14+2], W0
00880E  9000AE     MOV [W14+4], W1
008810  07BF67     RCALL _sinf
008812  980750     MOV W0, [W14+10]
008814  980761     MOV W1, [W14+12]
1299:                int ii;
1300:                for (ii=0; ii < VERT_LENGTH; ii++) {
008816  EB0000     CLR W0
008818  780F00     MOV W0, [W14]
00881A  37005B     BRA .L58
0088D0  E80F1E     INC [W14], [W14]
0088D2  78001E     MOV [W14], W0
0088D4  500FE2     SUB W0, #0x2, [W15]
0088D6  34FFA2     BRA LE, .L59
1301:                 x0 = (float)(vert_x[ii] - centerX);
00881C  78001E     MOV [W14], W0
00881E  400080     ADD W0, W0, W1
008820  2133E0     MOV #0x133E, W0
008822  408000     ADD W1, W0, W0
008824  780090     MOV [W0], W1
008826  90180E     MOV [W14+48], W0
008828  508000     SUB W1, W0, W0
00882A  DE80CF     ASR W0, #15, W1
00882C  07BEC5     RCALL ___floatsisf
00882E  980770     MOV W0, [W14+14]
008830  980F01     MOV W1, [W14+16]
1302:                 y0 = (float) (vert_y[ii] - centerY);
008832  78001E     MOV [W14], W0
008834  400080     ADD W0, W0, W1
008836  213440     MOV #0x1344, W0
008838  408000     ADD W1, W0, W0
00883A  780090     MOV [W0], W1
00883C  90181E     MOV [W14+50], W0
00883E  508000     SUB W1, W0, W0
008840  DE80CF     ASR W0, #15, W1
008842  07BEBA     RCALL ___floatsisf
008844  980F10     MOV W0, [W14+18]
008846  980F21     MOV W1, [W14+20]
1303:                 x1 = x0 + alpha_gamma * y0;
008848  90091E     MOV [W14+18], W2
00884A  9009AE     MOV [W14+20], W3
00884C  90003E     MOV [W14+6], W0
00884E  9000CE     MOV [W14+8], W1
008850  07BF13     RCALL ___mulsf3
008852  90017E     MOV [W14+14], W2
008854  90098E     MOV [W14+16], W3
008856  07BDC2     RCALL ___addsf3
008858  980F30     MOV W0, [W14+22]
00885A  980F41     MOV W1, [W14+24]
1304:                 y1 = y0;
00885C  90091E     MOV [W14+18], W2
00885E  9009AE     MOV [W14+20], W3
008860  980F52     MOV W2, [W14+26]
008862  980F63     MOV W3, [W14+28]
1305:                 x2 = x1;
008864  90093E     MOV [W14+22], W2
008866  9009CE     MOV [W14+24], W3
008868  980F72     MOV W2, [W14+30]
00886A  981703     MOV W3, [W14+32]
1306:                 y2 = beta*x1 + y1;
00886C  90093E     MOV [W14+22], W2
00886E  9009CE     MOV [W14+24], W3
008870  90005E     MOV [W14+10], W0
008872  9000EE     MOV [W14+12], W1
008874  07BF01     RCALL ___mulsf3
008876  90095E     MOV [W14+26], W2
008878  9009EE     MOV [W14+28], W3
00887A  07BDB0     RCALL ___addsf3
00887C  981710     MOV W0, [W14+34]
00887E  981721     MOV W1, [W14+36]
1307:                 x3 = x2 + alpha_gamma*y2;
008880  90111E     MOV [W14+34], W2
008882  9011AE     MOV [W14+36], W3
008884  90003E     MOV [W14+6], W0
008886  9000CE     MOV [W14+8], W1
008888  07BEF7     RCALL ___mulsf3
00888A  90097E     MOV [W14+30], W2
00888C  90118E     MOV [W14+32], W3
00888E  07BDA6     RCALL ___addsf3
008890  981730     MOV W0, [W14+38]
008892  981741     MOV W1, [W14+40]
1308:                 y3 = y2;
008894  90111E     MOV [W14+34], W2
008896  9011AE     MOV [W14+36], W3
008898  981752     MOV W2, [W14+42]
00889A  981763     MOV W3, [W14+44]
1309:                 vert_x[ii] = (int) (x3 + centerX);
00889C  90180E     MOV [W14+48], W0
00889E  DE80CF     ASR W0, #15, W1
0088A0  07BE8B     RCALL ___floatsisf
0088A2  90113E     MOV [W14+38], W2
0088A4  9011CE     MOV [W14+40], W3
0088A6  07BD9A     RCALL ___addsf3
0088A8  07BE4B     RCALL ___fixsfsi
0088AA  780080     MOV W0, W1
0088AC  78001E     MOV [W14], W0
0088AE  400100     ADD W0, W0, W2
0088B0  2133E0     MOV #0x133E, W0
0088B2  410000     ADD W2, W0, W0
0088B4  780801     MOV W1, [W0]
1310:                 vert_y[ii] = (int) (y3 + centerY);
0088B6  90181E     MOV [W14+50], W0
0088B8  DE80CF     ASR W0, #15, W1
0088BA  07BE7E     RCALL ___floatsisf
0088BC  90115E     MOV [W14+42], W2
0088BE  9011EE     MOV [W14+44], W3
0088C0  07BD8D     RCALL ___addsf3
0088C2  07BE3E     RCALL ___fixsfsi
0088C4  780080     MOV W0, W1
0088C6  78001E     MOV [W14], W0
0088C8  400100     ADD W0, W0, W2
0088CA  213440     MOV #0x1344, W0
0088CC  410000     ADD W2, W0, W0
0088CE  780801     MOV W1, [W0]
1311:                }
1312:              }
0088D8  FA8000     ULNK
0088DA  060000     RETURN
1313:              
1314:              /*
1315:               * maps the computed triangle vertex coordinates to the new epaper coordinate system
1316:               */
1317:              void map_triangle_coords() {
0088DC  FA0006     LNK #0x6
1318:                int tmpx, tmpy;
1319:                int ii;
1320:                for (ii=0; ii< VERT_LENGTH; ii++ ) {
0088DE  EB0000     CLR W0
0088E0  780F00     MOV W0, [W14]
0088E2  37001B     BRA .L61
008918  E80F1E     INC [W14], [W14]
00891A  78001E     MOV [W14], W0
00891C  500FE2     SUB W0, #0x2, [W15]
00891E  34FFE2     BRA LE, .L62
1321:                  tmpy = vert_x[ii];
0088E4  78001E     MOV [W14], W0
0088E6  400080     ADD W0, W0, W1
0088E8  2133E0     MOV #0x133E, W0
0088EA  408000     ADD W1, W0, W0
0088EC  780090     MOV [W0], W1
0088EE  980711     MOV W1, [W14+2]
1322:                  tmpx = EP_WIDTH - 1 - vert_y[ii];
0088F0  78001E     MOV [W14], W0
0088F2  400080     ADD W0, W0, W1
0088F4  213440     MOV #0x1344, W0
0088F6  408000     ADD W1, W0, W0
0088F8  780010     MOV [W0], W0
0088FA  200AF1     MOV #0xAF, W1
0088FC  508000     SUB W1, W0, W0
0088FE  980720     MOV W0, [W14+4]
1323:                  vert_x[ii] = tmpx;
008900  78001E     MOV [W14], W0
008902  400080     ADD W0, W0, W1
008904  2133E0     MOV #0x133E, W0
008906  408000     ADD W1, W0, W0
008908  9000AE     MOV [W14+4], W1
00890A  780801     MOV W1, [W0]
1324:                  vert_y[ii] = tmpy;
00890C  78001E     MOV [W14], W0
00890E  400080     ADD W0, W0, W1
008910  213440     MOV #0x1344, W0
008912  408000     ADD W1, W0, W0
008914  90009E     MOV [W14+2], W1
008916  780801     MOV W1, [W0]
1325:                }
1326:              }
008920  FA8000     ULNK
008922  060000     RETURN
1327:              
1328:              /*
1329:               * maps the computed digit coordinates to the new epaper coordinate system
1330:               */
1331:              void map_digit_coords() {
008924  FA0008     LNK #0x8
1332:                int tmpx, tmpy, tmp_8bit;
1333:                int ii;
1334:                for (ii=0; ii< DIGIT_POS_LENGTH; ii++ ) {
008926  EB0000     CLR W0
008928  980710     MOV W0, [W14+2]
00892A  370043     BRA .L64
0089AC  90001E     MOV [W14+2], W0
0089AE  E80000     INC W0, W0
0089B0  980710     MOV W0, [W14+2]
0089B2  90001E     MOV [W14+2], W0
0089B4  500FE1     SUB W0, #0x1, [W15]
0089B6  34FFBA     BRA LE, .L71
1335:                  tmpy = digit_pos_x[ii];
00892C  90001E     MOV [W14+2], W0
00892E  400080     ADD W0, W0, W1
008930  208800     MOV #0x880, W0
008932  408000     ADD W1, W0, W0
008934  780090     MOV [W0], W1
008936  980721     MOV W1, [W14+4]
1336:                  tmpx = EP_WIDTH - 1 - digit_pos_y[ii];
008938  90001E     MOV [W14+2], W0
00893A  400080     ADD W0, W0, W1
00893C  208840     MOV #0x884, W0
00893E  408000     ADD W1, W0, W0
008940  780010     MOV [W0], W0
008942  200AF1     MOV #0xAF, W1
008944  508000     SUB W1, W0, W0
008946  980730     MOV W0, [W14+6]
1337:                  if ( (tmpx % 8) == 0) {
008948  90003E     MOV [W14+6], W0
00894A  600067     AND W0, #0x7, W0
00894C  E00000     CP0 W0
00894E  3A0003     BRA NZ, .L65
1338:                    tmp_8bit = 0;    
008950  EB0000     CLR W0
008952  780F00     MOV W0, [W14]
008954  37000A     BRA .L66
1339:                  }
1340:                  else {
1341:                    tmp_8bit = (8 - (tmpx % 8));
008956  9000BE     MOV [W14+6], W1
008958  280070     MOV #0x8007, W0
00895A  608000     AND W1, W0, W0
00895C  E00000     CP0 W0
00895E  3D0004     BRA GE, .L67
008960  E90000     DEC W0, W0
008962  2FFF81     MOV #0xFFF8, W1
008964  708000     IOR W1, W0, W0
008966  E80000     INC W0, W0
008968  100F68     SUBR W0, #0x8, [W14]
1342:                  }
1343:                  // debug
1344:                  tmp_8bit = 0;
00896A  EB0000     CLR W0
00896C  780F00     MOV W0, [W14]
1345:                  digit_pos_x[ii] = tmpx + tmp_8bit;
00896E  90003E     MOV [W14+6], W0
008970  40009E     ADD W0, [W14], W1
008972  90001E     MOV [W14+2], W0
008974  400100     ADD W0, W0, W2
008976  208800     MOV #0x880, W0
008978  410000     ADD W2, W0, W0
00897A  780801     MOV W1, [W0]
1346:                  if ( (tmpy % 8) == 0) {
00897C  90002E     MOV [W14+4], W0
00897E  600067     AND W0, #0x7, W0
008980  E00000     CP0 W0
008982  3A0003     BRA NZ, .L68
1347:                    tmp_8bit = 0;    
008984  EB0000     CLR W0
008986  780F00     MOV W0, [W14]
008988  37000A     BRA .L69
1348:                  }
1349:                  else {
1350:                    tmp_8bit = (8 - (tmpy % 8));
00898A  9000AE     MOV [W14+4], W1
00898C  280070     MOV #0x8007, W0
00898E  608000     AND W1, W0, W0
008990  E00000     CP0 W0
008992  3D0004     BRA GE, .L70
008994  E90000     DEC W0, W0
008996  2FFF81     MOV #0xFFF8, W1
008998  708000     IOR W1, W0, W0
00899A  E80000     INC W0, W0
00899C  100F68     SUBR W0, #0x8, [W14]
1351:                  }
1352:                  // debug
1353:                  digit_pos_y[ii] = tmpy + tmp_8bit;
00899E  90002E     MOV [W14+4], W0
0089A0  40009E     ADD W0, [W14], W1
0089A2  90001E     MOV [W14+2], W0
0089A4  400100     ADD W0, W0, W2
0089A6  208840     MOV #0x884, W0
0089A8  410000     ADD W2, W0, W0
0089AA  780801     MOV W1, [W0]
1354:                }
1355:              }
0089B8  FA8000     ULNK
0089BA  060000     RETURN
1356:              
1357:              /**
1358:               * this function clears the rectangle where the prevoius indicator was drawn
1359:               */
1360:              void clear_indicator(int min_x, int min_y, int max_x, int max_y)
1361:              {
0089BC  FA0010     LNK #0x10
0089BE  980740     MOV W0, [W14+8]
0089C0  980751     MOV W1, [W14+10]
0089C2  980762     MOV W2, [W14+12]
0089C4  980773     MOV W3, [W14+14]
1362:               int tmpi;
1363:                int tmpj;
1364:                int x, y;
1365:              
1366:              
1367:                //partial updating the screen: Black
1368:                writeCMD(0x14);
0089C6  B3C140     MOV.B #0x14, W0
0089C8  07FCD2     RCALL writeCMD
1369:                writeData(0x00);  //1st half x
0089CA  EB4000     CLR.B W0
0089CC  07FCDF     RCALL writeData
1370:                writeData(min_x);  //2nd half x
0089CE  90004E     MOV [W14+8], W0
0089D0  784000     MOV.B W0, W0
0089D2  07FCDC     RCALL writeData
1371:                writeData(0x00);  //1st half y
0089D4  EB4000     CLR.B W0
0089D6  07FCDA     RCALL writeData
1372:                writeData(min_y);  //2nd half y
0089D8  90005E     MOV [W14+10], W0
0089DA  784000     MOV.B W0, W0
0089DC  07FCD7     RCALL writeData
1373:                writeData(0x00);  //1st half w
0089DE  EB4000     CLR.B W0
0089E0  07FCD5     RCALL writeData
1374:                writeData(max_x - min_x);  //2nd half w
0089E2  90006E     MOV [W14+12], W0
0089E4  784080     MOV.B W0, W1
0089E6  90004E     MOV [W14+8], W0
0089E8  784000     MOV.B W0, W0
0089EA  50C000     SUB.B W1, W0, W0
0089EC  07FCCF     RCALL writeData
1375:                writeData(0x00);  //1st half l
0089EE  EB4000     CLR.B W0
0089F0  07FCCD     RCALL writeData
1376:                writeData(max_y - min_y);  //2nd half l
0089F2  90007E     MOV [W14+14], W0
0089F4  784080     MOV.B W0, W1
0089F6  90005E     MOV [W14+10], W0
0089F8  784000     MOV.B W0, W0
0089FA  50C000     SUB.B W1, W0, W0
0089FC  07FCC7     RCALL writeData
1377:              
1378:                tmpi = 0;
0089FE  EB0000     CLR W0
008A00  980730     MOV W0, [W14+6]
1379:                tmpj = 0;
008A02  EB0000     CLR W0
008A04  780F00     MOV W0, [W14]
1380:                for (y = min_y; y < max_y; y++)
008A06  9000DE     MOV [W14+10], W1
008A08  980721     MOV W1, [W14+4]
008A0A  370016     BRA .L73
008A32  90002E     MOV [W14+4], W0
008A34  E80000     INC W0, W0
008A36  980720     MOV W0, [W14+4]
008A38  9000AE     MOV [W14+4], W1
008A3A  90007E     MOV [W14+14], W0
008A3C  508F80     SUB W1, W0, [W15]
008A3E  35FFE6     BRA LT, .L77
1381:                {
1382:                  for (x = min_x; x < max_x; x++) 
008A0C  9000CE     MOV [W14+8], W1
008A0E  980711     MOV W1, [W14+2]
008A10  37000C     BRA .L74
008A24  90001E     MOV [W14+2], W0
008A26  E80000     INC W0, W0
008A28  980710     MOV W0, [W14+2]
008A2A  90009E     MOV [W14+2], W1
008A2C  90006E     MOV [W14+12], W0
008A2E  508F80     SUB W1, W0, [W15]
008A30  35FFF0     BRA LT, .L76
1383:                  {
1384:                    tmpj++;
008A12  E80F1E     INC [W14], [W14]
1385:                    if ( (tmpj % 8 ) == 0 ) {
008A14  78001E     MOV [W14], W0
008A16  600067     AND W0, #0x7, W0
008A18  E00000     CP0 W0
008A1A  3A0004     BRA NZ, .L75
1386:                      writeData((uint8_t)0);
008A1C  EB4000     CLR.B W0
008A1E  07FCB6     RCALL writeData
1387:                      tmpj = 0;
008A20  EB0000     CLR W0
008A22  780F00     MOV W0, [W14]
1388:                    }
1389:                  }
1390:                }
1391:                ////partial updating the screen: Red
1392:                //writeCMD(0x15);
1393:                //writeData(0x00);  //1st half x
1394:                //writeData(min_x-1);  //2nd half x
1395:                //writeData(0x00);  //1st half y
1396:                //writeData(min_y);  //2nd half y
1397:                //writeData(0x00);  //1st half w
1398:                //writeData(max_x - min_x);  //2nd half w
1399:                //writeData(0x00);  //1st half l
1400:                //writeData(max_y - min_y);  //2nd half l
1401:              
1402:                //for (int h = 0; h < (max_y - min_y); h++)
1403:                //{
1404:                //  for (int i = 0; i < ((max_x - min_x)/8); i++) 
1405:                //  {
1406:                //    writeData(0x00);
1407:                //  }
1408:                //}
1409:              
1410:              
1411:                //partial refresh of the same area as the partial update
1412:                writeCMD(0x16);
008A40  B3C160     MOV.B #0x16, W0
008A42  07FC95     RCALL writeCMD
1413:                writeData(0x00);  //1st half x
008A44  EB4000     CLR.B W0
008A46  07FCA2     RCALL writeData
1414:                writeData(min_x);  //2nd half x
008A48  90004E     MOV [W14+8], W0
008A4A  784000     MOV.B W0, W0
008A4C  07FC9F     RCALL writeData
1415:                writeData(0x00);  //1st half y
008A4E  EB4000     CLR.B W0
008A50  07FC9D     RCALL writeData
1416:                writeData(min_y);  //2nd half y
008A52  90005E     MOV [W14+10], W0
008A54  784000     MOV.B W0, W0
008A56  07FC9A     RCALL writeData
1417:                writeData(0x00);  //1st half w
008A58  EB4000     CLR.B W0
008A5A  07FC98     RCALL writeData
1418:                writeData(max_x - min_x);  //2nd half w
008A5C  90006E     MOV [W14+12], W0
008A5E  784080     MOV.B W0, W1
008A60  90004E     MOV [W14+8], W0
008A62  784000     MOV.B W0, W0
008A64  50C000     SUB.B W1, W0, W0
008A66  07FC92     RCALL writeData
1419:                writeData(0x00);  //1st half l
008A68  EB4000     CLR.B W0
008A6A  07FC90     RCALL writeData
1420:                writeData(max_y - min_y);  //2nd half l
008A6C  90007E     MOV [W14+14], W0
008A6E  784080     MOV.B W0, W1
008A70  90005E     MOV [W14+10], W0
008A72  784000     MOV.B W0, W0
008A74  50C000     SUB.B W1, W0, W0
008A76  07FC8A     RCALL writeData
1421:                
1422:                while (0 == BSY_DISP_GetValue());
008A78  000000     NOP
008A7A  803620     MOV PORTF, W0
008A7C  600061     AND W0, #0x1, W0
008A7E  E00000     CP0 W0
008A80  32FFFC     BRA Z, .L78
1423:                // is this delay necessary//wait so you can view the screen
1424:                //__delay_ms(7000);
1425:                  
1426:              }
008A82  FA8000     ULNK
008A84  060000     RETURN
1427:              
1428:              /*
1429:               * updates the indicator on the epaper screen based on the defintion of pixels in 
1430:               * indicator definitions
1431:               */
1432:              void update_indicator() {
008A86  FA0016     LNK #0x16
1433:                // update the vert_x, very_y indices region
1434:                int min_x, max_x, min_y, max_y;
1435:                int index;
1436:                int tmpi;
1437:                int tmpj;
1438:                int tmp_height, tmp_width;
1439:                int x, y;
1440:                min_x = b_vert_x[0];
008A88  208500     MOV #0x850, W0
008A8A  780090     MOV [W0], W1
008A8C  980741     MOV W1, [W14+8]
1441:                min_y = b_vert_y[0];
008A8E  208580     MOV #0x858, W0
008A90  780090     MOV [W0], W1
008A92  980751     MOV W1, [W14+10]
1442:                max_x = b_vert_x[2];
008A94  208500     MOV #0x850, W0
008A96  9000A0     MOV [W0+4], W1
008A98  980761     MOV W1, [W14+12]
1443:                max_y = b_vert_y[2];
008A9A  208580     MOV #0x858, W0
008A9C  9000A0     MOV [W0+4], W1
008A9E  980771     MOV W1, [W14+14]
1444:              
1445:                tmp_width = max_x - min_x;
008AA0  9000EE     MOV [W14+12], W1
008AA2  90004E     MOV [W14+8], W0
008AA4  508000     SUB W1, W0, W0
008AA6  980F00     MOV W0, [W14+16]
1446:                if ( (tmp_width % 8) == 0 ) {
008AA8  90080E     MOV [W14+16], W0
008AAA  600067     AND W0, #0x7, W0
008AAC  E00000     CP0 W0
008AAE  3A0003     BRA NZ, .L80
1447:                  tmpi = 0;
008AB0  EB0000     CLR W0
008AB2  780F00     MOV W0, [W14]
008AB4  37000A     BRA .L81
1448:                }
1449:                else {
1450:                  tmpi = tmp_width % 8;
008AB6  90088E     MOV [W14+16], W1
008AB8  280070     MOV #0x8007, W0
008ABA  608000     AND W1, W0, W0
008ABC  E00000     CP0 W0
008ABE  3D0004     BRA GE, .L82
008AC0  E90000     DEC W0, W0
008AC2  2FFF81     MOV #0xFFF8, W1
008AC4  708000     IOR W1, W0, W0
008AC6  E80000     INC W0, W0
008AC8  780F00     MOV W0, [W14]
1451:                }
1452:                min_x = min_x - tmpi;
008ACA  90004E     MOV [W14+8], W0
008ACC  50001E     SUB W0, [W14], W0
008ACE  980740     MOV W0, [W14+8]
1453:                
1454:                //// make sure min_x is at 8 bit boundary, subtract to reach the boundary
1455:                //if ( (min_x % 8 ) == 0 ) {
1456:                //  tmpi = 0;
1457:                //}
1458:                //else {
1459:                //  tmpi = min_x % 8;
1460:                //}
1461:                //min_x = min_x - tmpi;
1462:              
1463:                tmp_height = max_y - min_y;
008AD0  9000FE     MOV [W14+14], W1
008AD2  90005E     MOV [W14+10], W0
008AD4  508000     SUB W1, W0, W0
008AD6  980F10     MOV W0, [W14+18]
1464:                if ( (tmp_height % 8 ) == 0 ) {
008AD8  90081E     MOV [W14+18], W0
008ADA  600067     AND W0, #0x7, W0
008ADC  E00000     CP0 W0
008ADE  3A0003     BRA NZ, .L83
1465:                  tmpi = 0;
008AE0  EB0000     CLR W0
008AE2  780F00     MOV W0, [W14]
008AE4  37000A     BRA .L84
1466:                }
1467:                else {
1468:                  tmpi = tmp_height % 8;
008AE6  90089E     MOV [W14+18], W1
008AE8  280070     MOV #0x8007, W0
008AEA  608000     AND W1, W0, W0
008AEC  E00000     CP0 W0
008AEE  3D0004     BRA GE, .L85
008AF0  E90000     DEC W0, W0
008AF2  2FFF81     MOV #0xFFF8, W1
008AF4  708000     IOR W1, W0, W0
008AF6  E80000     INC W0, W0
008AF8  780F00     MOV W0, [W14]
1469:                }
1470:                min_y = min_y - tmpi;
008AFA  90005E     MOV [W14+10], W0
008AFC  50001E     SUB W0, [W14], W0
008AFE  980750     MOV W0, [W14+10]
1471:              
1472:                draw_rect_min_x = min_x;
008B00  9000CE     MOV [W14+8], W1
008B02  884511     MOV W1, draw_rect_min_x
1473:                draw_rect_min_y = min_y;
008B04  9000DE     MOV [W14+10], W1
008B06  884521     MOV W1, draw_rect_min_y
1474:                draw_rect_max_x = max_x;
008B08  9000EE     MOV [W14+12], W1
008B0A  884531     MOV W1, draw_rect_max_x
1475:                draw_rect_max_y = max_y;
008B0C  9000FE     MOV [W14+14], W1
008B0E  884541     MOV W1, draw_rect_max_y
1476:                
1477:                //partial updating the screen: Black
1478:                writeCMD(0x14);
008B10  B3C140     MOV.B #0x14, W0
008B12  07FC2D     RCALL writeCMD
1479:                writeData(0x00);  //1st half x
008B14  EB4000     CLR.B W0
008B16  07FC3A     RCALL writeData
1480:                writeData(min_x);  //2nd half x
008B18  90004E     MOV [W14+8], W0
008B1A  784000     MOV.B W0, W0
008B1C  07FC37     RCALL writeData
1481:                writeData(0x00);  //1st half y
008B1E  EB4000     CLR.B W0
008B20  07FC35     RCALL writeData
1482:                writeData(min_y);  //2nd half y
008B22  90005E     MOV [W14+10], W0
008B24  784000     MOV.B W0, W0
008B26  07FC32     RCALL writeData
1483:                writeData(0x00);  //1st half w
008B28  EB4000     CLR.B W0
008B2A  07FC30     RCALL writeData
1484:                writeData(max_x - min_x);  //2nd half w
008B2C  90006E     MOV [W14+12], W0
008B2E  784080     MOV.B W0, W1
008B30  90004E     MOV [W14+8], W0
008B32  784000     MOV.B W0, W0
008B34  50C000     SUB.B W1, W0, W0
008B36  07FC2A     RCALL writeData
1485:                writeData(0x00);  //1st half l
008B38  EB4000     CLR.B W0
008B3A  07FC28     RCALL writeData
1486:                writeData(max_y - min_y);  //2nd half l
008B3C  90007E     MOV [W14+14], W0
008B3E  784080     MOV.B W0, W1
008B40  90005E     MOV [W14+10], W0
008B42  784000     MOV.B W0, W0
008B44  50C000     SUB.B W1, W0, W0
008B46  07FC22     RCALL writeData
1487:              
1488:                tmpi = 0;
008B48  EB0000     CLR W0
008B4A  780F00     MOV W0, [W14]
1489:                tmpj = 0;
008B4C  EB0000     CLR W0
008B4E  980710     MOV W0, [W14+2]
1490:                for (y = min_y; y < max_y; y++)
008B50  9000DE     MOV [W14+10], W1
008B52  980731     MOV W1, [W14+6]
008B54  37002B     BRA .L86
008BA6  90003E     MOV [W14+6], W0
008BA8  E80000     INC W0, W0
008BAA  980730     MOV W0, [W14+6]
008BAC  9000BE     MOV [W14+6], W1
008BAE  90007E     MOV [W14+14], W0
008BB0  508F80     SUB W1, W0, [W15]
008BB2  35FFD1     BRA LT, .L91
1491:                {
1492:                  for (x = min_x; x < max_x; x++) 
008B56  9000CE     MOV [W14+8], W1
008B58  980721     MOV W1, [W14+4]
008B5A  370021     BRA .L87
008B98  90002E     MOV [W14+4], W0
008B9A  E80000     INC W0, W0
008B9C  980720     MOV W0, [W14+4]
008B9E  9000AE     MOV [W14+4], W1
008BA0  90006E     MOV [W14+12], W0
008BA2  508F80     SUB W1, W0, [W15]
008BA4  35FFDB     BRA LT, .L90
1493:                  {
1494:                    index = x + y* EP_WIDTH;
008B5C  9000BE     MOV [W14+6], W1
008B5E  200B00     MOV #0xB0, W0
008B60  B98800     MUL.SS W1, W0, W0
008B62  780080     MOV W0, W1
008B64  90002E     MOV [W14+4], W0
008B66  408000     ADD W1, W0, W0
008B68  980F20     MOV W0, [W14+20]
1495:                    if (indexInBuffer(index)) {
008B6A  90082E     MOV [W14+20], W0
008B6C  07012A     RCALL indexInBuffer
008B6E  E00000     CP0 W0
008B70  320005     BRA Z, .L88
1496:                      tmpi +=  (1 << (7 - tmpj));
008B72  90001E     MOV [W14+2], W0
008B74  100067     SUBR W0, #0x7, W0
008B76  200011     MOV #0x1, W1
008B78  DD0800     SL W1, W0, W0
008B7A  400F1E     ADD W0, [W14], [W14]
1497:                    }
1498:                    tmpj++;
008B7C  90001E     MOV [W14+2], W0
008B7E  E80000     INC W0, W0
008B80  980710     MOV W0, [W14+2]
1499:                    if ( (tmpj % 8 ) == 0 ) {
008B82  90001E     MOV [W14+2], W0
008B84  600067     AND W0, #0x7, W0
008B86  E00000     CP0 W0
008B88  3A0007     BRA NZ, .L89
1500:                      writeData((uint8_t)tmpi);
008B8A  78001E     MOV [W14], W0
008B8C  784000     MOV.B W0, W0
008B8E  07FBFE     RCALL writeData
1501:                      tmpi = 0;
008B90  EB0000     CLR W0
008B92  780F00     MOV W0, [W14]
1502:                      tmpj = 0;
008B94  EB0000     CLR W0
008B96  980710     MOV W0, [W14+2]
1503:                    }
1504:                  }
1505:                }
1506:                ////partial updating the screen: Red
1507:                //writeCMD(0x15);
1508:                //writeData(0x00);  //1st half x
1509:                //writeData(min_x-1);  //2nd half x
1510:                //writeData(0x00);  //1st half y
1511:                //writeData(min_y);  //2nd half y
1512:                //writeData(0x00);  //1st half w
1513:                //writeData(max_x - min_x);  //2nd half w
1514:                //writeData(0x00);  //1st half l
1515:                //writeData(max_y - min_y);  //2nd half l
1516:              
1517:                //for (int h = 0; h < (max_y - min_y); h++)
1518:                //{
1519:                //  for (int i = 0; i < ((max_x - min_x)/8); i++) 
1520:                //  {
1521:                //    writeData(0x00);
1522:                //  }
1523:                //}
1524:              
1525:              
1526:                //partial refresh of the same area as the partial update
1527:                writeCMD(0x16);
008BB4  B3C160     MOV.B #0x16, W0
008BB6  07FBDB     RCALL writeCMD
1528:                writeData(0x00);  //1st half x
008BB8  EB4000     CLR.B W0
008BBA  07FBE8     RCALL writeData
1529:                writeData(min_x);  //2nd half x
008BBC  90004E     MOV [W14+8], W0
008BBE  784000     MOV.B W0, W0
008BC0  07FBE5     RCALL writeData
1530:                writeData(0x00);  //1st half y
008BC2  EB4000     CLR.B W0
008BC4  07FBE3     RCALL writeData
1531:                writeData(min_y);  //2nd half y
008BC6  90005E     MOV [W14+10], W0
008BC8  784000     MOV.B W0, W0
008BCA  07FBE0     RCALL writeData
1532:                writeData(0x00);  //1st half w
008BCC  EB4000     CLR.B W0
008BCE  07FBDE     RCALL writeData
1533:                writeData(max_x - min_x);  //2nd half w
008BD0  90006E     MOV [W14+12], W0
008BD2  784080     MOV.B W0, W1
008BD4  90004E     MOV [W14+8], W0
008BD6  784000     MOV.B W0, W0
008BD8  50C000     SUB.B W1, W0, W0
008BDA  07FBD8     RCALL writeData
1534:                writeData(0x00);  //1st half l
008BDC  EB4000     CLR.B W0
008BDE  07FBD6     RCALL writeData
1535:                writeData(max_y - min_y);  //2nd half l
008BE0  90007E     MOV [W14+14], W0
008BE2  784080     MOV.B W0, W1
008BE4  90005E     MOV [W14+10], W0
008BE6  784000     MOV.B W0, W0
008BE8  50C000     SUB.B W1, W0, W0
008BEA  07FBD0     RCALL writeData
1536:                
1537:                while (0 == BSY_DISP_GetValue());
008BEC  000000     NOP
008BEE  803620     MOV PORTF, W0
008BF0  600061     AND W0, #0x1, W0
008BF2  E00000     CP0 W0
008BF4  32FFFC     BRA Z, .L92
1538:                // is this delay necessary//wait so you can view the screen
1539:                //__delay_ms(7000);
1540:               
1541:              }
008BF6  FA8000     ULNK
008BF8  060000     RETURN
1542:              
1543:              void draw_indicator(int centerX, int centerY, int diameter, int angle) {
008BFA  FA000C     LNK #0xC
008BFC  980720     MOV W0, [W14+4]
008BFE  980731     MOV W1, [W14+6]
008C00  980742     MOV W2, [W14+8]
008C02  980753     MOV W3, [W14+10]
1544:                int tmpx, tmpy;
1545:                tmpx = centerX;
008C04  9000AE     MOV [W14+4], W1
008C06  780F01     MOV W1, [W14]
1546:                tmpy = centerY - (diameter/2)-3;
008C08  90004E     MOV [W14+8], W0
008C0A  DE00CF     LSR W0, #15, W1
008C0C  408000     ADD W1, W0, W0
008C0E  D18000     ASR W0, W0
008C10  9000BE     MOV [W14+6], W1
008C12  508000     SUB W1, W0, W0
008C14  500063     SUB W0, #0x3, W0
008C16  980710     MOV W0, [W14+2]
1547:                vert_x[0] = tmpx; vert_y[0] = tmpy;
008C18  78009E     MOV [W14], W1
008C1A  8899F1     MOV W1, vert_x
008C1C  90009E     MOV [W14+2], W1
008C1E  889A21     MOV W1, vert_y
1548:                vert_x[1] = tmpx - 9; vert_y[1] = tmpy - 10;
008C20  78009E     MOV [W14], W1
008C22  508069     SUB W1, #0x9, W0
008C24  889A00     MOV W0, 0x1340
008C26  90001E     MOV [W14+2], W0
008C28  50006A     SUB W0, #0xA, W0
008C2A  889A30     MOV W0, 0x1346
1549:                vert_x[2] = tmpx + 9; vert_y[2] = tmpy - 10;
008C2C  78009E     MOV [W14], W1
008C2E  408069     ADD W1, #0x9, W0
008C30  889A10     MOV W0, 0x1342
008C32  90001E     MOV [W14+2], W0
008C34  50006A     SUB W0, #0xA, W0
008C36  889A40     MOV W0, 0x1348
1550:                rotate_triangle(angle, centerX, centerY); // in degree
008C38  90013E     MOV [W14+6], W2
008C3A  9000AE     MOV [W14+4], W1
008C3C  90005E     MOV [W14+10], W0
008C3E  07FDCE     RCALL rotate_triangle
1551:                map_triangle_coords();
008C40  07FE4D     RCALL map_triangle_coords
1552:                app_fill_triangle(vert_x[0], vert_y[0], vert_x[1], vert_y[1], vert_x[2], vert_y[2], 0);
008C42  809A45     MOV 0x1348, W5
008C44  809A14     MOV 0x1342, W4
008C46  809A33     MOV 0x1346, W3
008C48  809A02     MOV 0x1340, W2
008C4A  809A21     MOV vert_y, W1
008C4C  8099F0     MOV vert_x, W0
008C4E  EB0300     CLR W6
008C50  07FD2F     RCALL app_fill_triangle
1553:                
1554:              }
008C52  FA8000     ULNK
008C54  060000     RETURN
1555:              
1556:              void draw_temp_indicator(int centerX, int centerY, int diameter, int angle) {
008C56  FA000C     LNK #0xC
008C58  980720     MOV W0, [W14+4]
008C5A  980731     MOV W1, [W14+6]
008C5C  980742     MOV W2, [W14+8]
008C5E  980753     MOV W3, [W14+10]
1557:                int tmpx, tmpy;
1558:                tmpx = centerX;
008C60  9000AE     MOV [W14+4], W1
008C62  780F01     MOV W1, [W14]
1559:                tmpy = centerY - (diameter/2) + 12;
008C64  90004E     MOV [W14+8], W0
008C66  DE00CF     LSR W0, #15, W1
008C68  408000     ADD W1, W0, W0
008C6A  D18000     ASR W0, W0
008C6C  9000BE     MOV [W14+6], W1
008C6E  508000     SUB W1, W0, W0
008C70  40006C     ADD W0, #0xC, W0
008C72  980710     MOV W0, [W14+2]
1560:                vert_x[0] = tmpx; vert_y[0] = tmpy;
008C74  78009E     MOV [W14], W1
008C76  8899F1     MOV W1, vert_x
008C78  90009E     MOV [W14+2], W1
008C7A  889A21     MOV W1, vert_y
1561:                vert_x[1] = tmpx - 5; vert_y[1] = tmpy + 12;
008C7C  78009E     MOV [W14], W1
008C7E  508065     SUB W1, #0x5, W0
008C80  889A00     MOV W0, 0x1340
008C82  90001E     MOV [W14+2], W0
008C84  40006C     ADD W0, #0xC, W0
008C86  889A30     MOV W0, 0x1346
1562:                vert_x[2] = tmpx + 5; vert_y[2] = tmpy + 12;
008C88  78009E     MOV [W14], W1
008C8A  408065     ADD W1, #0x5, W0
008C8C  889A10     MOV W0, 0x1342
008C8E  90001E     MOV [W14+2], W0
008C90  40006C     ADD W0, #0xC, W0
008C92  889A40     MOV W0, 0x1348
1563:                rotate_triangle(angle, centerX, centerY); // in degree
008C94  90013E     MOV [W14+6], W2
008C96  9000AE     MOV [W14+4], W1
008C98  90005E     MOV [W14+10], W0
008C9A  07FDA0     RCALL rotate_triangle
1564:                map_triangle_coords();
008C9C  07FE1F     RCALL map_triangle_coords
1565:                app_fill_triangle(vert_x[0], vert_y[0], vert_x[1], vert_y[1], vert_x[2], vert_y[2], 0);
008C9E  809A45     MOV 0x1348, W5
008CA0  809A14     MOV 0x1342, W4
008CA2  809A33     MOV 0x1346, W3
008CA4  809A02     MOV 0x1340, W2
008CA6  809A21     MOV vert_y, W1
008CA8  8099F0     MOV vert_x, W0
008CAA  EB0300     CLR W6
008CAC  07FD01     RCALL app_fill_triangle
1566:              }
008CAE  FA8000     ULNK
008CB0  060000     RETURN
1567:              
1568:              
1569:              /*
1570:               * draws the background gauge with lower and upper limits
1571:               */
1572:              void draw_gauge() {
008CB2  FA0002     LNK #0x2
1573:                  int i;
1574:                  //Set the LUT from the OTP since we're doing partial refreshes
1575:                  //setOTPLUT();
1576:                  setRegisterLUT(); //Produces lines
008CB4  07FBDC     RCALL setRegisterLUT
1577:                  //start data transmission 1: B&W data
1578:                  writeCMD(0x10);
008CB6  B3C100     MOV.B #0x10, W0
008CB8  07FB5A     RCALL writeCMD
1579:                  for (i = 0; i < 5808; i++)
008CBA  EB0000     CLR W0
008CBC  780F00     MOV W0, [W14]
008CBE  370005     BRA .L96
008CC8  E80F1E     INC [W14], [W14]
008CCA  216AF0     MOV #0x16AF, W0
008CCC  78009E     MOV [W14], W1
008CCE  508F80     SUB W1, W0, [W15]
008CD0  34FFF7     BRA LE, .L97
1580:                  {
1581:                    writeData(Mono_1BPP[i]);
008CC0  2A7100     MOV #0xA710, W0
008CC2  40001E     ADD W0, [W14], W0
008CC4  784010     MOV.B [W0], W0
008CC6  07FB62     RCALL writeData
1582:                  }
1583:              
1584:                  //start data transmission 2: red data
1585:                  writeCMD(0x13);
008CD2  B3C130     MOV.B #0x13, W0
008CD4  07FB4C     RCALL writeCMD
1586:                  for (i = 0; i < 5808; i++)
008CD6  EB0000     CLR W0
008CD8  780F00     MOV W0, [W14]
008CDA  370005     BRA .L98
008CE4  E80F1E     INC [W14], [W14]
008CE6  216AF0     MOV #0x16AF, W0
008CE8  78009E     MOV [W14], W1
008CEA  508F80     SUB W1, W0, [W15]
008CEC  34FFF7     BRA LE, .L99
1587:                  {
1588:                    writeData(Red_1BPP[i]);
008CDC  2BDC00     MOV #0xBDC0, W0
008CDE  40001E     ADD W0, [W14], W0
008CE0  784010     MOV.B [W0], W0
008CE2  07FB54     RCALL writeData
1589:                  }
1590:              
1591:                  //refresh the display
1592:                  writeCMD(0x12);
008CEE  B3C120     MOV.B #0x12, W0
008CF0  07FB3E     RCALL writeCMD
1593:                  while (0 == BSY_DISP_GetValue());
008CF2  000000     NOP
008CF4  803620     MOV PORTF, W0
008CF6  600061     AND W0, #0x1, W0
008CF8  E00000     CP0 W0
008CFA  32FFFC     BRA Z, .L100
1594:                  //delay(5000);
1595:                  
1596:              }
008CFC  FA8000     ULNK
008CFE  060000     RETURN
1597:              
1598:              /**
1599:               * drwas the heat setpoint indicator
1600:               * @param heat_setpoint_degF
1601:               */
1602:              void draw_heat_sp_indicator(int heat_setpoint_degF)
1603:              {
008D00  FA000C     LNK #0xC
008D02  980750     MOV W0, [W14+10]
1604:                int tmpx, tmpy;
1605:                int heat_sp_angle ;
1606:                float angles_per_degF;
1607:                tmpx = EP_HEIGHT/2;
008D04  200840     MOV #0x84, W0
008D06  980710     MOV W0, [W14+2]
1608:                tmpy = EP_WIDTH - 50;
008D08  2007E0     MOV #0x7E, W0
008D0A  980720     MOV W0, [W14+4]
1609:                angles_per_degF = 180.0/(90.0-50.0);
008D0C  200000     MOV #0x0, W0
008D0E  240901     MOV #0x4090, W1
008D10  980730     MOV W0, [W14+6]
008D12  980741     MOV W1, [W14+8]
1610:                if (heat_setpoint_degF <= 50) {
008D14  9000DE     MOV [W14+10], W1
008D16  200320     MOV #0x32, W0
008D18  508F80     SUB W1, W0, [W15]
008D1A  3C0003     BRA GT, .L102
1611:                    heat_sp_angle = -90;
008D1C  2FFA60     MOV #0xFFA6, W0
008D1E  780F00     MOV W0, [W14]
008D20  37000B     BRA .L103
1612:                }
1613:                else {
1614:                   heat_sp_angle = (int) ((heat_setpoint_degF - 50) * angles_per_degF);
008D22  90005E     MOV [W14+10], W0
008D24  B10320     SUB #0x32, W0
008D26  DE80CF     ASR W0, #15, W1
008D28  07BC47     RCALL ___floatsisf
008D2A  90013E     MOV [W14+6], W2
008D2C  9001CE     MOV [W14+8], W3
008D2E  07BCA4     RCALL ___mulsf3
008D30  07BC07     RCALL ___fixsfsi
008D32  780F00     MOV W0, [W14]
1615:                   heat_sp_angle = heat_sp_angle - 90;
008D34  2FFA61     MOV #0xFFA6, W1
008D36  408F1E     ADD W1, [W14], [W14]
1616:                }
1617:              
1618:                draw_indicator(tmpx, tmpy, DIAMETER, heat_sp_angle);
008D38  78019E     MOV [W14], W3
008D3A  200AA2     MOV #0xAA, W2
008D3C  9000AE     MOV [W14+4], W1
008D3E  90001E     MOV [W14+2], W0
008D40  07FF5C     RCALL draw_indicator
1619:                update_indicator();
008D42  07FEA1     RCALL update_indicator
1620:                heat_sp_min_x = draw_rect_min_x;
008D44  804510     MOV draw_rect_min_x, W0
008D46  884490     MOV W0, heat_sp_min_x
1621:                heat_sp_min_y = draw_rect_min_y;
008D48  804520     MOV draw_rect_min_y, W0
008D4A  8844A0     MOV W0, heat_sp_min_y
1622:                heat_sp_max_x = draw_rect_max_x;
008D4C  804530     MOV draw_rect_max_x, W0
008D4E  8844B0     MOV W0, heat_sp_max_x
1623:                heat_sp_max_y = draw_rect_max_y;
008D50  804540     MOV draw_rect_max_y, W0
008D52  8844C0     MOV W0, heat_sp_max_y
1624:              }
008D54  FA8000     ULNK
008D56  060000     RETURN
1625:              
1626:              /**
1627:               * draw the cool setpoint indicator
1628:               * @param cool_setpoint_degF
1629:               */
1630:              void draw_cool_sp_indicator(int cool_setpoint_degF)
1631:              {
008D58  FA000C     LNK #0xC
008D5A  980750     MOV W0, [W14+10]
1632:                int tmpx, tmpy;
1633:                int cool_sp_angle; 
1634:                float angles_per_degF;
1635:                tmpx = EP_HEIGHT/2;
008D5C  200840     MOV #0x84, W0
008D5E  980710     MOV W0, [W14+2]
1636:                tmpy = EP_WIDTH - 50;
008D60  2007E0     MOV #0x7E, W0
008D62  980720     MOV W0, [W14+4]
1637:                angles_per_degF = 180.0/(90.0-50.0);
008D64  200000     MOV #0x0, W0
008D66  240901     MOV #0x4090, W1
008D68  980730     MOV W0, [W14+6]
008D6A  980741     MOV W1, [W14+8]
1638:                if (cool_setpoint_degF >= 90) {
008D6C  9000DE     MOV [W14+10], W1
008D6E  200590     MOV #0x59, W0
008D70  508F80     SUB W1, W0, [W15]
008D72  340003     BRA LE, .L105
1639:                    cool_sp_angle = 90;
008D74  2005A0     MOV #0x5A, W0
008D76  780F00     MOV W0, [W14]
008D78  37000B     BRA .L106
1640:                }
1641:                else {
1642:                    cool_sp_angle = (int)((cool_setpoint_degF - 50) * angles_per_degF);
008D7A  90005E     MOV [W14+10], W0
008D7C  B10320     SUB #0x32, W0
008D7E  DE80CF     ASR W0, #15, W1
008D80  07BC1B     RCALL ___floatsisf
008D82  90013E     MOV [W14+6], W2
008D84  9001CE     MOV [W14+8], W3
008D86  07BC78     RCALL ___mulsf3
008D88  07BBDB     RCALL ___fixsfsi
008D8A  780F00     MOV W0, [W14]
1643:                    cool_sp_angle = cool_sp_angle - 90;
008D8C  2FFA61     MOV #0xFFA6, W1
008D8E  408F1E     ADD W1, [W14], [W14]
1644:                }
1645:               
1646:                
1647:                //draw_indicator(tmpx, tmpy, DIAMETER, 0);
1648:                draw_indicator(tmpx, tmpy, DIAMETER, cool_sp_angle);
008D90  78019E     MOV [W14], W3
008D92  200AA2     MOV #0xAA, W2
008D94  9000AE     MOV [W14+4], W1
008D96  90001E     MOV [W14+2], W0
008D98  07FF30     RCALL draw_indicator
1649:                update_indicator();
008D9A  07FE75     RCALL update_indicator
1650:                cool_sp_min_x = draw_rect_min_x;
008D9C  804510     MOV draw_rect_min_x, W0
008D9E  884450     MOV W0, cool_sp_min_x
1651:                cool_sp_min_y = draw_rect_min_y;
008DA0  804520     MOV draw_rect_min_y, W0
008DA2  884460     MOV W0, cool_sp_min_y
1652:                cool_sp_max_x = draw_rect_max_x;
008DA4  804530     MOV draw_rect_max_x, W0
008DA6  884470     MOV W0, cool_sp_max_x
1653:                cool_sp_max_y = draw_rect_max_y;
008DA8  804540     MOV draw_rect_max_y, W0
008DAA  884480     MOV W0, cool_sp_max_y
1654:              }
008DAC  FA8000     ULNK
008DAE  060000     RETURN
1655:              
1656:              
1657:              /*
1658:               * draws the range indicators based on the setpoints
1659:               */
1660:              void draw_range_indicators(int heat_setpoint_degF, int cool_setpoint_degF) {
008DB0  FA0004     LNK #0x4
008DB2  780F00     MOV W0, [W14]
008DB4  980711     MOV W1, [W14+2]
1661:              
1662:                  draw_heat_sp_indicator(heat_setpoint_degF);
008DB6  78001E     MOV [W14], W0
008DB8  07FFA3     RCALL draw_heat_sp_indicator
1663:                  draw_cool_sp_indicator(cool_setpoint_degF);
008DBA  90001E     MOV [W14+2], W0
008DBC  07FFCD     RCALL draw_cool_sp_indicator
1664:                  
1665:              }
008DBE  FA8000     ULNK
008DC0  060000     RETURN
1666:              
1667:              ///**
1668:              // * update a single indicator
1669:              // * @param old_setpoint: original setpoint
1670:              // * @param new_setpoint: the new setpoint to show on screen
1671:              // *      no checking in done in setpoints range, it is assumed that the 
1672:              // *      calling function has set the values according to the limits
1673:              // * @return 
1674:              // */
1675:              //void change_indicator(uint8_t orig_setpoint, uint8_t new_setpoint)
1676:              //{
1677:              //    // erase the old ones and draw the new one
1678:              //    int tmpx, tmpy;
1679:              //    int orig_sp_angle, new_sp_angle; 
1680:              //    float angles_per_degF;
1681:              //    tmpx = EP_HEIGHT/2;
1682:              //    tmpy = EP_WIDTH - 50;
1683:              //    angles_per_degF = 180.0/(90.0-50.0);
1684:              //    orig_sp_angle = (int) ((orig_setpoint - 50) * angles_per_degF);
1685:              //    orig_sp_angle = orig_sp_angle - 90;
1686:              //    new_sp_angle = (int)((new_setpoint - 50) * angles_per_degF);
1687:              //    new_sp_angle = new_sp_angle - 90;
1688:              //
1689:              //    clear_indicator(tmpx, tmpy, DIAMETER, orig_sp_angle);
1690:              //    update_indicator();
1691:              //
1692:              //    //draw_indicator(tmpx, tmpy, DIAMETER, 0);
1693:              //    draw_indicator(tmpx, tmpy, DIAMETER, new_sp_angle);
1694:              //    update_indicator();
1695:              //
1696:              //}
1697:              
1698:              /*
1699:               * utiltiy function to check if the tmp_index is defined in the 
1700:               * pixel display buffer, to draw a pixel at that location
1701:               */
1702:              int indexInBuffer(int tmp_index) {
008DC2  FA0004     LNK #0x4
008DC4  980710     MOV W0, [W14+2]
1703:                int ii = 0;
008DC6  EB0000     CLR W0
008DC8  780F00     MOV W0, [W14]
1704:                //// test code
1705:                //if ( (tmp_index > 1000) && (tmp_index < 2000) ) {
1706:                //  return 1;
1707:                //}
1708:                //else {
1709:                //  return 0;
1710:                //}
1711:                
1712:                while ( (ii < d_pt_count) && (d_pt[ii] != tmp_index) ) {
008DCA  370001     BRA .L109
008DCE  804440     MOV d_pt_count, W0
008DD0  78009E     MOV [W14], W1
008DD2  508F80     SUB W1, W0, [W15]
008DD4  3D0008     BRA GE, .L110
008DD6  78001E     MOV [W14], W0
008DD8  400080     ADD W0, W0, W1
008DDA  2134A0     MOV #0x134A, W0
008DDC  408000     ADD W1, W0, W0
008DDE  780090     MOV [W0], W1
008DE0  90001E     MOV [W14+2], W0
008DE2  508F80     SUB W1, W0, [W15]
008DE4  3AFFF3     BRA NZ, .L111
1713:                  ii++;
008DCC  E80F1E     INC [W14], [W14]
1714:                }
1715:                if (ii >= d_pt_count) {
008DE6  804440     MOV d_pt_count, W0
008DE8  78009E     MOV [W14], W1
008DEA  508F80     SUB W1, W0, [W15]
008DEC  350002     BRA LT, .L112
1716:                  return 0;
008DEE  EB0000     CLR W0
008DF0  370001     BRA .L113
1717:                }
1718:                else {
1719:                  return 1;
008DF2  200010     MOV #0x1, W0
1720:                }
1721:                
1722:              }
008DF4  FA8000     ULNK
008DF6  060000     RETURN
1723:              
1724:              /*
1725:               * draws the characters corresponding to the 2 temp digits
1726:               */
1727:              void drawTemperature(uint8_t current_temp) {
008DF8  FA0014     LNK #0x14
008DFA  985720     MOV.B W0, [W14+18]
1728:                  unsigned char * first_digit;
1729:                  unsigned char * second_digit;
1730:                  float angles_per_degF;
1731:                  int temp_angle;
1732:                  int h;
1733:                  int tmpx, tmpy;
1734:                  int tmpi = (current_temp - (current_temp % 10))/ 10;
008DFC  90502E     MOV.B [W14+18], W0
008DFE  FB8180     ZE W0, W3
008E00  90502E     MOV.B [W14+18], W0
008E02  FB8100     ZE W0, W2
008E04  2CCCD0     MOV #0xCCCD, W0
008E06  B81000     MUL.UU W2, W0, W0
008E08  DE0843     LSR W1, #3, W0
008E0A  B9006A     MUL.SU W0, #10, W0
008E0C  780000     MOV W0, W0
008E0E  510000     SUB W2, W0, W0
008E10  784000     MOV.B W0, W0
008E12  FB8000     ZE W0, W0
008E14  518100     SUB W3, W0, W2
008E16  266670     MOV #0x6667, W0
008E18  B99000     MUL.SS W2, W0, W0
008E1A  DE88C2     ASR W1, #2, W1
008E1C  DE904F     ASR W2, #15, W0
008E1E  508000     SUB W1, W0, W0
008E20  980740     MOV W0, [W14+8]
1735:                  if (tmpi != display_digit_1)
008E22  BFC906     MOV.B ___divdi3, WREG
008E24  FB8080     ZE W0, W1
008E26  90004E     MOV [W14+8], W0
008E28  508F80     SUB W1, W0, [W15]
008E2A  320034     BRA Z, .L115
1736:                  {
1737:                      display_digit_1 = tmpi;
008E2C  90004E     MOV [W14+8], W0
008E2E  784000     MOV.B W0, W0
008E30  B7E906     MOV.B WREG, ___divdi3
1738:                      switch ( tmpi) {
008E32  90004E     MOV [W14+8], W0
008E34  DE80CF     ASR W0, #15, W1
008E36  200092     MOV #0x9, W2
008E38  200003     MOV #0x0, W3
008E3A  500F82     SUB W0, W2, [W15]
008E3C  588F83     SUBB W1, W3, [W15]
008E3E  3E002D     BRA GTU, .L157
008E40  016000     BRA W0
008E42  370009     BRA .L117
008E44  37000B     BRA .L118
008E46  37000D     BRA .L119
008E48  37000F     BRA .L120
008E4A  370011     BRA .L121
008E4C  370013     BRA .L122
008E4E  370015     BRA .L123
008E50  370017     BRA .L124
008E52  370019     BRA .L125
008E54  37001C     BRA .L126
1739:                          case 0:
1740:                              first_digit = Mono_Letter_0;
008E56  209120     MOV #0x912, W0
008E58  780F00     MOV W0, [W14]
1741:                              break;
008E5A  370020     BRA .L128
1742:                          case 1:
1743:                              first_digit = Mono_Letter_1;
008E5C  209B20     MOV #0x9B2, W0
008E5E  780F00     MOV W0, [W14]
1744:                              break;
008E60  37001D     BRA .L128
1745:                          case 2:
1746:                              first_digit = Mono_Letter_2;
008E62  20A520     MOV #0xA52, W0
008E64  780F00     MOV W0, [W14]
1747:                              break;
008E66  37001A     BRA .L128
1748:                          case 3:
1749:                              first_digit = Mono_Letter_3;
008E68  20AF20     MOV #0xAF2, W0
008E6A  780F00     MOV W0, [W14]
1750:                              break;
008E6C  370017     BRA .L128
1751:                          case 4:
1752:                              first_digit = Mono_Letter_4;
008E6E  20B920     MOV #0xB92, W0
008E70  780F00     MOV W0, [W14]
1753:                              break;
008E72  370014     BRA .L128
1754:                          case 5:
1755:                              first_digit = Mono_Letter_5;
008E74  20C320     MOV #0xC32, W0
008E76  780F00     MOV W0, [W14]
1756:                              break;
008E78  370011     BRA .L128
1757:                          case 6:
1758:                              first_digit = Mono_Letter_6;
008E7A  20CD20     MOV #0xCD2, W0
008E7C  780F00     MOV W0, [W14]
1759:                              break;
008E7E  37000E     BRA .L128
1760:                          case 7:
1761:                              first_digit = Mono_Letter_7;
008E80  20D720     MOV #0xD72, W0
008E82  780F00     MOV W0, [W14]
1762:                              break;
008E84  37000B     BRA .L128
1763:                          case 8:
1764:                              first_digit = Mono_Letter_8;
008E86  20E120     MOV #0xE12, W0
008E88  780F00     MOV W0, [W14]
1765:                              break;
008E8A  000000     NOP
008E8C  370007     BRA .L128
1766:                          case 9:
1767:                              first_digit = Mono_Letter_9;
008E8E  20EB20     MOV #0xEB2, W0
008E90  780F00     MOV W0, [W14]
1768:                              break;
008E92  370004     BRA .L128
008E9A  000000     NOP
1769:                      }
1770:                  }
1771:                  else 
1772:                  {
1773:                      first_digit = NULL;
008E94  EB0000     CLR W0
008E96  780F00     MOV W0, [W14]
008E98  370001     BRA .L128
1774:                  }
1775:                  tmpi = current_temp % 10;
008E9C  90502E     MOV.B [W14+18], W0
008E9E  FB8100     ZE W0, W2
008EA0  2CCCD0     MOV #0xCCCD, W0
008EA2  B81000     MUL.UU W2, W0, W0
008EA4  DE0843     LSR W1, #3, W0
008EA6  B9006A     MUL.SU W0, #10, W0
008EA8  780000     MOV W0, W0
008EAA  510000     SUB W2, W0, W0
008EAC  784000     MOV.B W0, W0
008EAE  FB8000     ZE W0, W0
008EB0  980740     MOV W0, [W14+8]
1776:                  if (tmpi != display_digit_2)
008EB2  BFC907     MOV.B 0x907, WREG
008EB4  FB8080     ZE W0, W1
008EB6  90004E     MOV [W14+8], W0
008EB8  508F80     SUB W1, W0, [W15]
008EBA  320034     BRA Z, .L129
1777:                  {
1778:                      display_digit_2 = tmpi;
008EBC  90004E     MOV [W14+8], W0
008EBE  784000     MOV.B W0, W0
008EC0  B7E907     MOV.B WREG, 0x907
1779:                      switch (tmpi) {
008EC2  90004E     MOV [W14+8], W0
008EC4  DE80CF     ASR W0, #15, W1
008EC6  200092     MOV #0x9, W2
008EC8  200003     MOV #0x0, W3
008ECA  500F82     SUB W0, W2, [W15]
008ECC  588F83     SUBB W1, W3, [W15]
008ECE  3E002D     BRA GTU, .L158
008ED0  016000     BRA W0
008ED2  370009     BRA .L131
008ED4  37000B     BRA .L132
008ED6  37000D     BRA .L133
008ED8  37000F     BRA .L134
008EDA  370011     BRA .L135
008EDC  370013     BRA .L136
008EDE  370015     BRA .L137
008EE0  370017     BRA .L138
008EE2  370019     BRA .L139
008EE4  37001C     BRA .L140
1780:                          case 0:
1781:                              second_digit = Mono_Letter_0;
008EE6  209120     MOV #0x912, W0
008EE8  980710     MOV W0, [W14+2]
1782:                              break;
008EEA  370020     BRA .L142
1783:                          case 1:
1784:                              second_digit = Mono_Letter_1;
008EEC  209B20     MOV #0x9B2, W0
008EEE  980710     MOV W0, [W14+2]
1785:                              break;
008EF0  37001D     BRA .L142
1786:                          case 2:
1787:                              second_digit = Mono_Letter_2;
008EF2  20A520     MOV #0xA52, W0
008EF4  980710     MOV W0, [W14+2]
1788:                              break;
008EF6  37001A     BRA .L142
1789:                          case 3:
1790:                              second_digit = Mono_Letter_3;
008EF8  20AF20     MOV #0xAF2, W0
008EFA  980710     MOV W0, [W14+2]
1791:                              break;
008EFC  370017     BRA .L142
1792:                          case 4:
1793:                              second_digit = Mono_Letter_4;
008EFE  20B920     MOV #0xB92, W0
008F00  980710     MOV W0, [W14+2]
1794:                              break;
008F02  370014     BRA .L142
1795:                          case 5:
1796:                              second_digit = Mono_Letter_5;
008F04  20C320     MOV #0xC32, W0
008F06  980710     MOV W0, [W14+2]
1797:                              break;
008F08  370011     BRA .L142
1798:                          case 6:
1799:                              second_digit = Mono_Letter_6;
008F0A  20CD20     MOV #0xCD2, W0
008F0C  980710     MOV W0, [W14+2]
1800:                              break;
008F0E  37000E     BRA .L142
1801:                          case 7:
1802:                              second_digit = Mono_Letter_7;
008F10  20D720     MOV #0xD72, W0
008F12  980710     MOV W0, [W14+2]
1803:                              break;
008F14  37000B     BRA .L142
1804:                          case 8:
1805:                              second_digit = Mono_Letter_8;
008F16  20E120     MOV #0xE12, W0
008F18  980710     MOV W0, [W14+2]
1806:                              break;
008F1A  000000     NOP
008F1C  370007     BRA .L142
1807:                          case 9:
1808:                              second_digit = Mono_Letter_9;
008F1E  20EB20     MOV #0xEB2, W0
008F20  980710     MOV W0, [W14+2]
1809:                              break;
008F22  370004     BRA .L142
008F2A  000000     NOP
1810:                      }
1811:                  }
1812:                  else 
1813:                  {
1814:                      second_digit = NULL;
008F24  EB0000     CLR W0
008F26  980710     MOV W0, [W14+2]
008F28  370001     BRA .L142
1815:                  }
1816:              
1817:                  
1818:                  digit_pos_x[0] = CENTERX - LETTER_WIDTH_PIXELS + 8;
008F2C  2006C0     MOV #0x6C, W0
008F2E  884400     MOV W0, digit_pos_x
1819:                  digit_pos_y[0] = CENTERY;
008F30  2007E0     MOV #0x7E, W0
008F32  884420     MOV W0, digit_pos_y
1820:                  digit_pos_x[1] = CENTERX;
008F34  200840     MOV #0x84, W0
008F36  884410     MOV W0, 0x882
1821:                  digit_pos_y[1] = CENTERY;
008F38  2007E0     MOV #0x7E, W0
008F3A  884430     MOV W0, 0x886
1822:                  map_digit_coords();
008F3C  07FCF3     RCALL map_digit_coords
1823:              
1824:                  if (first_digit != NULL)
008F3E  78001E     MOV [W14], W0
008F40  E00000     CP0 W0
008F42  32005B     BRA Z, .L143
1825:                  {
1826:                      //partial updating the screen: Black
1827:                      writeCMD(0x14);
008F44  B3C140     MOV.B #0x14, W0
008F46  07FA13     RCALL writeCMD
1828:                      writeData(0x00);  //1st half x
008F48  EB4000     CLR.B W0
008F4A  07FA20     RCALL writeData
1829:                      writeData(digit_pos_x[0]);  //2nd half x
008F4C  804400     MOV digit_pos_x, W0
008F4E  784000     MOV.B W0, W0
008F50  07FA1D     RCALL writeData
1830:                      writeData(0x00);  //1st half y
008F52  EB4000     CLR.B W0
008F54  07FA1B     RCALL writeData
1831:                      writeData(digit_pos_y[0]);  //2nd half y
008F56  804420     MOV digit_pos_y, W0
008F58  784000     MOV.B W0, W0
008F5A  07FA18     RCALL writeData
1832:                      writeData(0x00);  //1st half w
008F5C  EB4000     CLR.B W0
008F5E  07FA16     RCALL writeData
1833:                      writeData(LETTER_HEIGHT_PIXELS);  //2nd half w
008F60  B3C280     MOV.B #0x28, W0
008F62  07FA14     RCALL writeData
1834:                      writeData(0x00);  //1st half l
008F64  EB4000     CLR.B W0
008F66  07FA12     RCALL writeData
1835:                      writeData(LETTER_WIDTH_PIXELS);  //2nd half l
008F68  B3C200     MOV.B #0x20, W0
008F6A  07FA10     RCALL writeData
1836:              
1837:                      for (h = 0; h < ( (LETTER_HEIGHT_PIXELS * LETTER_WIDTH_PIXELS) / LETTER_WIDTH_MONO_BYTES ) ; h++)
008F6C  EB0000     CLR W0
008F6E  980730     MOV W0, [W14+6]
008F70  370007     BRA .L144
008F7A  90003E     MOV [W14+6], W0
008F7C  E80000     INC W0, W0
008F7E  980730     MOV W0, [W14+6]
008F80  9000BE     MOV [W14+6], W1
008F82  2009F0     MOV #0x9F, W0
008F84  508F80     SUB W1, W0, [W15]
008F86  34FFF5     BRA LE, .L145
1838:                      {
1839:                        writeData(first_digit[h]);
008F72  90003E     MOV [W14+6], W0
008F74  40001E     ADD W0, [W14], W0
008F76  784010     MOV.B [W0], W0
008F78  07FA09     RCALL writeData
1840:                      }
1841:                      //partial updating the screen: Red
1842:                      writeCMD(0x15);
008F88  B3C150     MOV.B #0x15, W0
008F8A  07F9F1     RCALL writeCMD
1843:                      writeData(0x00);  //1st half x
008F8C  EB4000     CLR.B W0
008F8E  07F9FE     RCALL writeData
1844:                      writeData(digit_pos_x[0]);  //2nd half x
008F90  804400     MOV digit_pos_x, W0
008F92  784000     MOV.B W0, W0
008F94  07F9FB     RCALL writeData
1845:                      writeData(0x00);  //1st half y
008F96  EB4000     CLR.B W0
008F98  07F9F9     RCALL writeData
1846:                      writeData(digit_pos_y[0]);  //2nd half y
008F9A  804420     MOV digit_pos_y, W0
008F9C  784000     MOV.B W0, W0
008F9E  07F9F6     RCALL writeData
1847:                      writeData(0x00);  //1st half w
008FA0  EB4000     CLR.B W0
008FA2  07F9F4     RCALL writeData
1848:                      writeData(LETTER_HEIGHT_PIXELS);  //2nd half w
008FA4  B3C280     MOV.B #0x28, W0
008FA6  07F9F2     RCALL writeData
1849:                      writeData(0x00);  //1st half l
008FA8  EB4000     CLR.B W0
008FAA  07F9F0     RCALL writeData
1850:                      writeData(LETTER_WIDTH_PIXELS);  //2nd half l
008FAC  B3C200     MOV.B #0x20, W0
008FAE  07F9EE     RCALL writeData
1851:              
1852:                      for (h = 0; h < ( (LETTER_HEIGHT_PIXELS * LETTER_WIDTH_PIXELS) / LETTER_WIDTH_MONO_BYTES ) ; h++)
008FB0  EB0000     CLR W0
008FB2  980730     MOV W0, [W14+6]
008FB4  370005     BRA .L146
008FBA  90003E     MOV [W14+6], W0
008FBC  E80000     INC W0, W0
008FBE  980730     MOV W0, [W14+6]
008FC0  9000BE     MOV [W14+6], W1
008FC2  2009F0     MOV #0x9F, W0
008FC4  508F80     SUB W1, W0, [W15]
008FC6  34FFF7     BRA LE, .L147
1853:                      {
1854:                        writeData(0x00);
008FB6  EB4000     CLR.B W0
008FB8  07F9E9     RCALL writeData
1855:                      }
1856:                      //partial refresh of the same area as the partial update
1857:                      writeCMD(0x16);
008FC8  B3C160     MOV.B #0x16, W0
008FCA  07F9D1     RCALL writeCMD
1858:                      writeData(0x00);  //1st half x
008FCC  EB4000     CLR.B W0
008FCE  07F9DE     RCALL writeData
1859:                      writeData(digit_pos_x[0]);  //2nd half x
008FD0  804400     MOV digit_pos_x, W0
008FD2  784000     MOV.B W0, W0
008FD4  07F9DB     RCALL writeData
1860:                      writeData(0x00);  //1st half y
008FD6  EB4000     CLR.B W0
008FD8  07F9D9     RCALL writeData
1861:                      writeData(digit_pos_y[0]);  //2nd half y
008FDA  804420     MOV digit_pos_y, W0
008FDC  784000     MOV.B W0, W0
008FDE  07F9D6     RCALL writeData
1862:                      writeData(0x00);  //1st half w
008FE0  EB4000     CLR.B W0
008FE2  07F9D4     RCALL writeData
1863:                      writeData(LETTER_HEIGHT_PIXELS);  //2nd half w
008FE4  B3C280     MOV.B #0x28, W0
008FE6  07F9D2     RCALL writeData
1864:                      writeData(0x00);  //1st half l
008FE8  EB4000     CLR.B W0
008FEA  07F9D0     RCALL writeData
1865:                      writeData(LETTER_WIDTH_PIXELS);  //2nd half l
008FEC  B3C200     MOV.B #0x20, W0
008FEE  07F9CE     RCALL writeData
1866:              
1867:                      while (0 == BSY_DISP_GetValue());
008FF0  000000     NOP
008FF2  803620     MOV PORTF, W0
008FF4  600061     AND W0, #0x1, W0
008FF6  E00000     CP0 W0
008FF8  32FFFC     BRA Z, .L148
1868:                      //wait so you can view the screen
1869:                      //delay(1000);
1870:                  }
1871:              
1872:                  if (second_digit != NULL)
008FFA  90001E     MOV [W14+2], W0
008FFC  E00000     CP0 W0
008FFE  32005C     BRA Z, .L149
1873:                  {
1874:                      //partial updating the screen: Black
1875:                      writeCMD(0x14);
009000  B3C140     MOV.B #0x14, W0
009002  07F9B5     RCALL writeCMD
1876:                      writeData(0x00);  //1st half x
009004  EB4000     CLR.B W0
009006  07F9C2     RCALL writeData
1877:                      writeData(digit_pos_x[1]);  //2nd half x
009008  804410     MOV 0x882, W0
00900A  784000     MOV.B W0, W0
00900C  07F9BF     RCALL writeData
1878:                      writeData(0x00);  //1st half y
00900E  EB4000     CLR.B W0
009010  07F9BD     RCALL writeData
1879:                      writeData(digit_pos_y[1]);  //2nd half y
009012  804430     MOV 0x886, W0
009014  784000     MOV.B W0, W0
009016  07F9BA     RCALL writeData
1880:                      writeData(0x00);  //1st half w
009018  EB4000     CLR.B W0
00901A  07F9B8     RCALL writeData
1881:                      writeData(LETTER_HEIGHT_PIXELS);  //2nd half w
00901C  B3C280     MOV.B #0x28, W0
00901E  07F9B6     RCALL writeData
1882:                      writeData(0x00);  //1st half l
009020  EB4000     CLR.B W0
009022  07F9B4     RCALL writeData
1883:                      writeData(LETTER_WIDTH_PIXELS);  //2nd half l
009024  B3C200     MOV.B #0x20, W0
009026  07F9B2     RCALL writeData
1884:              
1885:                      for ( h = 0; h < ( (LETTER_HEIGHT_PIXELS * LETTER_WIDTH_PIXELS) / LETTER_WIDTH_MONO_BYTES ) ; h++)
009028  EB0000     CLR W0
00902A  980730     MOV W0, [W14+6]
00902C  370008     BRA .L150
009038  90003E     MOV [W14+6], W0
00903A  E80000     INC W0, W0
00903C  980730     MOV W0, [W14+6]
00903E  9000BE     MOV [W14+6], W1
009040  2009F0     MOV #0x9F, W0
009042  508F80     SUB W1, W0, [W15]
009044  34FFF4     BRA LE, .L151
1886:                      {
1887:                        writeData(second_digit[h]);
00902E  90003E     MOV [W14+6], W0
009030  90009E     MOV [W14+2], W1
009032  408000     ADD W1, W0, W0
009034  784010     MOV.B [W0], W0
009036  07F9AA     RCALL writeData
1888:                      }
1889:                      //partial updating the screen: Red
1890:                      writeCMD(0x15);
009046  B3C150     MOV.B #0x15, W0
009048  07F992     RCALL writeCMD
1891:                      writeData(0x00);  //1st half x
00904A  EB4000     CLR.B W0
00904C  07F99F     RCALL writeData
1892:                      writeData(digit_pos_x[1]);  //2nd half x
00904E  804410     MOV 0x882, W0
009050  784000     MOV.B W0, W0
009052  07F99C     RCALL writeData
1893:                      writeData(0x00);  //1st half y
009054  EB4000     CLR.B W0
009056  07F99A     RCALL writeData
1894:                      writeData(digit_pos_y[1]);  //2nd half y
009058  804430     MOV 0x886, W0
00905A  784000     MOV.B W0, W0
00905C  07F997     RCALL writeData
1895:                      writeData(0x00);  //1st half w
00905E  EB4000     CLR.B W0
009060  07F995     RCALL writeData
1896:                      writeData(LETTER_HEIGHT_PIXELS);  //2nd half w
009062  B3C280     MOV.B #0x28, W0
009064  07F993     RCALL writeData
1897:                      writeData(0x00);  //1st half l
009066  EB4000     CLR.B W0
009068  07F991     RCALL writeData
1898:                      writeData(LETTER_WIDTH_PIXELS);  //2nd half l
00906A  B3C200     MOV.B #0x20, W0
00906C  07F98F     RCALL writeData
1899:              
1900:                      for ( h = 0; h < ( (LETTER_HEIGHT_PIXELS * LETTER_WIDTH_PIXELS) / LETTER_WIDTH_MONO_BYTES ) ; h++)
00906E  EB0000     CLR W0
009070  980730     MOV W0, [W14+6]
009072  370005     BRA .L152
009078  90003E     MOV [W14+6], W0
00907A  E80000     INC W0, W0
00907C  980730     MOV W0, [W14+6]
00907E  9000BE     MOV [W14+6], W1
009080  2009F0     MOV #0x9F, W0
009082  508F80     SUB W1, W0, [W15]
009084  34FFF7     BRA LE, .L153
1901:                      {
1902:                        writeData(0x00);
009074  EB4000     CLR.B W0
009076  07F98A     RCALL writeData
1903:                      }
1904:                      //partial refresh of the same area as the partial update
1905:                      writeCMD(0x16);
009086  B3C160     MOV.B #0x16, W0
009088  07F972     RCALL writeCMD
1906:                      writeData(0x00);  //1st half x
00908A  EB4000     CLR.B W0
00908C  07F97F     RCALL writeData
1907:                      writeData(digit_pos_x[1]);  //2nd half x
00908E  804410     MOV 0x882, W0
009090  784000     MOV.B W0, W0
009092  07F97C     RCALL writeData
1908:                      writeData(0x00);  //1st half y
009094  EB4000     CLR.B W0
009096  07F97A     RCALL writeData
1909:                      writeData(digit_pos_y[1]);  //2nd half y
009098  804430     MOV 0x886, W0
00909A  784000     MOV.B W0, W0
00909C  07F977     RCALL writeData
1910:                      writeData(0x00);  //1st half w
00909E  EB4000     CLR.B W0
0090A0  07F975     RCALL writeData
1911:                      writeData(LETTER_HEIGHT_PIXELS);  //2nd half w
0090A2  B3C280     MOV.B #0x28, W0
0090A4  07F973     RCALL writeData
1912:                      writeData(0x00);  //1st half l
0090A6  EB4000     CLR.B W0
0090A8  07F971     RCALL writeData
1913:                      writeData(LETTER_WIDTH_PIXELS);  //2nd half l
0090AA  B3C200     MOV.B #0x20, W0
0090AC  07F96F     RCALL writeData
1914:              
1915:                      while (0 == BSY_DISP_GetValue());
0090AE  000000     NOP
0090B0  803620     MOV PORTF, W0
0090B2  600061     AND W0, #0x1, W0
0090B4  E00000     CP0 W0
0090B6  32FFFC     BRA Z, .L154
1916:                      ////wait so you can view the screen
1917:                      //delay(5000);
1918:                  }
1919:                  
1920:                  tmpx = EP_HEIGHT/2;
0090B8  200840     MOV #0x84, W0
0090BA  980750     MOV W0, [W14+10]
1921:                  tmpy = EP_WIDTH - 50;
0090BC  2007E0     MOV #0x7E, W0
0090BE  980760     MOV W0, [W14+12]
1922:                  angles_per_degF = 180.0/(90.0-50.0);
0090C0  200000     MOV #0x0, W0
0090C2  240901     MOV #0x4090, W1
0090C4  980770     MOV W0, [W14+14]
0090C6  980F01     MOV W1, [W14+16]
1923:                  if (current_temp <= 50) {
0090C8  9050AE     MOV.B [W14+18], W1
0090CA  B3C320     MOV.B #0x32, W0
0090CC  50CF80     SUB.B W1, W0, [W15]
0090CE  3E0003     BRA GTU, .L155
1924:                      temp_angle = -90;
0090D0  2FFA60     MOV #0xFFA6, W0
0090D2  980720     MOV W0, [W14+4]
0090D4  37000D     BRA .L156
1925:                  }
1926:                  else {
1927:                     temp_angle = (int) ((current_temp - 50) * angles_per_degF);
0090D6  90502E     MOV.B [W14+18], W0
0090D8  FB8000     ZE W0, W0
0090DA  B10320     SUB #0x32, W0
0090DC  DE80CF     ASR W0, #15, W1
0090DE  07BA6C     RCALL ___floatsisf
0090E0  90017E     MOV [W14+14], W2
0090E2  90098E     MOV [W14+16], W3
0090E4  07BAC9     RCALL ___mulsf3
0090E6  07BA2C     RCALL ___fixsfsi
0090E8  980720     MOV W0, [W14+4]
1928:                     temp_angle = temp_angle - 90;
0090EA  90002E     MOV [W14+4], W0
0090EC  B105A0     SUB #0x5A, W0
0090EE  980720     MOV W0, [W14+4]
1929:                  }
1930:                  draw_temp_indicator(tmpx, tmpy, DIAMETER, temp_angle);
0090F0  9001AE     MOV [W14+4], W3
0090F2  200AA2     MOV #0xAA, W2
0090F4  9000EE     MOV [W14+12], W1
0090F6  90005E     MOV [W14+10], W0
0090F8  07FDAE     RCALL draw_temp_indicator
1931:                  update_indicator();
0090FA  07FCC5     RCALL update_indicator
1932:                  temperature_min_x = draw_rect_min_x;
0090FC  804510     MOV draw_rect_min_x, W0
0090FE  8844D0     MOV W0, temperature_min_x
1933:                  temperature_min_y = draw_rect_min_y;
009100  804520     MOV draw_rect_min_y, W0
009102  8844E0     MOV W0, temperature_min_y
1934:                  temperature_max_x = draw_rect_max_x;
009104  804530     MOV draw_rect_max_x, W0
009106  8844F0     MOV W0, temperature_max_x
1935:                  temperature_max_y = draw_rect_max_y;
009108  804540     MOV draw_rect_max_y, W0
00910A  884500     MOV W0, temperature_max_y
1936:                  
1937:              }
00910C  FA8000     ULNK
00910E  060000     RETURN
1938:              
1939:              
1940:              void epaper_draw_screen(uint8_t cool_set_point, uint8_t heat_set_point) {
009110  FA0002     LNK #0x2
009112  784F00     MOV.B W0, [W14]
009114  984711     MOV.B W1, [W14+1]
1941:                  // TODO: redraw whole screen after 10 partial updates
1942:                  draw_gauge();    
009116  07FDCD     RCALL draw_gauge
1943:                  draw_range_indicators(cool_set_point, heat_set_point);
009118  90401E     MOV.B [W14+1], W0
00911A  FB8080     ZE W0, W1
00911C  FB801E     ZE [W14], W0
00911E  07FE48     RCALL draw_range_indicators
1944:              }
009120  FA8000     ULNK
009122  060000     RETURN
1945:              
1946:              /**
1947:               * 
1948:               * @param heatorcool
1949:               *      if heatorcool is 1 => write heat to epaper at (action_pos_x action_pos_y)
1950:               *      if heatorcool is 0 => write cool to epaper at (action_pos_x action_pos_y)   
1951:               *      if heatorcool is 2 => erase whatever was written at that location
1952:               * 
1953:               *      any other value the no action is taken
1954:               */
1955:              void epaper_draw_heatcool(uint8_t heatorcool)
1956:              {
009124  FA0008     LNK #0x8
009126  984760     MOV.B W0, [W14+6]
1957:                  unsigned char * pImg=NULL;
009128  EB0000     CLR W0
00912A  780F00     MOV W0, [W14]
1958:                  int h;
1959:                  uint8_t erase;
1960:                  
1961:                  if (heatorcool == 0) 
00912C  90406E     MOV.B [W14+6], W0
00912E  E00400     CP0.B W0
009130  3A0005     BRA NZ, .L161
1962:                  {
1963:                      // draw cool
1964:                      pImg = IMG_Cool;
009132  20F520     MOV #0xF52, W0
009134  780F00     MOV W0, [W14]
1965:                      erase = 0;
009136  EB4000     CLR.B W0
009138  984740     MOV.B W0, [W14+4]
00913A  37000D     BRA .L162
1966:                  } 
1967:                  else if (heatorcool == 1)
00913C  90406E     MOV.B [W14+6], W0
00913E  504FE1     SUB.B W0, #0x1, [W15]
009140  3A0005     BRA NZ, .L163
1968:                  {
1969:                      // draw heat
1970:                      pImg = IMG_Heat;
009142  210720     MOV #0x1072, W0
009144  780F00     MOV W0, [W14]
1971:                      erase = 0;
009146  EB4000     CLR.B W0
009148  984740     MOV.B W0, [W14+4]
00914A  370005     BRA .L162
1972:                  }
1973:                  else if (heatorcool == 2)
00914C  90406E     MOV.B [W14+6], W0
00914E  504FE2     SUB.B W0, #0x2, [W15]
009150  3A0002     BRA NZ, .L162
1974:                  {
1975:                      erase = 1;
009152  B3C010     MOV.B #0x1, W0
009154  984740     MOV.B W0, [W14+4]
1976:                  }   
1977:                  else {
1978:                      // THIS SHOULD NOT HAPPEN
1979:                  }
1980:                  
1981:                  digit_pos_x[0] = action_pos_x;
009156  804790     MOV 0x8F2, W0
009158  884400     MOV W0, digit_pos_x
1982:                  digit_pos_y[0] = action_pos_y;
00915A  8047A0     MOV 0x8F4, W0
00915C  884420     MOV W0, digit_pos_y
1983:                  digit_pos_x[1] = batt_pos_x;
00915E  8047B0     MOV 0x8F6, W0
009160  884410     MOV W0, 0x882
1984:                  digit_pos_y[1] = batt_pos_y;
009162  8047C0     MOV 0x8F8, W0
009164  884430     MOV W0, 0x886
1985:                  map_digit_coords();
009166  07FBDE     RCALL map_digit_coords
1986:              
1987:                  if ( (pImg != NULL) || (erase == 1) )
009168  78001E     MOV [W14], W0
00916A  E00000     CP0 W0
00916C  3A0003     BRA NZ, .L164
00916E  90404E     MOV.B [W14+4], W0
009170  504FE1     SUB.B W0, #0x1, [W15]
009172  3A006B     BRA NZ, .L160
1988:                  {
1989:                      //partial updating the screen: Black
1990:                      writeCMD(0x14);
009174  B3C140     MOV.B #0x14, W0
009176  07F8FB     RCALL writeCMD
1991:                      writeData(0x00);  //1st half x
009178  EB4000     CLR.B W0
00917A  07F908     RCALL writeData
1992:                      writeData(digit_pos_x[0]);  //2nd half x
00917C  804400     MOV digit_pos_x, W0
00917E  784000     MOV.B W0, W0
009180  07F905     RCALL writeData
1993:                      writeData(0x00);  //1st half y
009182  EB4000     CLR.B W0
009184  07F903     RCALL writeData
1994:                      writeData(digit_pos_y[0]);  //2nd half y
009186  804420     MOV digit_pos_y, W0
009188  784000     MOV.B W0, W0
00918A  07F900     RCALL writeData
1995:                      writeData(0x00);  //1st half w
00918C  EB4000     CLR.B W0
00918E  07F8FE     RCALL writeData
1996:                      writeData(Cool_WIDTH_PIXELS);  //2nd half w
009190  B3C200     MOV.B #0x20, W0
009192  07F8FC     RCALL writeData
1997:                      writeData(0x00);  //1st half l
009194  EB4000     CLR.B W0
009196  07F8FA     RCALL writeData
1998:                      writeData(Cool_HEIGHT_PIXELS);  //2nd half l
009198  B3C480     MOV.B #0x48, W0
00919A  07F8F8     RCALL writeData
1999:              
2000:                      if (erase == 0)
00919C  90404E     MOV.B [W14+4], W0
00919E  E00400     CP0.B W0
0091A0  3A000F     BRA NZ, .L166
2001:                      {
2002:                          for (h = 0; h < ( (Cool_HEIGHT_PIXELS * Cool_WIDTH_PIXELS) / Cool_WIDTH_MONO_BYTES ) ; h++)
0091A2  EB0000     CLR W0
0091A4  980710     MOV W0, [W14+2]
0091A6  370007     BRA .L167
0091B0  90001E     MOV [W14+2], W0
0091B2  E80000     INC W0, W0
0091B4  980710     MOV W0, [W14+2]
0091B6  90009E     MOV [W14+2], W1
0091B8  2011F0     MOV #0x11F, W0
0091BA  508F80     SUB W1, W0, [W15]
0091BC  34FFF5     BRA LE, .L168
0091BE  37000C     BRA .L169
2003:                          {
2004:                            writeData(pImg[h]);
0091A8  90001E     MOV [W14+2], W0
0091AA  40001E     ADD W0, [W14], W0
0091AC  784010     MOV.B [W0], W0
0091AE  07F8EE     RCALL writeData
2005:                          }
2006:                      }
2007:                      else 
2008:                      {
2009:                          for (h = 0; h < ( (Cool_HEIGHT_PIXELS * Cool_WIDTH_PIXELS) / Cool_WIDTH_MONO_BYTES ) ; h++)
0091C0  EB0000     CLR W0
0091C2  980710     MOV W0, [W14+2]
0091C4  370005     BRA .L170
0091CA  90001E     MOV [W14+2], W0
0091CC  E80000     INC W0, W0
0091CE  980710     MOV W0, [W14+2]
0091D0  90009E     MOV [W14+2], W1
0091D2  2011F0     MOV #0x11F, W0
0091D4  508F80     SUB W1, W0, [W15]
0091D6  34FFF7     BRA LE, .L171
2010:                          {
2011:                            writeData(0x00);
0091C6  EB4000     CLR.B W0
0091C8  07F8E1     RCALL writeData
2012:                          }
2013:                      }
2014:                      //partial updating the screen: Red
2015:                      writeCMD(0x15);
0091D8  B3C150     MOV.B #0x15, W0
0091DA  07F8C9     RCALL writeCMD
2016:                      writeData(0x00);  //1st half x
0091DC  EB4000     CLR.B W0
0091DE  07F8D6     RCALL writeData
2017:                      writeData(digit_pos_x[0]);  //2nd half x
0091E0  804400     MOV digit_pos_x, W0
0091E2  784000     MOV.B W0, W0
0091E4  07F8D3     RCALL writeData
2018:                      writeData(0x00);  //1st half y
0091E6  EB4000     CLR.B W0
0091E8  07F8D1     RCALL writeData
2019:                      writeData(digit_pos_y[0]);  //2nd half y
0091EA  804420     MOV digit_pos_y, W0
0091EC  784000     MOV.B W0, W0
0091EE  07F8CE     RCALL writeData
2020:                      writeData(0x00);  //1st half w
0091F0  EB4000     CLR.B W0
0091F2  07F8CC     RCALL writeData
2021:                      writeData(Cool_WIDTH_PIXELS);  //2nd half w
0091F4  B3C200     MOV.B #0x20, W0
0091F6  07F8CA     RCALL writeData
2022:                      writeData(0x00);  //1st half l
0091F8  EB4000     CLR.B W0
0091FA  07F8C8     RCALL writeData
2023:                      writeData(Cool_HEIGHT_PIXELS);  //2nd half l
0091FC  B3C480     MOV.B #0x48, W0
0091FE  07F8C6     RCALL writeData
2024:              
2025:                      for (h = 0; h < ( (Cool_HEIGHT_PIXELS * Cool_WIDTH_PIXELS) / Cool_WIDTH_MONO_BYTES ) ; h++)
009200  EB0000     CLR W0
009202  980710     MOV W0, [W14+2]
009204  370005     BRA .L172
00920A  90001E     MOV [W14+2], W0
00920C  E80000     INC W0, W0
00920E  980710     MOV W0, [W14+2]
009210  90009E     MOV [W14+2], W1
009212  2011F0     MOV #0x11F, W0
009214  508F80     SUB W1, W0, [W15]
009216  34FFF7     BRA LE, .L173
2026:                      {
2027:                        writeData(0x00);
009206  EB4000     CLR.B W0
009208  07F8C1     RCALL writeData
2028:                      }
2029:                      //partial refresh of the same area as the partial update
2030:                      writeCMD(0x16);
009218  B3C160     MOV.B #0x16, W0
00921A  07F8A9     RCALL writeCMD
2031:                      writeData(0x00);  //1st half x
00921C  EB4000     CLR.B W0
00921E  07F8B6     RCALL writeData
2032:                      writeData(digit_pos_x[0]);  //2nd half x
009220  804400     MOV digit_pos_x, W0
009222  784000     MOV.B W0, W0
009224  07F8B3     RCALL writeData
2033:                      writeData(0x00);  //1st half y
009226  EB4000     CLR.B W0
009228  07F8B1     RCALL writeData
2034:                      writeData(digit_pos_y[0]);  //2nd half y
00922A  804420     MOV digit_pos_y, W0
00922C  784000     MOV.B W0, W0
00922E  07F8AE     RCALL writeData
2035:                      writeData(0x00);  //1st half w
009230  EB4000     CLR.B W0
009232  07F8AC     RCALL writeData
2036:                      writeData(Cool_WIDTH_PIXELS);  //2nd half w
009234  B3C200     MOV.B #0x20, W0
009236  07F8AA     RCALL writeData
2037:                      writeData(0x00);  //1st half l
009238  EB4000     CLR.B W0
00923A  07F8A8     RCALL writeData
2038:                      writeData(Cool_HEIGHT_PIXELS);  //2nd half l
00923C  B3C480     MOV.B #0x48, W0
00923E  07F8A6     RCALL writeData
2039:              
2040:                      while (0 == BSY_DISP_GetValue());
009240  000000     NOP
009242  803620     MOV PORTF, W0
009244  600061     AND W0, #0x1, W0
009246  E00000     CP0 W0
009248  32FFFC     BRA Z, .L174
2041:                      //wait so you can view the screen
2042:                      //delay(1000);
2043:                  }
2044:              
2045:                  
2046:              }
00924A  FA8000     ULNK
00924C  060000     RETURN
2047:              
2048:              
2049:              /**
2050:               *
2051:               * draws the battery icon
2052:               * param draw_batt
2053:               *      if draw_batt is 1, it draws the batt icon to screen
2054:               *      if draw_batt is 0, it erases the screen region belonging to the battery icon 
2055:               * 
2056:               */
2057:              void epaper_draw_battery(uint8_t draw_batt)
2058:              {
00924E  FA0004     LNK #0x4
009250  984720     MOV.B W0, [W14+2]
2059:                  int h;
2060:                  
2061:                  digit_pos_x[0] = action_pos_x;
009252  804790     MOV 0x8F2, W0
009254  884400     MOV W0, digit_pos_x
2062:                  digit_pos_y[0] = action_pos_y;
009256  8047A0     MOV 0x8F4, W0
009258  884420     MOV W0, digit_pos_y
2063:                  digit_pos_x[1] = batt_pos_x;
00925A  8047B0     MOV 0x8F6, W0
00925C  884410     MOV W0, 0x882
2064:                  digit_pos_y[1] = batt_pos_y;
00925E  8047C0     MOV 0x8F8, W0
009260  884430     MOV W0, 0x886
2065:                  map_digit_coords();
009262  07FB60     RCALL map_digit_coords
2066:              
2067:                  //partial updating the screen: Black
2068:                  writeCMD(0x14);
009264  B3C140     MOV.B #0x14, W0
009266  07F883     RCALL writeCMD
2069:                  writeData(0x00);  //1st half x
009268  EB4000     CLR.B W0
00926A  07F890     RCALL writeData
2070:                  writeData(digit_pos_x[1]);  //2nd half x
00926C  804410     MOV 0x882, W0
00926E  784000     MOV.B W0, W0
009270  07F88D     RCALL writeData
2071:                  writeData(0x00);  //1st half y
009272  EB4000     CLR.B W0
009274  07F88B     RCALL writeData
2072:                  writeData(digit_pos_y[1]);  //2nd half y
009276  804430     MOV 0x886, W0
009278  784000     MOV.B W0, W0
00927A  07F888     RCALL writeData
2073:                  writeData(0x00);  //1st half w
00927C  EB4000     CLR.B W0
00927E  07F886     RCALL writeData
2074:                  writeData(Battery_WIDTH_PIXELS);  //2nd half w
009280  B3C180     MOV.B #0x18, W0
009282  07F884     RCALL writeData
2075:                  writeData(0x00);  //1st half l
009284  EB4000     CLR.B W0
009286  07F882     RCALL writeData
2076:                  writeData(Battery_HEIGHT_PIXELS);  //2nd half l
009288  B3C300     MOV.B #0x30, W0
00928A  07F880     RCALL writeData
2077:              
2078:                  if (draw_batt == 1)
00928C  90402E     MOV.B [W14+2], W0
00928E  504FE1     SUB.B W0, #0x1, [W15]
009290  3A000D     BRA NZ, .L176
2079:                  {
2080:                      for (h = 0; h < ( (Battery_HEIGHT_PIXELS * Battery_WIDTH_PIXELS) / Battery_WIDTH_MONO_BYTES ) ; h++)
009292  EB0000     CLR W0
009294  780F00     MOV W0, [W14]
009296  370005     BRA .L177
0092A0  E80F1E     INC [W14], [W14]
0092A2  2008F0     MOV #0x8F, W0
0092A4  78009E     MOV [W14], W1
0092A6  508F80     SUB W1, W0, [W15]
0092A8  34FFF7     BRA LE, .L178
0092AA  37000A     BRA .L179
2081:                      {
2082:                        writeData(IMG_Battery[h]);
009298  212660     MOV #0x1266, W0
00929A  40001E     ADD W0, [W14], W0
00929C  784010     MOV.B [W0], W0
00929E  07F876     RCALL writeData
2083:                      }
2084:                  }
2085:                  else 
2086:                  {
2087:                      for (h = 0; h < ( (Battery_HEIGHT_PIXELS * Battery_WIDTH_PIXELS) / Battery_WIDTH_MONO_BYTES ) ; h++)
0092AC  EB0000     CLR W0
0092AE  780F00     MOV W0, [W14]
0092B0  370003     BRA .L180
0092B6  E80F1E     INC [W14], [W14]
0092B8  2008F0     MOV #0x8F, W0
0092BA  78009E     MOV [W14], W1
0092BC  508F80     SUB W1, W0, [W15]
0092BE  34FFF9     BRA LE, .L181
2088:                      {
2089:                        writeData(0x00);
0092B2  EB4000     CLR.B W0
0092B4  07F86B     RCALL writeData
2090:                      }
2091:                  }
2092:                  //partial updating the screen: Red
2093:                  writeCMD(0x15);
0092C0  B3C150     MOV.B #0x15, W0
0092C2  07F855     RCALL writeCMD
2094:                  writeData(0x00);  //1st half x
0092C4  EB4000     CLR.B W0
0092C6  07F862     RCALL writeData
2095:                  writeData(digit_pos_x[1]);  //2nd half x
0092C8  804410     MOV 0x882, W0
0092CA  784000     MOV.B W0, W0
0092CC  07F85F     RCALL writeData
2096:                  writeData(0x00);  //1st half y
0092CE  EB4000     CLR.B W0
0092D0  07F85D     RCALL writeData
2097:                  writeData(digit_pos_y[1]);  //2nd half y
0092D2  804430     MOV 0x886, W0
0092D4  784000     MOV.B W0, W0
0092D6  07F85A     RCALL writeData
2098:                  writeData(0x00);  //1st half w
0092D8  EB4000     CLR.B W0
0092DA  07F858     RCALL writeData
2099:                  writeData(Battery_WIDTH_PIXELS);  //2nd half w
0092DC  B3C180     MOV.B #0x18, W0
0092DE  07F856     RCALL writeData
2100:                  writeData(0x00);  //1st half l
0092E0  EB4000     CLR.B W0
0092E2  07F854     RCALL writeData
2101:                  writeData(Battery_HEIGHT_PIXELS);  //2nd half l
0092E4  B3C300     MOV.B #0x30, W0
0092E6  07F852     RCALL writeData
2102:              
2103:                  for (h = 0; h < ( (Battery_HEIGHT_PIXELS * Battery_WIDTH_PIXELS) / Battery_WIDTH_MONO_BYTES ) ; h++)
0092E8  EB0000     CLR W0
0092EA  780F00     MOV W0, [W14]
0092EC  370003     BRA .L182
0092F2  E80F1E     INC [W14], [W14]
0092F4  2008F0     MOV #0x8F, W0
0092F6  78009E     MOV [W14], W1
0092F8  508F80     SUB W1, W0, [W15]
0092FA  34FFF9     BRA LE, .L183
2104:                  {
2105:                    writeData(0x00);
0092EE  EB4000     CLR.B W0
0092F0  07F84D     RCALL writeData
2106:                  }
2107:                  //partial refresh of the same area as the partial update
2108:                  writeCMD(0x16);
0092FC  B3C160     MOV.B #0x16, W0
0092FE  07F837     RCALL writeCMD
2109:                  writeData(0x00);  //1st half x
009300  EB4000     CLR.B W0
009302  07F844     RCALL writeData
2110:                  writeData(digit_pos_x[1]);  //2nd half x
009304  804410     MOV 0x882, W0
009306  784000     MOV.B W0, W0
009308  07F841     RCALL writeData
2111:                  writeData(0x00);  //1st half y
00930A  EB4000     CLR.B W0
00930C  07F83F     RCALL writeData
2112:                  writeData(digit_pos_y[1]);  //2nd half y
00930E  804430     MOV 0x886, W0
009310  784000     MOV.B W0, W0
009312  07F83C     RCALL writeData
2113:                  writeData(0x00);  //1st half w
009314  EB4000     CLR.B W0
009316  07F83A     RCALL writeData
2114:                  writeData(Battery_WIDTH_PIXELS);  //2nd half w
009318  B3C180     MOV.B #0x18, W0
00931A  07F838     RCALL writeData
2115:                  writeData(0x00);  //1st half l
00931C  EB4000     CLR.B W0
00931E  07F836     RCALL writeData
2116:                  writeData(Battery_HEIGHT_PIXELS);  //2nd half l
009320  B3C300     MOV.B #0x30, W0
009322  07F834     RCALL writeData
2117:              
2118:                  while (0 == BSY_DISP_GetValue());
009324  000000     NOP
009326  803620     MOV PORTF, W0
009328  600061     AND W0, #0x1, W0
00932A  E00000     CP0 W0
00932C  32FFFC     BRA Z, .L184
2119:                  //wait so you can view the screen
2120:                  //delay(1000);
2121:                  
2122:              }
00932E  FA8000     ULNK
009330  060000     RETURN
2123:              
2124:              void epaper_draw_timer(int draw_timer)
2125:              {
009332  FA0004     LNK #0x4
009334  980710     MOV W0, [W14+2]
2126:                  int h;
2127:                  
2128:                  digit_pos_x[0] = timer_icon_x;
009336  8047D0     MOV 0x8FA, W0
009338  884400     MOV W0, digit_pos_x
2129:                  digit_pos_y[0] = timer_icon_y;
00933A  8047E0     MOV 0x8FC, W0
00933C  884420     MOV W0, digit_pos_y
2130:                  digit_pos_x[1] = batt_pos_x;
00933E  8047B0     MOV 0x8F6, W0
009340  884410     MOV W0, 0x882
2131:                  digit_pos_y[1] = batt_pos_y;
009342  8047C0     MOV 0x8F8, W0
009344  884430     MOV W0, 0x886
2132:                  map_digit_coords();
009346  07FAEE     RCALL map_digit_coords
2133:              
2134:                  //partial updating the screen: Black
2135:                  writeCMD(0x14);
009348  B3C140     MOV.B #0x14, W0
00934A  07F811     RCALL writeCMD
2136:                  writeData(0x00);  //1st half x
00934C  EB4000     CLR.B W0
00934E  07F81E     RCALL writeData
2137:                  writeData(digit_pos_x[1]);  //2nd half x
009350  804410     MOV 0x882, W0
009352  784000     MOV.B W0, W0
009354  07F81B     RCALL writeData
2138:                  writeData(0x00);  //1st half y
009356  EB4000     CLR.B W0
009358  07F819     RCALL writeData
2139:                  writeData(digit_pos_y[1]);  //2nd half y
00935A  804430     MOV 0x886, W0
00935C  784000     MOV.B W0, W0
00935E  07F816     RCALL writeData
2140:                  writeData(0x00);  //1st half w
009360  EB4000     CLR.B W0
009362  07F814     RCALL writeData
2141:                  writeData(Timer_WIDTH_PIXELS);  //2nd half w
009364  B3C180     MOV.B #0x18, W0
009366  07F812     RCALL writeData
2142:                  writeData(0x00);  //1st half l
009368  EB4000     CLR.B W0
00936A  07F810     RCALL writeData
2143:                  writeData(Timer_HEIGHT_PIXELS);  //2nd half l
00936C  B3C180     MOV.B #0x18, W0
00936E  07F80E     RCALL writeData
2144:              
2145:                  if (draw_timer == 1)
009370  90001E     MOV [W14+2], W0
009372  500FE1     SUB W0, #0x1, [W15]
009374  3A000D     BRA NZ, .L186
2146:                  {
2147:                      for (h = 0; h < ( (Timer_HEIGHT_PIXELS * Timer_WIDTH_PIXELS) / Timer_WIDTH_MONO_BYTES ) ; h++)
009376  EB0000     CLR W0
009378  780F00     MOV W0, [W14]
00937A  370005     BRA .L187
009384  E80F1E     INC [W14], [W14]
009386  200470     MOV #0x47, W0
009388  78009E     MOV [W14], W1
00938A  508F80     SUB W1, W0, [W15]
00938C  34FFF7     BRA LE, .L188
00938E  37000A     BRA .L189
2148:                      {
2149:                        writeData(IMG_Timer[h]);
00937C  212F60     MOV #0x12F6, W0
00937E  40001E     ADD W0, [W14], W0
009380  784010     MOV.B [W0], W0
009382  07F804     RCALL writeData
2150:                      }
2151:                  }
2152:                  else 
2153:                  {
2154:                      for (h = 0; h < ( (Battery_HEIGHT_PIXELS * Battery_WIDTH_PIXELS) / Battery_WIDTH_MONO_BYTES ) ; h++)
009390  EB0000     CLR W0
009392  780F00     MOV W0, [W14]
009394  370003     BRA .L190
00939A  E80F1E     INC [W14], [W14]
00939C  2008F0     MOV #0x8F, W0
00939E  78009E     MOV [W14], W1
0093A0  508F80     SUB W1, W0, [W15]
0093A2  34FFF9     BRA LE, .L191
2155:                      {
2156:                        writeData(0x00);
009396  EB4000     CLR.B W0
009398  07F7F9     RCALL writeData
2157:                      }
2158:                  }
2159:                  //partial updating the screen: Red
2160:                  writeCMD(0x15);
0093A4  B3C150     MOV.B #0x15, W0
0093A6  07F7E3     RCALL writeCMD
2161:                  writeData(0x00);  //1st half x
0093A8  EB4000     CLR.B W0
0093AA  07F7F0     RCALL writeData
2162:                  writeData(digit_pos_x[1]);  //2nd half x
0093AC  804410     MOV 0x882, W0
0093AE  784000     MOV.B W0, W0
0093B0  07F7ED     RCALL writeData
2163:                  writeData(0x00);  //1st half y
0093B2  EB4000     CLR.B W0
0093B4  07F7EB     RCALL writeData
2164:                  writeData(digit_pos_y[1]);  //2nd half y
0093B6  804430     MOV 0x886, W0
0093B8  784000     MOV.B W0, W0
0093BA  07F7E8     RCALL writeData
2165:                  writeData(0x00);  //1st half w
0093BC  EB4000     CLR.B W0
0093BE  07F7E6     RCALL writeData
2166:                  writeData(Timer_WIDTH_PIXELS);  //2nd half w
0093C0  B3C180     MOV.B #0x18, W0
0093C2  07F7E4     RCALL writeData
2167:                  writeData(0x00);  //1st half l
0093C4  EB4000     CLR.B W0
0093C6  07F7E2     RCALL writeData
2168:                  writeData(Timer_HEIGHT_PIXELS);  //2nd half l
0093C8  B3C180     MOV.B #0x18, W0
0093CA  07F7E0     RCALL writeData
2169:              
2170:                  for (h = 0; h < ( (Timer_HEIGHT_PIXELS * Timer_WIDTH_PIXELS) / Timer_WIDTH_MONO_BYTES ) ; h++)
0093CC  EB0000     CLR W0
0093CE  780F00     MOV W0, [W14]
0093D0  370003     BRA .L192
0093D6  E80F1E     INC [W14], [W14]
0093D8  200470     MOV #0x47, W0
0093DA  78009E     MOV [W14], W1
0093DC  508F80     SUB W1, W0, [W15]
0093DE  34FFF9     BRA LE, .L193
2171:                  {
2172:                    writeData(0x00);
0093D2  EB4000     CLR.B W0
0093D4  07F7DB     RCALL writeData
2173:                  }
2174:                  //partial refresh of the same area as the partial update
2175:                  writeCMD(0x16);
0093E0  B3C160     MOV.B #0x16, W0
0093E2  07F7C5     RCALL writeCMD
2176:                  writeData(0x00);  //1st half x
0093E4  EB4000     CLR.B W0
0093E6  07F7D2     RCALL writeData
2177:                  writeData(digit_pos_x[1]);  //2nd half x
0093E8  804410     MOV 0x882, W0
0093EA  784000     MOV.B W0, W0
0093EC  07F7CF     RCALL writeData
2178:                  writeData(0x00);  //1st half y
0093EE  EB4000     CLR.B W0
0093F0  07F7CD     RCALL writeData
2179:                  writeData(digit_pos_y[1]);  //2nd half y
0093F2  804430     MOV 0x886, W0
0093F4  784000     MOV.B W0, W0
0093F6  07F7CA     RCALL writeData
2180:                  writeData(0x00);  //1st half w
0093F8  EB4000     CLR.B W0
0093FA  07F7C8     RCALL writeData
2181:                  writeData(Timer_WIDTH_PIXELS);  //2nd half w
0093FC  B3C180     MOV.B #0x18, W0
0093FE  07F7C6     RCALL writeData
2182:                  writeData(0x00);  //1st half l
009400  EB4000     CLR.B W0
009402  07F7C4     RCALL writeData
2183:                  writeData(Timer_HEIGHT_PIXELS);  //2nd half l
009404  B3C180     MOV.B #0x18, W0
009406  07F7C2     RCALL writeData
2184:              
2185:                  while (0 == BSY_DISP_GetValue());
009408  000000     NOP
00940A  803620     MOV PORTF, W0
00940C  600061     AND W0, #0x1, W0
00940E  E00000     CP0 W0
009410  32FFFC     BRA Z, .L194
2186:                  //wait so you can view the screen
2187:                  //delay(1000);
2188:              }
009412  FA8000     ULNK
009414  060000     RETURN
2189:              
2190:              
2191:              // draw functions: end
2192:              
---  C:/Users/pvan002/Box Sync/low_income_thermostats/lita_sw/R1/RN4871.c  ------------------------------
1:                  /*
2:                  *      
3:                  *      File:   main.c
4:                  *      Author: Madhu Annapragada
5:                  *      Company: Automation Research Group
6:                  *               3401 Grays Ferry Ave, B197, STE305
7:                  *               Philadelphia, PA 19146 
8:                  *               302-897-7776
9:                  *      Created on February 11, 2016
10:                 * 
11:                 */
12:                
13:                #include <xc.h>
14:                #include "Main.h"
15:                #include "HAL.h"
16:                #include "RN4871.h"
17:                
18:                
19:                char BTH_ADV_PWR[] = "3"; //0 to 5 , 0 = highest advertisement power
20:                char BTH_CON_PWR[] = "3"; //0 to 5 , 0 = highest connection power
21:                
22:                //GLOBALS:
23:                uint16_t BTH_Rx_DataIndex = 0;
24:                uint8_t BTH_RxData[BTH_BUFFER_SIZE] = {0};
25:                uint8_t BTH_DataAvailable = 0;
26:                bool BLE_Connected = false;
27:                
28:                /*
29:                 * RN4871 Initialize
30:                 * 
31:                 * Power is set to 3 (mid range) 
32:                 * Default services are device info and transparent UART only - Line 82
33:                 * Beacons and adv are enabled - Line 88
34:                 * Min interval = 1s, max = 2s, latency = 80, timeout = 2s - Line 78
35:                 */
36:                uint8_t RN4871_Init(void)
37:                {
00BDBA  FA0028     LNK #0x28
38:                    char tmpStr[40] = {0};
00BDBC  090013     REPEAT #0x13
00BDBE  EB1F00     CLR [W14++]
00BDC0  B1028E     SUB #0x28, W14
39:                    
40:                    //Waking the module up
41:                    RN4871_RTS_SetHigh();
00BDC2  A8469E     BSET LATD, #2
42:                    RN4871_Wake_SetLow();
00BDC4  A9C677     BCLR 0x677, #6
43:                    __delay_ms(5);
00BDC6  238800     MOV #0x3880, W0
00BDC8  200011     MOV #0x1, W1
00BDCA  070903     RCALL ___delay32, .Letext0, .LFE18
44:                    
45:                    RN4871_Reset();
00BDCC  070250     RCALL RN4871_Reset
46:                    
47:                    //Going into command mode:    
48:                    RN4871_Send_Command("$$$"); //this should return a cmd within 10ms
00BDCE  2D4700     MOV #0xD470, W0
00BDD0  070259     RCALL RN4871_Send_Command
49:                    __delay_ms(25);
00BDD2  21A800     MOV #0x1A80, W0
00BDD4  200061     MOV #0x6, W1
00BDD6  0708FD     RCALL ___delay32, .Letext0, .LFE18
50:                    
51:                    
52:                    //Disabling command prompt:
53:                    RN4871_Send_Command("SR,4000\r");
00BDD8  2D4740     MOV #0xD474, W0
00BDDA  070254     RCALL RN4871_Send_Command
54:                    if (!RN4871_Check_For_AOK(200))
00BDDC  200C80     MOV #0xC8, W0
00BDDE  0701D5     RCALL RN4871_Check_For_AOK
00BDE0  E00400     CP0.B W0
00BDE2  3A0002     BRA NZ, .L2
55:                    {
56:                        return 0;
00BDE4  EB4000     CLR.B W0
00BDE6  3700C0     BRA .L3
57:                    }
58:                    
59:                    /*Setting connection parameters:
60:                     * RN4871 user guide page # 24
61:                     * 
62:                     * MIN INTERVAL - SET IN 1.25ms increments
63:                     * Android expects 16.25ms minimum communication interval
64:                     * iOS expects this value >= 16
65:                     * Setting min interval to 1000ms = 800(0x0320)[old value->]16.25 => = 13 in 1.25ms increments = 0x0D
66:                     * 
67:                     * MAX INTERVAL - SET IN 1.25ms increments
68:                     * max interval >=20 for iOS -> setting it to 2000ms = 1600 (0x0540)[old value] 600ms = 480 (1E0) in 1.25ms units
69:                     * 
70:                     * Latency  < (Timeout*10) / (Interval * 1.25 -1) <= 80 (0x0050) [old value] 34 - setting to 30 (0x1E)
71:                     *       
72:                     * Timeout : maximum time allowed before link is considered lost:
73:                     *           The app would normally be getting data every 5 seconds
74:                     *           Setting the timeout to 2seconds = 2000ms = 200 in 10ms units = 0x00C8[old value] 0x7D0
75:                     * iOs requires (interval+16)*(latency+1) < Timeout * 8/3
76:                     *              466 * 11 < 5333 - OK
77:                     * 
78:                    */
79:                    RN4871_Send_Command("ST,000D,01E0,000A,07D0\r");
00BDE8  2D47D0     MOV #0xD47D, W0
00BDEA  07024C     RCALL RN4871_Send_Command
80:                    //These settings make the adv interval longer..
81:                    //RN4871_Send_Command("ST,0320,0540,0050,00C8\r");
82:                    if (!RN4871_Check_For_AOK(200))
00BDEC  200C80     MOV #0xC8, W0
00BDEE  0701CD     RCALL RN4871_Check_For_AOK
00BDF0  E00400     CP0.B W0
00BDF2  3A0002     BRA NZ, .L4
83:                    {
84:                        return 0;
00BDF4  EB4000     CLR.B W0
00BDF6  3700B8     BRA .L3
85:                    }
86:                    
87:                    //Setting default services to device info, Transparent UART:
88:                    RN4871_Send_Command("SS,C0\r");
00BDF8  2D4950     MOV #0xD495, W0
00BDFA  070244     RCALL RN4871_Send_Command
89:                    if (!RN4871_Check_For_AOK(200))
00BDFC  200C80     MOV #0xC8, W0
00BDFE  0701C5     RCALL RN4871_Check_For_AOK
00BE00  E00400     CP0.B W0
00BE02  3A0002     BRA NZ, .L5
90:                    {
91:                        return 0;
00BE04  EB4000     CLR.B W0
00BE06  3700B0     BRA .L3
92:                    }
93:                    
94:                    //enabling  beacon with connectable adv:
95:                    RN4871_Send_Command("SC,2\r"); //
00BE08  2D49C0     MOV #0xD49C, W0
00BE0A  07023C     RCALL RN4871_Send_Command
96:                    if (!RN4871_Check_For_AOK(200))
00BE0C  200C80     MOV #0xC8, W0
00BE0E  0701BD     RCALL RN4871_Check_For_AOK
00BE10  E00400     CP0.B W0
00BE12  3A0002     BRA NZ, .L6
97:                    {
98:                        return 0;
00BE14  EB4000     CLR.B W0
00BE16  3700A8     BRA .L3
99:                    }
100:                   
101:                
102:                   //Setting up the model name with the serial number appended
103:                   strcpy((char*)tmpStr,"SN,");
00BE18  200042     MOV #0x4, W2
00BE1A  2D4A21     MOV #0xD4A2, W1
00BE1C  78000E     MOV W14, W0
00BE1E  07A768     RCALL _memcpy
104:                   strcat((char*)tmpStr,(char*)MODEL_NAME);
00BE20  220E41     MOV #0x20E4, W1
00BE22  78000E     MOV W14, W0
00BE24  07A846     RCALL _strcat
105:                   strcat((char*)tmpStr,(char*)SerialNum);
00BE26  220F71     MOV #0x20F7, W1
00BE28  78000E     MOV W14, W0
00BE2A  07A843     RCALL _strcat
106:                   strcat((char*)tmpStr,"\r");
00BE2C  78000E     MOV W14, W0
00BE2E  07A851     RCALL _strlen
00BE30  470000     ADD W14, W0, W0
00BE32  200022     MOV #0x2, W2
00BE34  2D4A61     MOV #0xD4A6, W1
00BE36  07A75C     RCALL _memcpy
107:                   RN4871_Send_Command(tmpStr);
00BE38  78000E     MOV W14, W0
00BE3A  070224     RCALL RN4871_Send_Command
108:                   if (!RN4871_Check_For_AOK(200))
00BE3C  200C80     MOV #0xC8, W0
00BE3E  0701A5     RCALL RN4871_Check_For_AOK
00BE40  E00400     CP0.B W0
00BE42  3A0002     BRA NZ, .L7
109:                   {
110:                       return 0;
00BE44  EB4000     CLR.B W0
00BE46  370090     BRA .L3
111:                   }
112:                   
113:                   //Setting up Manufacturer Name:
114:                   strcpy((char*)tmpStr,"SDN,");
00BE48  200052     MOV #0x5, W2
00BE4A  2D4A81     MOV #0xD4A8, W1
00BE4C  78000E     MOV W14, W0
00BE4E  07A750     RCALL _memcpy
115:                   strcat((char*)tmpStr,(char*)MFG_NAME);
00BE50  2212B1     MOV #0x212B, W1
00BE52  78000E     MOV W14, W0
00BE54  07A82E     RCALL _strcat
116:                   strcat((char*)tmpStr,"\r");
00BE56  78000E     MOV W14, W0
00BE58  07A83C     RCALL _strlen
00BE5A  470000     ADD W14, W0, W0
00BE5C  200022     MOV #0x2, W2
00BE5E  2D4A61     MOV #0xD4A6, W1
00BE60  07A747     RCALL _memcpy
117:                   RN4871_Send_Command(tmpStr);
00BE62  78000E     MOV W14, W0
00BE64  07020F     RCALL RN4871_Send_Command
118:                   if (!RN4871_Check_For_AOK(200))
00BE66  200C80     MOV #0xC8, W0
00BE68  070190     RCALL RN4871_Check_For_AOK
00BE6A  E00400     CP0.B W0
00BE6C  3A0002     BRA NZ, .L8
119:                   {
120:                       return 0;
00BE6E  EB4000     CLR.B W0
00BE70  37007B     BRA .L3
121:                   }
122:                   
123:                   //Setting up Hardware Revision:
124:                   strcpy((char*)tmpStr,"SDH,");
00BE72  200052     MOV #0x5, W2
00BE74  2D4AD1     MOV #0xD4AD, W1
00BE76  78000E     MOV W14, W0
00BE78  07A73B     RCALL _memcpy
125:                   strcat((char*)tmpStr,(char*)HARDWARE_REVISION);
00BE7A  221251     MOV #0x2125, W1
00BE7C  78000E     MOV W14, W0
00BE7E  07A819     RCALL _strcat
126:                   strcat((char*)tmpStr,"\r");
00BE80  78000E     MOV W14, W0
00BE82  07A827     RCALL _strlen
00BE84  470000     ADD W14, W0, W0
00BE86  200022     MOV #0x2, W2
00BE88  2D4A61     MOV #0xD4A6, W1
00BE8A  07A732     RCALL _memcpy
127:                   RN4871_Send_Command(tmpStr);
00BE8C  78000E     MOV W14, W0
00BE8E  0701FA     RCALL RN4871_Send_Command
128:                   if (!RN4871_Check_For_AOK(200))
00BE90  200C80     MOV #0xC8, W0
00BE92  07017B     RCALL RN4871_Check_For_AOK
00BE94  E00400     CP0.B W0
00BE96  3A0002     BRA NZ, .L9
129:                   {
130:                       return 0;
00BE98  EB4000     CLR.B W0
00BE9A  370066     BRA .L3
131:                   }    
132:                   
133:                   //setting up Software Revision:
134:                   strcpy((char*)tmpStr,"SDR,");
00BE9C  200052     MOV #0x5, W2
00BE9E  2D4B21     MOV #0xD4B2, W1
00BEA0  78000E     MOV W14, W0
00BEA2  07A726     RCALL _memcpy
135:                   strcat((char*)tmpStr,(char*)SOFTWARE_REV);
00BEA4  221341     MOV #0x2134, W1
00BEA6  78000E     MOV W14, W0
00BEA8  07A804     RCALL _strcat
136:                   strcat((char*)tmpStr,"\r");
00BEAA  78000E     MOV W14, W0
00BEAC  07A812     RCALL _strlen
00BEAE  470000     ADD W14, W0, W0
00BEB0  200022     MOV #0x2, W2
00BEB2  2D4A61     MOV #0xD4A6, W1
00BEB4  07A71D     RCALL _memcpy
137:                   RN4871_Send_Command(tmpStr);
00BEB6  78000E     MOV W14, W0
00BEB8  0701E5     RCALL RN4871_Send_Command
138:                   if (!RN4871_Check_For_AOK(200))
00BEBA  200C80     MOV #0xC8, W0
00BEBC  070166     RCALL RN4871_Check_For_AOK
00BEBE  E00400     CP0.B W0
00BEC0  3A0002     BRA NZ, .L10
139:                   {
140:                       return 0;
00BEC2  EB4000     CLR.B W0
00BEC4  370051     BRA .L3
141:                   }
142:                   
143:                   //setting up Serial Number
144:                   strcpy((char*)tmpStr,"SDS,");
00BEC6  200052     MOV #0x5, W2
00BEC8  2D4B71     MOV #0xD4B7, W1
00BECA  78000E     MOV W14, W0
00BECC  07A711     RCALL _memcpy
145:                   strcat((char*)tmpStr,(char*)SerialNum);
00BECE  220F71     MOV #0x20F7, W1
00BED0  78000E     MOV W14, W0
00BED2  07A7EF     RCALL _strcat
146:                   strcat((char*)tmpStr,"\r");
00BED4  78000E     MOV W14, W0
00BED6  07A7FD     RCALL _strlen
00BED8  470000     ADD W14, W0, W0
00BEDA  200022     MOV #0x2, W2
00BEDC  2D4A61     MOV #0xD4A6, W1
00BEDE  07A708     RCALL _memcpy
147:                   RN4871_Send_Command(tmpStr);
00BEE0  78000E     MOV W14, W0
00BEE2  0701D0     RCALL RN4871_Send_Command
148:                   if (!RN4871_Check_For_AOK(200))
00BEE4  200C80     MOV #0xC8, W0
00BEE6  070151     RCALL RN4871_Check_For_AOK
00BEE8  E00400     CP0.B W0
00BEEA  3A0002     BRA NZ, .L11
149:                   {
150:                       return 0;
00BEEC  EB4000     CLR.B W0
00BEEE  37003C     BRA .L3
151:                   }    
152:                   
153:                   //Setting advertisements and connection to power specified
154:                   strcpy((char*)tmpStr,"SGA,");
00BEF0  200052     MOV #0x5, W2
00BEF2  2D4BC1     MOV #0xD4BC, W1
00BEF4  78000E     MOV W14, W0
00BEF6  07A6FC     RCALL _memcpy
155:                   strcat((char*)tmpStr,(char*)BTH_ADV_PWR);
00BEF8  226861     MOV #0x2686, W1
00BEFA  78000E     MOV W14, W0
00BEFC  07A7DA     RCALL _strcat
156:                   strcat((char*)tmpStr,"\r");
00BEFE  78000E     MOV W14, W0
00BF00  07A7E8     RCALL _strlen
00BF02  470000     ADD W14, W0, W0
00BF04  200022     MOV #0x2, W2
00BF06  2D4A61     MOV #0xD4A6, W1
00BF08  07A6F3     RCALL _memcpy
157:                   RN4871_Send_Command(tmpStr);
00BF0A  78000E     MOV W14, W0
00BF0C  0701BB     RCALL RN4871_Send_Command
158:                   if (!RN4871_Check_For_AOK(200))
00BF0E  200C80     MOV #0xC8, W0
00BF10  07013C     RCALL RN4871_Check_For_AOK
00BF12  E00400     CP0.B W0
00BF14  3A0002     BRA NZ, .L12
159:                   {
160:                       return 0;
00BF16  EB4000     CLR.B W0
00BF18  370027     BRA .L3
161:                   }     
162:                   strcpy((char*)tmpStr,"SGC,");
00BF1A  200052     MOV #0x5, W2
00BF1C  2D4C11     MOV #0xD4C1, W1
00BF1E  78000E     MOV W14, W0
00BF20  07A6E7     RCALL _memcpy
163:                   strcat((char*)tmpStr,(char*)BTH_CON_PWR);
00BF22  226881     MOV #0x2688, W1
00BF24  78000E     MOV W14, W0
00BF26  07A7C5     RCALL _strcat
164:                   strcat((char*)tmpStr,"\r");
00BF28  78000E     MOV W14, W0
00BF2A  07A7D3     RCALL _strlen
00BF2C  470000     ADD W14, W0, W0
00BF2E  200022     MOV #0x2, W2
00BF30  2D4A61     MOV #0xD4A6, W1
00BF32  07A6DE     RCALL _memcpy
165:                   RN4871_Send_Command(tmpStr);
00BF34  78000E     MOV W14, W0
00BF36  0701A6     RCALL RN4871_Send_Command
166:                   if (!RN4871_Check_For_AOK(200))
00BF38  200C80     MOV #0xC8, W0
00BF3A  070127     RCALL RN4871_Check_For_AOK
00BF3C  E00400     CP0.B W0
00BF3E  3A0002     BRA NZ, .L13
167:                   {
168:                       return 0;
00BF40  EB4000     CLR.B W0
00BF42  370012     BRA .L3
169:                   }
170:                   
171:                   //Setting up configurable IO to make P12 as Status1
172:                   RN4871_Send_Command("SW,0A,07\r");
00BF44  2D4C60     MOV #0xD4C6, W0
00BF46  07019E     RCALL RN4871_Send_Command
173:                   if (!RN4871_Check_For_AOK(200))
00BF48  200C80     MOV #0xC8, W0
00BF4A  07011F     RCALL RN4871_Check_For_AOK
00BF4C  E00400     CP0.B W0
00BF4E  3A0002     BRA NZ, .L14
174:                   {
175:                       return 0;
00BF50  EB4000     CLR.B W0
00BF52  37000A     BRA .L3
176:                   }
177:                   
178:                   //enabling UART_Rx_IND
179:                   RN4871_Send_Command("SW,0C,04\r");
00BF54  2D4D00     MOV #0xD4D0, W0
00BF56  070196     RCALL RN4871_Send_Command
180:                   if (!RN4871_Check_For_AOK(200))
00BF58  200C80     MOV #0xC8, W0
00BF5A  070117     RCALL RN4871_Check_For_AOK
00BF5C  E00400     CP0.B W0
00BF5E  3A0002     BRA NZ, .L15
181:                   {
182:                       return 0;
00BF60  EB4000     CLR.B W0
00BF62  370002     BRA .L3
183:                   }
184:                   
185:                   
186:                   
187:                   RN4871_Reboot(); /* to make the changes take effect */
00BF64  070158     RCALL RN4871_Reboot
188:               
189:                   return 1;
00BF66  B3C010     MOV.B #0x1, W0
190:                   
191:               }
00BF68  FA8000     ULNK
00BF6A  060000     RETURN
192:               
193:               uint8_t RN4871_Clear_All_Services(void)
194:               {
00BF6C  FA0000     LNK #0x0
195:                    //Clearing up all settings and services:
196:                   RN4871_Send_Command("PZ\r");
00BF6E  2D4DA0     MOV #0xD4DA, W0
00BF70  070189     RCALL RN4871_Send_Command
197:                   if (!RN4871_Check_For_AOK(500))
00BF72  201F40     MOV #0x1F4, W0
00BF74  07010A     RCALL RN4871_Check_For_AOK
00BF76  E00400     CP0.B W0
00BF78  3A0002     BRA NZ, .L17
198:                   {
199:                       return 0;
00BF7A  EB4000     CLR.B W0
00BF7C  370001     BRA .L18
200:                   }
201:                   return 1;
00BF7E  B3C010     MOV.B #0x1, W0
202:               }
00BF80  FA8000     ULNK
00BF82  060000     RETURN
203:               
204:               /**
205:                * Set up Private Service
206:                * 
207:                * @param serviceUUID
208:                * @return 
209:                */
210:               uint8_t RN4871_SetUp_Private_Service(const char *serviceUUID)
211:               {
00BF84  FA002A     LNK #0x2A
00BF86  981740     MOV W0, [W14+40]
212:                   char tmpStr[40] = {0};
00BF88  090013     REPEAT #0x13
00BF8A  EB1F00     CLR [W14++]
00BF8C  B1028E     SUB #0x28, W14
213:                   strcpy((char*)tmpStr,"PS,");
00BF8E  200042     MOV #0x4, W2
00BF90  2D4DE1     MOV #0xD4DE, W1
00BF92  78000E     MOV W14, W0
00BF94  07A6AD     RCALL _memcpy
214:                   strcat((char*)tmpStr,(char*)serviceUUID);
00BF96  9010CE     MOV [W14+40], W1
00BF98  78000E     MOV W14, W0
00BF9A  07A78B     RCALL _strcat
215:                   strcat((char*)tmpStr,"\r");
00BF9C  78000E     MOV W14, W0
00BF9E  07A799     RCALL _strlen
00BFA0  470000     ADD W14, W0, W0
00BFA2  200022     MOV #0x2, W2
00BFA4  2D4A61     MOV #0xD4A6, W1
00BFA6  07A6A4     RCALL _memcpy
216:                   RN4871_Send_Command(tmpStr);
00BFA8  78000E     MOV W14, W0
00BFAA  07016C     RCALL RN4871_Send_Command
217:                   if (!RN4871_Check_For_AOK(3000))
00BFAC  20BB80     MOV #0xBB8, W0
00BFAE  0700ED     RCALL RN4871_Check_For_AOK
00BFB0  E00400     CP0.B W0
00BFB2  3A0002     BRA NZ, .L20
218:                   {
219:                       return 0;
00BFB4  EB4000     CLR.B W0
00BFB6  370001     BRA .L21
220:                   }
221:                   return 1;
00BFB8  B3C010     MOV.B #0x1, W0
222:               }
00BFBA  FA8000     ULNK
00BFBC  060000     RETURN
223:               
224:               /**
225:                * Set up Private Characteristic
226:                * 
227:                * @param characteristicUUID - 128 bit private UUID
228:                * @param rwi: property - read = 2, write_no_response = 4,write = 8, notify = 16, indicate = 32
229:                * @param charcLen - number of bytes of data
230:                * @return 
231:                */
232:               uint8_t RN4871_SetUp_Private_Characteristic(const char *characteristicUUID, uint8_t rwi, uint8_t charcLen)
233:               {
00BFBE  FA0040     LNK #0x40
00BFC0  981F60     MOV W0, [W14+60]
00BFC2  987F61     MOV.B W1, [W14+62]
00BFC4  987F72     MOV.B W2, [W14+63]
234:                   char tmpStr[50] = {0};
00BFC6  090018     REPEAT #0x18
00BFC8  EB1F00     CLR [W14++]
00BFCA  B1032E     SUB #0x32, W14
235:                   char tmpStr2[10] = {0};
00BFCC  78008E     MOV W14, W1
00BFCE  B00321     ADD #0x32, W1
00BFD0  090004     REPEAT #0x4
00BFD2  EB1880     CLR [W1++]
236:                   
237:                   strcpy((char*)tmpStr,"PC,");
00BFD4  200042     MOV #0x4, W2
00BFD6  2D4E21     MOV #0xD4E2, W1
00BFD8  78000E     MOV W14, W0
00BFDA  07A68A     RCALL _memcpy
238:                   strcat((char*)tmpStr,(char*)characteristicUUID);
00BFDC  9018EE     MOV [W14+60], W1
00BFDE  78000E     MOV W14, W0
00BFE0  07A768     RCALL _strcat
239:                   strcat((char*)tmpStr,",");
00BFE2  78000E     MOV W14, W0
00BFE4  07A776     RCALL _strlen
00BFE6  470000     ADD W14, W0, W0
00BFE8  200022     MOV #0x2, W2
00BFEA  2D4E61     MOV #0xD4E6, W1
00BFEC  07A681     RCALL _memcpy
240:                   sprintf ( (char*) tmpStr2, "%02X,%02X\r", rwi,charcLen); 
00BFEE  90787E     MOV.B [W14+63], W0
00BFF0  FB8100     ZE W0, W2
00BFF2  90786E     MOV.B [W14+62], W0
00BFF4  FB8080     ZE W0, W1
00BFF6  200320     MOV #0x32, W0
00BFF8  40000E     ADD W0, W14, W0
00BFFA  781F82     MOV W2, [W15++]
00BFFC  781F81     MOV W1, [W15++]
00BFFE  2D4E81     MOV #0xD4E8, W1
00C000  781F81     MOV W1, [W15++]
00C002  07AA97     RCALL __sprintf_cdnopuxX, __sprintf_cdnopsuxX
00C004  5787E6     SUB W15, #0x6, W15
241:                   strcat((char*)tmpStr, tmpStr2);     
00C006  200320     MOV #0x32, W0
00C008  40000E     ADD W0, W14, W0
00C00A  780080     MOV W0, W1
00C00C  78000E     MOV W14, W0
00C00E  07A751     RCALL _strcat
242:                   RN4871_Send_Command(tmpStr);
00C010  78000E     MOV W14, W0
00C012  070138     RCALL RN4871_Send_Command
243:                   
244:                   if (!RN4871_Check_For_AOK(3000))
00C014  20BB80     MOV #0xBB8, W0
00C016  0700B9     RCALL RN4871_Check_For_AOK
00C018  E00400     CP0.B W0
00C01A  3A0002     BRA NZ, .L23
245:                   {
246:                       return 0;
00C01C  EB4000     CLR.B W0
00C01E  370001     BRA .L24
247:                   }    
248:                   return 1;
00C020  B3C010     MOV.B #0x1, W0
249:               }
00C022  FA8000     ULNK
00C024  060000     RETURN
250:               
251:               /**
252:                * Set Characteristic Value
253:                * 
254:                * Uses the command SHW to update the local characteristic
255:                * 
256:                * @param handle to the private characteristic
257:                * @param data uint16_t
258:                * @param len - number of hex bytes to be sent - this should correspond to the 
259:                *        length allocated to the data field when setting up the characteristic
260:                * @return 1 if successful, 0 on failure
261:                */
262:               uint8_t RN4871_Set_Characteristic_Value_Word(const char *handle, uint16_t data)
263:               {
00C026  FA0036     LNK #0x36
00C028  981F10     MOV W0, [W14+50]
00C02A  981F21     MOV W1, [W14+52]
264:                   char tmpStr[40] = {0};
00C02C  090013     REPEAT #0x13
00C02E  EB1F00     CLR [W14++]
00C030  B1028E     SUB #0x28, W14
265:                   char tmpStr2[10] = {0};
00C032  78008E     MOV W14, W1
00C034  B00281     ADD #0x28, W1
00C036  090004     REPEAT #0x4
00C038  EB1880     CLR [W1++]
266:                   
267:                   strcpy((char*)tmpStr,"SHW,");
00C03A  200052     MOV #0x5, W2
00C03C  2D4F31     MOV #0xD4F3, W1
00C03E  78000E     MOV W14, W0
00C040  07A657     RCALL _memcpy
268:                   strcat((char*)tmpStr,(char*)handle);
00C042  90189E     MOV [W14+50], W1
00C044  78000E     MOV W14, W0
00C046  07A735     RCALL _strcat
269:                   strcat((char*)tmpStr,",");
00C048  78000E     MOV W14, W0
00C04A  07A743     RCALL _strlen
00C04C  470000     ADD W14, W0, W0
00C04E  200022     MOV #0x2, W2
00C050  2D4E61     MOV #0xD4E6, W1
00C052  07A64E     RCALL _memcpy
270:                   //TODO: note that we always send out 2 bytes of data - have to fix this
271:                   sprintf ( (char*) tmpStr2, "%04X\r", data);
00C054  200280     MOV #0x28, W0
00C056  40000E     ADD W0, W14, W0
00C058  9018AE     MOV [W14+52], W1
00C05A  781F81     MOV W1, [W15++]
00C05C  2D4F81     MOV #0xD4F8, W1
00C05E  781F81     MOV W1, [W15++]
00C060  07AA68     RCALL __sprintf_cdnopuxX, __sprintf_cdnopsuxX
00C062  5787E4     SUB W15, #0x4, W15
272:                   strcat((char*)tmpStr, tmpStr2);     
00C064  200280     MOV #0x28, W0
00C066  40000E     ADD W0, W14, W0
00C068  780080     MOV W0, W1
00C06A  78000E     MOV W14, W0
00C06C  07A722     RCALL _strcat
273:                   RN4871_Send_Command(tmpStr);
00C06E  78000E     MOV W14, W0
00C070  070109     RCALL RN4871_Send_Command
274:                   
275:                   if (!RN4871_Check_For_AOK(300))
00C072  2012C0     MOV #0x12C, W0
00C074  07008A     RCALL RN4871_Check_For_AOK
00C076  E00400     CP0.B W0
00C078  3A0002     BRA NZ, .L26
276:                   {
277:                       return 0;
00C07A  EB4000     CLR.B W0
00C07C  370001     BRA .L27
278:                   }    
279:                   return 1;
00C07E  B3C010     MOV.B #0x1, W0
280:               }
00C080  FA8000     ULNK
00C082  060000     RETURN
281:               
282:               uint16_t RN4871_Read_Characteristic_Value_Word(const char *handle)
283:               {
00C084  FA0018     LNK #0x18
00C086  980F30     MOV W0, [W14+22]
284:                   char tmpStr[20] = {0};
00C088  4700E2     ADD W14, #0x2, W1
00C08A  090009     REPEAT #0x9
00C08C  EB1880     CLR [W1++]
285:                   uint16_t retval = 0;
00C08E  EB0000     CLR W0
00C090  780F00     MOV W0, [W14]
286:                   
287:                   strcpy((char*)tmpStr,"SHR,");
00C092  E8800E     INC2 W14, W0
00C094  200052     MOV #0x5, W2
00C096  2D4FE1     MOV #0xD4FE, W1
00C098  07A62B     RCALL _memcpy
288:                   strcat((char*)tmpStr,(char*)handle);
00C09A  E8800E     INC2 W14, W0
00C09C  9008BE     MOV [W14+22], W1
00C09E  07A709     RCALL _strcat
289:                   strcat((char*)tmpStr,"\r");
00C0A0  E8800E     INC2 W14, W0
00C0A2  07A717     RCALL _strlen
00C0A4  E8808E     INC2 W14, W1
00C0A6  408000     ADD W1, W0, W0
00C0A8  200022     MOV #0x2, W2
00C0AA  2D4A61     MOV #0xD4A6, W1
00C0AC  07A621     RCALL _memcpy
290:                   RN4871_Send_Command(tmpStr);
00C0AE  E8800E     INC2 W14, W0
00C0B0  0700E9     RCALL RN4871_Send_Command
291:                   
292:                   //waiting for response for 1second:
293:                   if (!RN4871_Wait_For_Response(1000))
00C0B2  203E80     MOV #0x3E8, W0
00C0B4  07007B     RCALL RN4871_Wait_For_Response
00C0B6  E00400     CP0.B W0
00C0B8  3A0002     BRA NZ, .L29
294:                   {
295:                       return 0; //exit if no response
00C0BA  EB0000     CLR W0
00C0BC  37000E     BRA .L30
296:                   }
297:                   //TODO: change from expecting 4 numbers to make this function more generic.
298:                   //converting string to uint16_t
299:                   //we will always get 4 numbers in a string:
300:                   memset (tmpStr,0,20);
00C0BE  E8800E     INC2 W14, W0
00C0C0  200142     MOV #0x14, W2
00C0C2  EB0080     CLR W1
00C0C4  07A61C     RCALL _memset
301:                   strncpy ((char*)tmpStr, (const char*)BTH_RxData,4);
00C0C6  21CE41     MOV #0x1CE4, W1
00C0C8  E8800E     INC2 W14, W0
00C0CA  200042     MOV #0x4, W2
00C0CC  07A71C     RCALL _strncpy
302:                   retval = atol(tmpStr);
00C0CE  E8800E     INC2 W14, W0
00C0D0  2000A2     MOV #0xA, W2
00C0D2  EB0080     CLR W1
00C0D4  07A727     RCALL __Stoul
00C0D6  780F00     MOV W0, [W14]
303:                   return retval;
00C0D8  78001E     MOV [W14], W0
304:                   
305:               }
00C0DA  FA8000     ULNK
00C0DC  060000     RETURN
306:               
307:               /**
308:                * Update Advertisement packet of the bluetooth module
309:                * 
310:                * @param byte - pointer to byte array to be sent as the adv packet
311:                * @param startIndex - start position in the byte array
312:                * @param cmdLen - total length of the command array
313:                * @return 
314:                */
315:               uint8_t RN4871_UpdateAdvPacket(uint8_t *byte, uint8_t startIndex, uint8_t cmdLen)
316:               {
00C0DE  FA0010     LNK #0x10
00C0E0  980760     MOV W0, [W14+12]
00C0E2  984F61     MOV.B W1, [W14+14]
00C0E4  984F72     MOV.B W2, [W14+15]
317:                   
318:                   uint8_t i = 0;
00C0E6  EB4000     CLR.B W0
00C0E8  784F00     MOV.B W0, [W14]
319:               
320:                   char tmpStr2[10] = {0};
00C0EA  4700E1     ADD W14, #0x1, W1
00C0EC  090009     REPEAT #0x9
00C0EE  EB5880     CLR.B [W1++]
321:               
322:               
323:                   RN4871_Send_Command("IA,Z\r"); //clear advertising buffer
00C0F0  2D5030     MOV #0xD503, W0
00C0F2  0700C8     RCALL RN4871_Send_Command
324:               //        if (!BT_CheckForAok(200))
325:               //        return false;//waiting for ok    
326:                   if (!RN4871_Check_For_AOK(200))
00C0F4  200C80     MOV #0xC8, W0
00C0F6  070049     RCALL RN4871_Check_For_AOK
00C0F8  E00400     CP0.B W0
00C0FA  3A0002     BRA NZ, .L32
327:                   {
328:                       return 2;
00C0FC  B3C020     MOV.B #0x2, W0
00C0FE  37002D     BRA .L33
329:                   } 
330:                
331:                   //now sending the message as a custom advertisement
332:                   RN4871_Reset_Rx_Buffer();
00C100  07003B     RCALL RN4871_Reset_Rx_Buffer
333:                   RN4871_Send_Command("IA,FF,0000");
00C102  2D5090     MOV #0xD509, W0
00C104  0700BF     RCALL RN4871_Send_Command
334:                   for (i=startIndex; i< startIndex+cmdLen; i++)
00C106  9048EE     MOV.B [W14+14], W1
00C108  784F01     MOV.B W1, [W14]
00C10A  37000E     BRA .L34
00C126  E84F1E     INC.B [W14], [W14]
00C128  FB809E     ZE [W14], W1
00C12A  90486E     MOV.B [W14+14], W0
00C12C  FB8100     ZE W0, W2
00C12E  90487E     MOV.B [W14+15], W0
00C130  FB8000     ZE W0, W0
00C132  410000     ADD W2, W0, W0
00C134  508F80     SUB W1, W0, [W15]
00C136  35FFEA     BRA LT, .L35
335:                   { 
336:                      sprintf ( (char*) tmpStr2, "%X", byte[i]); 
00C10C  FB801E     ZE [W14], W0
00C10E  9000EE     MOV [W14+12], W1
00C110  408000     ADD W1, W0, W0
00C112  784010     MOV.B [W0], W0
00C114  FB8080     ZE W0, W1
00C116  E8000E     INC W14, W0
00C118  781F81     MOV W1, [W15++]
00C11A  2D5141     MOV #0xD514, W1
00C11C  781F81     MOV W1, [W15++]
00C11E  07AA09     RCALL __sprintf_cdnopuxX, __sprintf_cdnopsuxX
00C120  5787E4     SUB W15, #0x4, W15
337:                      RN4871_Send_Command(tmpStr2);
00C122  E8000E     INC W14, W0
00C124  0700AF     RCALL RN4871_Send_Command
338:                      
339:                   }
340:                   RN4871_Send_Command("\r");
00C138  2D4A60     MOV #0xD4A6, W0
00C13A  0700A4     RCALL RN4871_Send_Command
341:                   if (!RN4871_Check_For_AOK(200))
00C13C  200C80     MOV #0xC8, W0
00C13E  070025     RCALL RN4871_Check_For_AOK
00C140  E00400     CP0.B W0
00C142  3A0002     BRA NZ, .L36
342:                   {
343:                       return 2;
00C144  B3C020     MOV.B #0x2, W0
00C146  370009     BRA .L33
344:                   } 
345:                   RN4871_Send_Command("A\r"); //start advertising
00C148  2D5170     MOV #0xD517, W0
00C14A  07009C     RCALL RN4871_Send_Command
346:                   if (!RN4871_Check_For_AOK(200))
00C14C  200C80     MOV #0xC8, W0
00C14E  07001D     RCALL RN4871_Check_For_AOK
00C150  E00400     CP0.B W0
00C152  3A0002     BRA NZ, .L37
347:                   {
348:                       return false;//waiting for ok
00C154  EB4000     CLR.B W0
00C156  370001     BRA .L33
349:                   }
350:                
351:                    //sending the same message out as a beacon
352:               //    strcpy((char*)tmpStr,"IB,FF,");
353:               //    strcat((char*)tmpStr,(char*)tmpStr2);
354:               //    strcat((char*)tmpStr,"\r");
355:               //    BT_SendCommand(tmpStr);
356:               //    if (!BT_CheckForAok(200))
357:               //    {
358:               //        return 2;
359:               //    } 
360:               //    ResetBth_RxBuffer();
361:               //    if (!BT_CheckForAok(200))
362:               //    {
363:               //        return false;//waiting for ok
364:               //    }
365:               
366:                   return 1;
00C158  B3C010     MOV.B #0x1, W0
367:                   
368:               }
00C15A  FA8000     ULNK
00C15C  060000     RETURN
369:               
370:               void RN4871_SetLowPowerMode()
371:               {
00C15E  FA0000     LNK #0x0
372:                  
373:                  RN4871_Send_Command("SO,1\r");
00C160  2D51A0     MOV #0xD51A, W0
00C162  070090     RCALL RN4871_Send_Command
374:                  RN4871_Wake_SetHigh();
00C164  A8C677     BSET 0x677, #6
375:               //   RN4871_Reboot();
376:               //   RN4871_Wake_SetLow();
377:               //    //Going into command mode:    
378:               //    RN4871_Send_Command("$$$"); //this should return a cmd within 10ms
379:               //    __delay_ms(25);
380:               //    RN4871_Send_Command("SO,1\r");    
381:               }
00C166  FA8000     ULNK
00C168  060000     RETURN
382:               
383:               /**
384:                * Send the disconnect command 
385:                */
386:               void RN4871_Disconnect()
387:               {
00C16A  FA0000     LNK #0x0
388:                   RN4871_Send_Command("K,1\r");
00C16C  2D5200     MOV #0xD520, W0
00C16E  07008A     RCALL RN4871_Send_Command
389:                   // wait for command to execute
390:                   RN4871_Check_For_AOK(200);
00C170  200C80     MOV #0xC8, W0
00C172  07000B     RCALL RN4871_Check_For_AOK
391:               }
00C174  FA8000     ULNK
00C176  060000     RETURN
392:               
393:               /* 
394:                * Reset Rx Buffer
395:                * 
396:                * zeroing out the receive buffer 
397:                * and resetting the index to the buffer
398:                */
399:               void RN4871_Reset_Rx_Buffer(void)
400:               {
00C178  FA0000     LNK #0x0
401:                   memset (BTH_RxData, 0, BTH_BUFFER_SIZE);
00C17A  204002     MOV #0x400, W2
00C17C  EB0080     CLR W1
00C17E  21CE40     MOV #0x1CE4, W0
00C180  07A5BE     RCALL _memset
402:                   BTH_DataAvailable = 0;
00C182  EF690A     CLR.B BTH_DataAvailable
403:                   BTH_Rx_DataIndex = 0;
00C184  EF2908     CLR BTH_Rx_DataIndex
404:               }
00C186  FA8000     ULNK
00C188  060000     RETURN
405:               
406:               
407:               
408:               /*
409:                * RN4871 Check For AOK
410:                * 
411:                * Checks for the reception of the string "AOK\r\n"
412:                * from RN4871 for a given timeout value in ms
413:                * 
414:                * returns 1 if successful and a 0 if there is no response
415:                * or the response does not match AOK (could have been ERR)
416:                */
417:               uint8_t RN4871_Check_For_AOK(uint16_t timeout)
418:               {
00C18A  FA0002     LNK #0x2
00C18C  780F00     MOV W0, [W14]
419:                   if (!RN4871_Wait_For_Response(timeout))
00C18E  78001E     MOV [W14], W0
00C190  07000D     RCALL RN4871_Wait_For_Response
00C192  E00400     CP0.B W0
00C194  3A0002     BRA NZ, .L42
420:                   {
421:                       return 0; //exit if no response
00C196  EB4000     CLR.B W0
00C198  370007     BRA .L43
422:                   }
423:                   
424:                   if (RN4871_Check_Response("AOK\r\n") != 1)
00C19A  2D5250     MOV #0xD525, W0
00C19C  070021     RCALL RN4871_Check_Response
00C19E  504FE1     SUB.B W0, #0x1, [W15]
00C1A0  320002     BRA Z, .L44
425:                   {
426:                       return 0;
00C1A2  EB4000     CLR.B W0
00C1A4  370001     BRA .L43
427:                   }
428:                   
429:                   return 1;
00C1A6  B3C010     MOV.B #0x1, W0
430:               }
00C1A8  FA8000     ULNK
00C1AA  060000     RETURN
431:               
432:               /*
433:                * RN4871 Wait For Response
434:                * 
435:                * Parameters : timeout in ms
436:                * 
437:                * Waits the specified timeout while
438:                * checking the receive buffer for 
439:                * characters from RN4871
440:                * 
441:                * Returns 1 if successful, 0 on failure
442:                */
443:               uint8_t RN4871_Wait_For_Response (uint16_t timeout)
444:               {
00C1AC  FA0004     LNK #0x4
00C1AE  980710     MOV W0, [W14+2]
445:                   uint16_t timeTick = 0;
00C1B0  EB0000     CLR W0
00C1B2  780F00     MOV W0, [W14]
446:                   
447:                   if (BTH_DataAvailable == 1)
00C1B4  BFC90A     MOV.B BTH_DataAvailable, WREG
00C1B6  504FE1     SUB.B W0, #0x1, [W15]
00C1B8  3A000C     BRA NZ, .L50
448:                   {
449:                       return 1;
00C1BA  B3C010     MOV.B #0x1, W0
00C1BC  37000F     BRA .L47
450:                   }
451:                   while (BTH_DataAvailable == 0)
00C1D2  000000     NOP
00C1D4  BFC90A     MOV.B BTH_DataAvailable, WREG
00C1D6  E00400     CP0.B W0
00C1D8  32FFF2     BRA Z, .L49
452:                   {
453:                       __delay_ms(1);
00C1BE  23E800     MOV #0x3E80, W0
00C1C0  200001     MOV #0x0, W1
00C1C2  070707     RCALL ___delay32, .Letext0, .LFE18
454:                       timeTick ++;
00C1C4  E80F1E     INC [W14], [W14]
455:                       if (timeTick > timeout)
00C1C6  90001E     MOV [W14+2], W0
00C1C8  78009E     MOV [W14], W1
00C1CA  508F80     SUB W1, W0, [W15]
00C1CC  360003     BRA LEU, .L48
456:                       {
457:                           return 0;
00C1CE  EB4000     CLR.B W0
00C1D0  370005     BRA .L47
458:                       }
459:                   }
460:                   
461:                   return 1;
00C1DA  B3C010     MOV.B #0x1, W0
462:               }
00C1DC  FA8000     ULNK
00C1DE  060000     RETURN
463:               
464:               /*
465:                * RN4871 Check Response
466:                * 
467:                * Parameters: pointer to a string
468:                * 
469:                * Compares the receive buffer to the string
470:                * The entire length of the receive buffer
471:                * is compared byte to byte with the string
472:                * 
473:                * returns 1 if the bytes are the same 
474:                * and a 0 if the bytes are different
475:                */
476:               uint8_t RN4871_Check_Response(const char *msg)
477:               {
00C1E0  FA0004     LNK #0x4
00C1E2  980710     MOV W0, [W14+2]
478:                   uint16_t i = 0;
00C1E4  EB0000     CLR W0
00C1E6  780F00     MOV W0, [W14]
479:                   
480:                   for (i=0; i< BTH_Rx_DataIndex; i++)
00C1E8  EB0000     CLR W0
00C1EA  780F00     MOV W0, [W14]
00C1EC  37000D     BRA .L52
00C206  E80F1E     INC [W14], [W14]
00C208  804840     MOV BTH_Rx_DataIndex, W0
00C20A  78009E     MOV [W14], W1
00C20C  508F80     SUB W1, W0, [W15]
00C20E  39FFEF     BRA NC, .L55
481:                   {
482:                       if (msg[i] != BTH_RxData[i])
00C1EE  90001E     MOV [W14+2], W0
00C1F0  40001E     ADD W0, [W14], W0
00C1F2  784010     MOV.B [W0], W0
00C1F4  FB0080     SE W0, W1
00C1F6  21CE40     MOV #0x1CE4, W0
00C1F8  40001E     ADD W0, [W14], W0
00C1FA  784010     MOV.B [W0], W0
00C1FC  FB8000     ZE W0, W0
00C1FE  508F80     SUB W1, W0, [W15]
00C200  320002     BRA Z, .L53
483:                       {
484:                           return 0;
00C202  EB4000     CLR.B W0
00C204  370006     BRA .L54
485:                       }
486:                   }
487:                   
488:                   return 1;
00C210  B3C010     MOV.B #0x1, W0
489:               }
00C212  FA8000     ULNK
00C214  060000     RETURN
490:               
491:               uint8_t  RN4871_Reboot(void)
492:               {
00C216  FA0000     LNK #0x0
493:                   RN4871_Send_Command("R,1\r");
00C218  2D52B0     MOV #0xD52B, W0
00C21A  070034     RCALL RN4871_Send_Command
494:                   
495:                   if (RN4871_Wait_For_Response(2000) == 0)
00C21C  207D00     MOV #0x7D0, W0
00C21E  07FFC6     RCALL RN4871_Wait_For_Response
00C220  E00400     CP0.B W0
00C222  3A0002     BRA NZ, .L57
496:                   {
497:                       return 0;
00C224  EB4000     CLR.B W0
00C226  370021     BRA .L58
498:                   }
499:                   __delay_ms(1500); /* can take this long for the command prompt */
00C228  236000     MOV #0x3600, W0
00C22A  2016E1     MOV #0x16E, W1
00C22C  0706D2     RCALL ___delay32, .Letext0, .LFE18
500:                   
501:                   //Going into command mode:    
502:                   RN4871_Send_Command("$$$"); //this should return a cmd withing 10ms
00C22E  2D4700     MOV #0xD470, W0
00C230  070029     RCALL RN4871_Send_Command
503:                   __delay_ms(25);
00C232  21A800     MOV #0x1A80, W0
00C234  200061     MOV #0x6, W1
00C236  0706CD     RCALL ___delay32, .Letext0, .LFE18
504:                       
505:                   //Disabling command prompt:
506:                   RN4871_Send_Command("SR,4000\r");
00C238  2D4740     MOV #0xD474, W0
00C23A  070024     RCALL RN4871_Send_Command
507:                   if (!RN4871_Check_For_AOK(200))
00C23C  200C80     MOV #0xC8, W0
00C23E  07FFA5     RCALL RN4871_Check_For_AOK
00C240  E00400     CP0.B W0
00C242  3A0002     BRA NZ, .L59
508:                   {
509:                       return 0;
00C244  EB4000     CLR.B W0
00C246  370011     BRA .L58
510:                   }
511:                   
512:                   //clearing all previous advertisement payloads:
513:                   RN4871_Send_Command("IA,Z");
00C248  2D5300     MOV #0xD530, W0
00C24A  07001C     RCALL RN4871_Send_Command
514:                   if (!RN4871_Check_For_AOK(200))
00C24C  200C80     MOV #0xC8, W0
00C24E  07FF9D     RCALL RN4871_Check_For_AOK
00C250  E00400     CP0.B W0
00C252  3A0002     BRA NZ, .L60
515:                   {
516:                       return 0;
00C254  EB4000     CLR.B W0
00C256  370009     BRA .L58
517:                   }
518:                   
519:                   //starting Advertisements with local name
520:                   RN4871_Send_Command("A\r");
00C258  2D5170     MOV #0xD517, W0
00C25A  070014     RCALL RN4871_Send_Command
521:                   if (!RN4871_Check_For_AOK(200))
00C25C  200C80     MOV #0xC8, W0
00C25E  07FF95     RCALL RN4871_Check_For_AOK
00C260  E00400     CP0.B W0
00C262  3A0002     BRA NZ, .L61
522:                   {
523:                       return 0;
00C264  EB4000     CLR.B W0
00C266  370001     BRA .L58
524:                   }
525:                   
526:                   return 1;
00C268  B3C010     MOV.B #0x1, W0
527:               }
00C26A  FA8000     ULNK
00C26C  060000     RETURN
528:               
529:               void RN4871_Reset(void)
530:               {
00C26E  FA0000     LNK #0x0
531:                    //re-setting the module
532:                   RN4871_Reset_SetLow();
00C270  A946B2     BCLR LATE, #2
533:                   __delay_ms(1);
00C272  23E800     MOV #0x3E80, W0
00C274  200001     MOV #0x0, W1
00C276  0706AD     RCALL ___delay32, .Letext0, .LFE18
534:                   RN4871_Reset_SetHigh();
00C278  A846B2     BSET LATE, #2
535:                   __delay_ms(1000);
00C27A  224000     MOV #0x2400, W0
00C27C  200F41     MOV #0xF4, W1
00C27E  0706A9     RCALL ___delay32, .Letext0, .LFE18
536:               }
00C280  FA8000     ULNK
00C282  060000     RETURN
537:               
538:               /*
539:                * RN4871 Send Command
540:                * 
541:                * Resets the Rx buffer and sends a string out
542:                * via the UART interface
543:                */
544:               void RN4871_Send_Command (const char *msg)
545:               {
00C284  FA0002     LNK #0x2
00C286  780F00     MOV W0, [W14]
546:                   RN4871_Reset_Rx_Buffer();
00C288  07FF77     RCALL RN4871_Reset_Rx_Buffer
547:                   UART1_SendString(msg);
00C28A  78001E     MOV [W14], W0
00C28C  07FBF0     RCALL UART1_SendString
548:               }
00C28E  FA8000     ULNK
00C290  060000     RETURN
549:               
550:               /**
551:                * Set Characteristic Value
552:                * 
553:                * Uses the command SHW to update the local characteristic
554:                * 
555:                * @param handle to the private characteristic
556:                * @param data uint8_t *
557:                * @param len - number of hex bytes to be sent - this should correspond to the 
558:                *        length allocated to the data field when setting up the characteristic
559:                * @return 1 if successful, 0 on failure
560:                */
561:               uint8_t RN4871_Write_Characteristic_Value(const char *handle, uint8_t* data, int len)
562:               {
00C292  FA003A     LNK #0x3A
00C294  981F20     MOV W0, [W14+52]
00C296  981F31     MOV W1, [W14+54]
00C298  981F42     MOV W2, [W14+56]
563:                   int ii;
564:                   char tmpStr[40] = {0};
00C29A  4700E2     ADD W14, #0x2, W1
00C29C  090013     REPEAT #0x13
00C29E  EB1880     CLR [W1++]
565:                   char tmpStr2[10] = {0};
00C2A0  78008E     MOV W14, W1
00C2A2  B002A1     ADD #0x2A, W1
00C2A4  090004     REPEAT #0x4
00C2A6  EB1880     CLR [W1++]
566:                   
567:                   strcpy((char*)tmpStr,"SHW,");
00C2A8  E8800E     INC2 W14, W0
00C2AA  200052     MOV #0x5, W2
00C2AC  2D4F31     MOV #0xD4F3, W1
00C2AE  07A520     RCALL _memcpy
568:                   strcat((char*)tmpStr,(char*)handle);
00C2B0  E8800E     INC2 W14, W0
00C2B2  9018AE     MOV [W14+52], W1
00C2B4  07A5FE     RCALL _strcat
569:                   strcat((char*)tmpStr,",");
00C2B6  E8800E     INC2 W14, W0
00C2B8  07A60C     RCALL _strlen
00C2BA  E8808E     INC2 W14, W1
00C2BC  408000     ADD W1, W0, W0
00C2BE  200022     MOV #0x2, W2
00C2C0  2D4E61     MOV #0xD4E6, W1
00C2C2  07A516     RCALL _memcpy
570:                   for (ii = 0; ii < len; ii++)
00C2C4  EB0000     CLR W0
00C2C6  780F00     MOV W0, [W14]
00C2C8  370022     BRA .L65
00C30C  E80F1E     INC [W14], [W14]
00C30E  90184E     MOV [W14+56], W0
00C310  78009E     MOV [W14], W1
00C312  508F80     SUB W1, W0, [W15]
00C314  35FFDA     BRA LT, .L68
571:                   {
572:                       if (ii != len-1)
00C2CA  90184E     MOV [W14+56], W0
00C2CC  E90000     DEC W0, W0
00C2CE  500F9E     SUB W0, [W14], [W15]
00C2D0  32000D     BRA Z, .L66
573:                       {
574:                           sprintf ( (char*) tmpStr2, "%02X", data[ii]);
00C2D2  78001E     MOV [W14], W0
00C2D4  9018BE     MOV [W14+54], W1
00C2D6  408000     ADD W1, W0, W0
00C2D8  784010     MOV.B [W0], W0
00C2DA  FB8080     ZE W0, W1
00C2DC  2002A0     MOV #0x2A, W0
00C2DE  40000E     ADD W0, W14, W0
00C2E0  781F81     MOV W1, [W15++]
00C2E2  2D5351     MOV #0xD535, W1
00C2E4  781F81     MOV W1, [W15++]
00C2E6  07A925     RCALL __sprintf_cdnopuxX, __sprintf_cdnopsuxX
00C2E8  5787E4     SUB W15, #0x4, W15
00C2EA  37000C     BRA .L67
575:                       }
576:                       else
577:                       {
578:                           // last byte of data, append "\r"
579:                           sprintf ( (char*) tmpStr2, "%02X\r", data[ii]);
00C2EC  78001E     MOV [W14], W0
00C2EE  9018BE     MOV [W14+54], W1
00C2F0  408000     ADD W1, W0, W0
00C2F2  784010     MOV.B [W0], W0
00C2F4  FB8080     ZE W0, W1
00C2F6  2002A0     MOV #0x2A, W0
00C2F8  40000E     ADD W0, W14, W0
00C2FA  781F81     MOV W1, [W15++]
00C2FC  2D53A1     MOV #0xD53A, W1
00C2FE  781F81     MOV W1, [W15++]
00C300  07A918     RCALL __sprintf_cdnopuxX, __sprintf_cdnopsuxX
00C302  5787E4     SUB W15, #0x4, W15
580:                       }
581:                       strcat((char*)tmpStr, tmpStr2);     
00C304  2002A1     MOV #0x2A, W1
00C306  40808E     ADD W1, W14, W1
00C308  E8800E     INC2 W14, W0
00C30A  07A5D3     RCALL _strcat
582:                   }
583:                   RN4871_Send_Command(tmpStr);
00C316  E8800E     INC2 W14, W0
00C318  07FFB5     RCALL RN4871_Send_Command
584:                   
585:                   if (!RN4871_Check_For_AOK(300))
00C31A  2012C0     MOV #0x12C, W0
00C31C  07FF36     RCALL RN4871_Check_For_AOK
00C31E  E00400     CP0.B W0
00C320  3A0002     BRA NZ, .L69
586:                   {
587:                       return 0;
00C322  EB4000     CLR.B W0
00C324  370001     BRA .L70
588:                   }    
589:                   return 1;
00C326  B3C010     MOV.B #0x1, W0
590:               }
00C328  FA8000     ULNK
00C32A  060000     RETURN
591:               
592:               
593:               /**
594:                * Reads the characteristic value and populates the data array
595:                *      the array must be pre-allocated before this call
596:                *      The len variable provides the length of data that will be read into the buffer
597:                * @param handle
598:                * @param data
599:                * @param len
600:                * @return 
601:                *      1 on success, 0 on failure
602:                */
603:               uint8_t RN4871_Read_Characteristic_Value(const char *handle, uint8_t* data, int len)
604:               {
00C32C  FA0022     LNK #0x22
00C32E  980F50     MOV W0, [W14+26]
00C330  980F61     MOV W1, [W14+28]
00C332  980F72     MOV W2, [W14+30]
605:                   
606:                   // len is the number of bytes
607:                   // rn4871 returns hex characters, so its length will be 2*len
608:                   char tmpStr[20] = {0};
00C334  470066     ADD W14, #0x6, W0
00C336  090009     REPEAT #0x9
00C338  EB1800     CLR [W0++]
609:                   int tmpi, tmpj;
610:                   uint8_t num_tries = 0;
00C33A  EB4000     CLR.B W0
00C33C  984740     MOV.B W0, [W14+4]
611:                   bool got_data = false;
00C33E  EB4000     CLR.B W0
00C340  984750     MOV.B W0, [W14+5]
612:               
613:                   if ( (2*len + 2) > BTH_BUFFER_SIZE ) // 2 hex characters for each byte and the last 2 is for \r\n
00C342  90087E     MOV [W14+30], W0
00C344  E80000     INC W0, W0
00C346  400000     ADD W0, W0, W0
00C348  780080     MOV W0, W1
00C34A  204000     MOV #0x400, W0
00C34C  508F80     SUB W1, W0, [W15]
00C34E  340002     BRA LE, .L72
614:                   {
615:                       // insufficient memory
616:                       return 0;
00C350  EB4000     CLR.B W0
00C352  370071     BRA .L73
617:                   }
618:               
619:                   strcpy((char*)tmpStr,"SHR,");
00C354  470066     ADD W14, #0x6, W0
00C356  200052     MOV #0x5, W2
00C358  2D4FE1     MOV #0xD4FE, W1
00C35A  07A4CA     RCALL _memcpy
620:                   strcat((char*)tmpStr,(char*)handle);
00C35C  470066     ADD W14, #0x6, W0
00C35E  9008DE     MOV [W14+26], W1
00C360  07A5A8     RCALL _strcat
621:                   strcat((char*)tmpStr,"\r");
00C362  470066     ADD W14, #0x6, W0
00C364  07A5B6     RCALL _strlen
00C366  4700E6     ADD W14, #0x6, W1
00C368  408000     ADD W1, W0, W0
00C36A  200022     MOV #0x2, W2
00C36C  2D4A61     MOV #0xD4A6, W1
00C36E  07A4C0     RCALL _memcpy
622:                   while ( (num_tries < BTH_MAX_RETRIES) && (!got_data) )
00C370  370055     BRA .L74
00C41C  90404E     MOV.B [W14+4], W0
00C41E  504FE9     SUB.B W0, #0x9, [W15]
00C420  3E0004     BRA GTU, .L81
00C422  90405E     MOV.B [W14+5], W0
00C424  A20400     BTG.B W0, #0
00C426  E00400     CP0.B W0
00C428  3AFFA4     BRA NZ, .L82
623:                   {
624:                       RN4871_Send_Command(tmpStr);
00C372  470066     ADD W14, #0x6, W0
00C374  07FF87     RCALL RN4871_Send_Command
625:               
626:                       //waiting for response for 1second:
627:                       if (!RN4871_Wait_For_Response(1000))
00C376  203E80     MOV #0x3E8, W0
00C378  07FF19     RCALL RN4871_Wait_For_Response
00C37A  E00400     CP0.B W0
00C37C  3A0002     BRA NZ, .L75
628:                       {
629:                           return 0; //exit if no response
00C37E  EB4000     CLR.B W0
00C380  37005A     BRA .L73
630:                       }
631:                       // got a N/A response; try again
632:                       if (strncmp(BTH_RxData,"N/A", 3) == 0 )  
00C382  21CE40     MOV #0x1CE4, W0
00C384  200032     MOV #0x3, W2
00C386  2D5401     MOV #0xD540, W1
00C388  07A5AA     RCALL _strncmp
00C38A  E00000     CP0 W0
00C38C  3A0007     BRA NZ, .L76
633:                       {
634:                           num_tries ++;
00C38E  90404E     MOV.B [W14+4], W0
00C390  E84000     INC.B W0, W0
00C392  984740     MOV.B W0, [W14+4]
635:                           __delay_ms(BTH_SLEEP_BETWEEN_COMMANDS_MS);
00C394  212000     MOV #0x1200, W0
00C396  2007A1     MOV #0x7A, W1
00C398  07061C     RCALL ___delay32, .Letext0, .LFE18
00C39A  370040     BRA .L74
636:                       }
637:                       else if (strncmp(BTH_RxData, "ERR", 3) == 0) 
00C39C  21CE40     MOV #0x1CE4, W0
00C39E  200032     MOV #0x3, W2
00C3A0  2D5441     MOV #0xD544, W1
00C3A2  07A59D     RCALL _strncmp
00C3A4  E00000     CP0 W0
00C3A6  3A0003     BRA NZ, .L77
638:                       {
639:                           // error return immediately
640:                           num_tries = BTH_MAX_RETRIES; // allows the function to exit the while loop; got_data is still false
00C3A8  B3C0A0     MOV.B #0xA, W0
00C3AA  984740     MOV.B W0, [W14+4]
00C3AC  370037     BRA .L74
641:                       }
642:                       else 
643:                       {
644:                           if (BTH_Rx_DataIndex <= (2*len))
00C3AE  90087E     MOV [W14+30], W0
00C3B0  400000     ADD W0, W0, W0
00C3B2  780080     MOV W0, W1
00C3B4  804840     MOV BTH_Rx_DataIndex, W0
00C3B6  508F80     SUB W1, W0, [W15]
00C3B8  390003     BRA NC, .L78
645:                           {
646:                               // not sufficient data; return
647:                               num_tries = BTH_MAX_RETRIES;
00C3BA  B3C0A0     MOV.B #0xA, W0
00C3BC  984740     MOV.B W0, [W14+4]
00C3BE  37002E     BRA .L74
648:                           }
649:                           else 
650:                           {
651:                               tmpi = 0;
00C3C0  EB0000     CLR W0
00C3C2  780F00     MOV W0, [W14]
652:                               tmpj = 0;
00C3C4  EB0000     CLR W0
00C3C6  980710     MOV W0, [W14+2]
653:                               while (tmpi < 2*len)
00C3C8  370023     BRA .L79
00C410  90087E     MOV [W14+30], W0
00C412  400000     ADD W0, W0, W0
00C414  500F9E     SUB W0, [W14], [W15]
00C416  3CFFD9     BRA GT, .L80
654:                               {
655:                                   data[tmpj] = (uint8_t) ( ( ( ( BTH_RxData[tmpi] %32 ) + 9 ) % 25 ) * 16 + ( ( BTH_RxData[tmpi+1] %32 ) + 9 ) % 25 );  // convert ascii 2 characters to value
00C3CA  90001E     MOV [W14+2], W0
00C3CC  9008EE     MOV [W14+28], W1
00C3CE  408080     ADD W1, W0, W1
00C3D0  981701     MOV W1, [W14+32]
00C3D2  21CE41     MOV #0x1CE4, W1
00C3D4  40809E     ADD W1, [W14], W1
00C3D6  784091     MOV.B [W1], W1
00C3D8  FB8081     ZE W1, W1
00C3DA  6080FF     AND W1, #0x1F, W1
00C3DC  408169     ADD W1, #0x9, W2
00C3DE  200191     MOV #0x19, W1
00C3E0  780181     MOV W1, W3
00C3E2  090011     REPEAT #0x11
00C3E4  D80103     DIV.SW W2, W3
00C3E6  784101     MOV.B W1, W2
00C3E8  200041     MOV #0x4, W1
00C3EA  DD1101     SL W2, W1, W2
00C3EC  E8009E     INC [W14], W1
00C3EE  21CE43     MOV #0x1CE4, W3
00C3F0  78C0E3     MOV.B [W3+W1], W1
00C3F2  FB8081     ZE W1, W1
00C3F4  6080FF     AND W1, #0x1F, W1
00C3F6  4081E9     ADD W1, #0x9, W3
00C3F8  200191     MOV #0x19, W1
00C3FA  780201     MOV W1, W4
00C3FC  090011     REPEAT #0x11
00C3FE  D80184     DIV.SW W3, W4
00C400  784081     MOV.B W1, W1
00C402  414081     ADD.B W2, W1, W1
00C404  90100E     MOV [W14+32], W0
00C406  784801     MOV.B W1, [W0]
656:                                   tmpi += 2;
00C408  E88F1E     INC2 [W14], [W14]
657:                                   tmpj++;
00C40A  90001E     MOV [W14+2], W0
00C40C  E80000     INC W0, W0
00C40E  980710     MOV W0, [W14+2]
658:                               }
659:                               got_data = true;
00C418  B3C010     MOV.B #0x1, W0
00C41A  984750     MOV.B W0, [W14+5]
660:                           }
661:                       }
662:                   }
663:                   if (got_data)
00C42A  90405E     MOV.B [W14+5], W0
00C42C  E00400     CP0.B W0
00C42E  320002     BRA Z, .L83
664:                   {
665:                       return 1;
00C430  B3C010     MOV.B #0x1, W0
00C432  370001     BRA .L73
666:                   }
667:                   else 
668:                   {
669:                       return 0;
00C434  EB4000     CLR.B W0
670:                   }
671:                   
672:               }
00C436  FA8000     ULNK
00C438  060000     RETURN
673:               
674:               uint8_t RN4871_Get_Handles_Characteristics(const char *serviceUUID)
675:               {
00C43A  FA0034     LNK #0x34
00C43C  981F10     MOV W0, [W14+50]
676:                   char tmpStr[50] = {0};
00C43E  090018     REPEAT #0x18
00C440  EB1F00     CLR [W14++]
00C442  B1032E     SUB #0x32, W14
677:                   
678:                   //strcpy((char*)tmpStr,"LS,");
679:                   //strcat((char*)tmpStr,(char*)serviceUUID);
680:                   //strcat((char*)tmpStr,"\r");
681:                   sprintf(tmpStr, "LS,%s\r", serviceUUID);
00C444  90189E     MOV [W14+50], W1
00C446  781F81     MOV W1, [W15++]
00C448  2D5480     MOV #0xD548, W0
00C44A  781F80     MOV W0, [W15++]
00C44C  78000E     MOV W14, W0
00C44E  07A871     RCALL __sprintf_cdnopuxX, __sprintf_cdnopsuxX
00C450  5787E4     SUB W15, #0x4, W15
682:                   //sprintf(tmpStr, "LS\r", serviceUUID);
683:                   RN4871_Send_Command(tmpStr);
00C452  78000E     MOV W14, W0
00C454  07FF17     RCALL RN4871_Send_Command
684:                   
685:                   if (!RN4871_Check_For_AOK(5000))
00C456  213880     MOV #0x1388, W0
00C458  07FE98     RCALL RN4871_Check_For_AOK
00C45A  E00400     CP0.B W0
00C45C  3A0008     BRA NZ, .L85
686:                   {
687:                       //__delay_ms(250); // is this neceasary
688:                       if (!RN4871_Check_For_AOK(5000))
00C45E  213880     MOV #0x1388, W0
00C460  07FE94     RCALL RN4871_Check_For_AOK
00C462  E00400     CP0.B W0
00C464  3A0002     BRA NZ, .L86
689:                       {
690:                           return 0;
00C466  EB4000     CLR.B W0
00C468  370003     BRA .L87
691:                       }        
692:                       return 0;
00C46A  EB4000     CLR.B W0
00C46C  370001     BRA .L87
693:                   }    
694:                   return 1;
00C46E  B3C010     MOV.B #0x1, W0
695:               }
00C470  FA8000     ULNK
00C472  060000     RETURN
---  C:/Users/pvan002/Box Sync/low_income_thermostats/lita_sw/R1/HAL.c  ---------------------------------
1:                 // FSEC
2:                 #pragma config BWRP = OFF               // Boot Segment Write Protect (Boot segment may be written)
3:                 #pragma config BSS = OFF                // Boot segment Protect (No Protection (other than BWRP))
4:                 #pragma config BSEN = OFF               // Boot Segment Control bit (No Boot Segment)
5:                 #pragma config GWRP = OFF               // General Segment Write Protect (Writes to program memory are allowed)
6:                 #pragma config GSS = OFF                // General Segment Code Protect (Code protection is disabled)
7:                 #pragma config CWRP = OFF               // Configuration Segment Program Write Protection bit (Configuration Segment may be written)
8:                 #pragma config CSS = DIS                // Configuration Segment Code Protection Level bits (No Protection (other than CWRP))
9:                 #pragma config AIVTDIS = DISABLE        // Alternate Interrupt Vector Table Disable bit (Disable AIVT)
10:                
11:                // FBSLIM
12:                //#pragma config BSLIM = 0xFFFFFF         // Boot Segment Code Flash Page Address Limit bits (Enter Hexadecimal value)
13:                
14:                // FSIGN
15:                
16:                // FOSCSEL
17:                #pragma config FNOSC = FRCPLL           // Oscillator Select (Fast RC Oscillator with divide-by-n (FRCDIV))
18:                #pragma config PLLMODE = PLL4X          // Frequency Multiplier Select Bits (No PLL used; PLLEN bit is not available)
19:                #pragma config IESO = ON                // Internal External Switchover (Start up device with FRC, then switch to user-selected oscillator source)
20:                
21:                // FOSC
22:                #pragma config POSCMOD = NONE           // Primary Oscillator Select (Primary Oscillator disabled)
23:                #pragma config OSCIOFCN = ON            // OSCO Pin Configuration (OSCO/CLKO/RC15 functions as port I/O (RC15))
24:                #pragma config SOSCSEL = ON             // SOSC Power Selection Configuration bits (SOSC is used in crystal (SOSCI/SOSCO) mode)
25:                #pragma config PLLSS = PLL_PRI          // PLL Secondary Selection Configuration bit (PLL is fed by the Primary oscillator)
26:                #pragma config IOL1WAY = OFF             // IOLOCK One-Way Set Enable (The IOLOCK bit can be set and cleared using the unlock sequence)
27:                #pragma config FCKSM = CSECMD           // Clock Switching and Monitor Selection (Clock switching enabled, Fail-Safe Clock Monitor are disabled)
28:                
29:                // FWDT
30:                #pragma config WDTPS = PS1024           // Watchdog Timer Postscaler->1:1024
31:                #pragma config FWPSA = PR128            // WDT Prescaler (Prescaler ratio of 1:128)
32:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable (Watchdog Timer is disabled)
33:                #pragma config WINDIS = OFF             // Windowed Watchdog Timer Disable bit (Standard Watchdog Timer enabled (Windowed-mode is disabled))
34:                #pragma config WDTWIN = PS25_0          // Watchdog Window Select bits (Watch Dog Timer Window Width is 25 percent)
35:                #pragma config WDTCMX = WDTCLK          // WDT Clock Source Select bits (WDT clock source is determined by the WDTCLK Configuration bits)
36:                #pragma config WDTCLK = LPRC            // WDT Clock Source Select bits (WDT uses LPRC)
37:                
38:                // FPOR
39:                #pragma config BOREN = OFF               // Brown-out Reset Enable bits (Brown-out Reset Enable)
40:                #pragma config LPCFG = ON               // Low power regulator control (Enabled)
41:                
42:                // FICD
43:                #pragma config ICS = PGx1               // Emulator Pin Placement Select bits (Emulator functions are shared with PGEC1/PGED1)
44:                #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG port is disabled)
45:                #pragma config BTSWP = OFF              // BOOTSWP Instruction Enable bit (BOOTSWP instruction is disabled)
46:                
47:                // FDS
48:                #pragma config DSWDTPS = DSWDTPS1F      // Deep Sleep Watchdog Timer Postscale Select bits (1:68,719,476,736 (25.7 days))
49:                #pragma config DSWDTOSC = LPRC          // DSWDT Reference Clock Select bit (DSWDT uses Low Power RC Oscillator (LPRC))
50:                #pragma config DSBOREN = OFF             // Deep Sleep Zero-Power BOR Enable bit (Deep Sleep BOR enabled in Deep Sleep)
51:                #pragma config DSWDTEN = ON            // Deep Sleep Watchdog Timer Enable bit (DSWDT disabled)
52:                #pragma config DSSWEN = ON              // Deep Sleep Software Control Select Bit (Deep Sleep disabled)
53:                
54:                // FDEVOPT1
55:                #pragma config ALTCMPI = DISABLE        // Alternate Comparator Input Enable bit (C1INC, C2INC, and C3INC are on their standard pin locations)
56:                #pragma config TMPRPIN = OFF            // Tamper Pin Enable bit (TMPRN pin function is disabled)
57:                #pragma config TMPRWIPE = OFF           // RAM Based Entryption Key Wipe Enable bit (Cryptographic Engine Key RAM is not erased onTMPR pin events)
58:                #pragma config ALTVREF = ALTVREFDIS     // Alternate VREF location Enable (VREF is on a default pin (VREF+ on RA10 and VREF- on RA9))
59:                
60:                // FBOOT
61:                #pragma config BTMODE = SINGLE    // Boot Mode Select bits->Device is in Single Boot (legacy) mode
62:                
63:                #include <xc.h>
64:                #include <p24FJ256GB406.h>
65:                #include "hal.h"
66:                #include "RN4871.h"
67:                #include "FRAM.h"
68:                
69:                #define ERROR_HANDLER __attribute__((interrupt,no_auto_psv))
70:                #define ERROR_HANDLER_NORETURN ERROR_HANDLER __attribute__((noreturn))
71:                #define FAILSAFE_STACK_GUARDSIZE 8
72:                
73:                /**
74:                 * a private place to store the error code if we run into a severe error
75:                 */
76:                static uint16_t TRAPS_error_code = -1;
77:                
78:                //Globals INIT:
79:                uint16_t u16Timer1Tick1ms = 0;
80:                uint16_t Timer2Tick100ms = 0;
81:                uint16_t u16Timer3Tick1s = 0;
82:                uint16_t u16Timer4Tick10ms = 0;
83:                uint32_t u32Timer5Tick100us = 0;
84:                
85:                
86:                
87:                /*******************************************************************************
88:                *                   UART1 [Bluetooth] INTERRUPT
89:                *******************************************************************************/
90:                void __attribute__((interrupt, no_auto_psv)) _U1RXInterrupt(void)
91:                {
00021C  BE9F80     MOV.D W0, [W15++]
00021E  781F82     MOV W2, [W15++]
000220  FA0000     LNK #0x0
92:                     BTH_RxData[BTH_Rx_DataIndex] = U1RXREG;
000222  804840     MOV BTH_Rx_DataIndex, W0
000224  801CF1     MOV U1RXREG, W1
000226  784101     MOV.B W1, W2
000228  21CE41     MOV #0x1CE4, W1
00022A  787082     MOV.B W2, [W1+W0]
93:                    
94:                    if (BTH_RxData[BTH_Rx_DataIndex] == 10) //we have a line feed:
00022C  804840     MOV BTH_Rx_DataIndex, W0
00022E  21CE41     MOV #0x1CE4, W1
000230  784061     MOV.B [W1+W0], W0
000232  504FEA     SUB.B W0, #0xA, [W15]
000234  3A0002     BRA NZ, .L2
95:                    {
96:                        BTH_DataAvailable = 1;
000236  B3C010     MOV.B #0x1, W0
000238  B7E90A     MOV.B WREG, BTH_DataAvailable
97:                    }
98:                    
99:                    BTH_Rx_DataIndex++;
00023A  804840     MOV BTH_Rx_DataIndex, W0
00023C  E80000     INC W0, W0
00023E  884840     MOV W0, BTH_Rx_DataIndex
100:                   IFS0bits.U1RXIF = 0; //clearing U4 - bluetooth interrupt
000240  A96089     BCLR 0x89, #3
101:               
102:               }
000242  FA8000     ULNK
000244  78014F     MOV [--W15], W2
000246  BE004F     MOV.D [--W15], W0
000248  064000     RETFIE
103:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _U1ErrInterrupt ( void )
104:               {
00024A  781F80     MOV W0, [W15++]
00024C  FA0000     LNK #0x0
105:                   if ((U1STAbits.OERR == 1)) //just in case we get an overruun error - we do want
00024E  801CD0     MOV U1STA, W0
000250  600062     AND W0, #0x2, W0
000252  E00000     CP0 W0
000254  320001     BRA Z, .L4
106:                   {                          //to clear it up and keep going..
107:                       U1STAbits.OERR = 0;
000256  A9239A     BCLR U1STA, #1
108:                   }
109:               
110:                   IFS4bits.U1ERIF = false;
000258  A92090     BCLR IFS4, #1
111:               }
00025A  FA8000     ULNK
00025C  78004F     MOV [--W15], W0
00025E  064000     RETFIE
112:               
113:               /*******************************************************************************
114:                                       UART2 LoRa INTERRUPT
115:               *******************************************************************************/
116:               
117:               void __attribute__((interrupt, no_auto_psv)) _U2RXInterrupt(void)
118:               {
000260  FA0000     LNK #0x0
119:                  //TODO: code for LoRa reception
120:                   IFS1bits.U2RXIF = 0; //clearing UART2  interrupt    
000262  A9C08B     BCLR 0x8B, #6
121:               }
000264  FA8000     ULNK
000266  064000     RETFIE
122:               
123:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _U2ErrInterrupt ( void )
124:               {
000268  781F80     MOV W0, [W15++]
00026A  FA0000     LNK #0x0
125:                   if ((U2STAbits.OERR == 1)) //just in case we get an overruun error - wewant
00026C  801D80     MOV U2STA, W0
00026E  600062     AND W0, #0x2, W0
000270  E00000     CP0 W0
000272  320001     BRA Z, .L7
126:                   {                          //to clear it up and keep going..
127:                       U2STAbits.OERR = 0;
000274  A923B0     BCLR U2STA, #1
128:                   }
129:               
130:                   IFS4bits.U2ERIF = false;
000276  A94090     BCLR IFS4, #2
131:               }
000278  FA8000     ULNK
00027A  78004F     MOV [--W15], W0
00027C  064000     RETFIE
132:               
133:               /*******************************************************************************
134:                                   UART3 DiGi WiFi INTERRUPT
135:               *******************************************************************************/
136:               
137:               void __attribute__((interrupt, no_auto_psv)) _U3RXInterrupt(void)
138:               {
00027E  FA0000     LNK #0x0
139:                   //TODO: code for WiFi reception
140:                   IFS5bits.U3RXIF = 0; //clearing  UART3 interrupt
000280  A94092     BCLR IFS5, #2
141:               }
000282  FA8000     ULNK
000284  064000     RETFIE
142:               
143:               /*******************************************************************************
144:                                   INT0: Timer button  INTERRUPT
145:               *******************************************************************************/
146:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _INT0Interrupt(void)
147:               {
000286  781F80     MOV W0, [W15++]
000288  FA0000     LNK #0x0
148:                   bTimerButtonPressed = true;
00028A  B3C010     MOV.B #0x1, W0
00028C  B7E8AA     MOV.B WREG, bTimerButtonPressed
149:                   TimerButton_InterruptFlagClear();
00028E  A90088     BCLR IFS0, #0
150:               }
000290  FA8000     ULNK
000292  78004F     MOV [--W15], W0
000294  064000     RETFIE
151:               /*******************************************************************************
152:                                   INT1: Down button  INTERRUPT
153:               *******************************************************************************/
154:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _INT1Interrupt(void)
155:               {
000296  781F80     MOV W0, [W15++]
000298  FA0000     LNK #0x0
156:                  bDownButtonPressed = true; 
00029A  B3C010     MOV.B #0x1, W0
00029C  B7E8AC     MOV.B WREG, bDownButtonPressed
157:                  DownButton_InterruptFlagClear();
00029E  A9808A     BCLR IFS1, #4
158:               }
0002A0  FA8000     ULNK
0002A2  78004F     MOV [--W15], W0
0002A4  064000     RETFIE
159:               /*******************************************************************************
160:                                   INT2: Up button  INTERRUPT
161:               *******************************************************************************/
162:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _INT2Interrupt(void)
163:               {
0002A6  781F80     MOV W0, [W15++]
0002A8  FA0000     LNK #0x0
164:                   bUpButtonPressed = true;
0002AA  B3C010     MOV.B #0x1, W0
0002AC  B7E8AB     MOV.B WREG, bUpButtonPressed
165:                   UpButton_InterruptFlagClear();
0002AE  A9A08B     BCLR 0x8B, #5
166:               }
0002B0  FA8000     ULNK
0002B2  78004F     MOV [--W15], W0
0002B4  064000     RETFIE
167:               /*******************************************************************************
168:                                   INT3: Power button  INTERRUPT
169:               *******************************************************************************/
170:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _INT3Interrupt(void)
171:               {
0002B6  781F80     MOV W0, [W15++]
0002B8  FA0000     LNK #0x0
172:                   bPowerButtonPressed = true;
0002BA  B3C010     MOV.B #0x1, W0
0002BC  B7E8AD     MOV.B WREG, bPowerButtonPressed
173:                   PowerButton_InterruptFlagClear();
0002BE  A9A08E     BCLR IFS3, #5
174:               }
0002C0  FA8000     ULNK
0002C2  78004F     MOV [--W15], W0
0002C4  064000     RETFIE
175:               
176:               /*******************************************************************************
177:                                   INT4: BLuetooth connected interrupt
178:               *******************************************************************************/
179:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _INT4Interrupt(void)
180:               {
0002C6  BE9F80     MOV.D W0, [W15++]
0002C8  FA0000     LNK #0x0
181:                   if (RN4871_Status1 == 0) //Bluetooth connection established
0002CA  8033A1     MOV PORTB, W1
0002CC  200200     MOV #0x20, W0
0002CE  608000     AND W1, W0, W0
0002D0  E00000     CP0 W0
0002D2  3A0007     BRA NZ, .L14
182:                   {
183:                       BLE_Connected = true;
0002D4  B3C010     MOV.B #0x1, W0
0002D6  B7E90B     MOV.B WREG, BLE_Connected
184:                       BLEStatus_PositiveEdgeSet(); //set to trigger when phone is disconnected. 
0002D8  A98082     BCLR INTCON2, #4
185:                        //Waking up BLE UART function:
186:                       RN4871_Wake_SetLow();        
0002DA  A9C677     BCLR 0x677, #6
187:                       u8CurrentState = STATE_CONNECT;
0002DC  B3C010     MOV.B #0x1, W0
0002DE  B7E8B0     MOV.B WREG, u8CurrentState
0002E0  370002     BRA .L15
188:                   }
189:                   else
190:                   {
191:                       BLE_Connected = false;
0002E2  EF690B     CLR.B BLE_Connected
192:                       BLEStatus_NegativeEdgeSet(); //goes low when phone is connected
0002E4  A88082     BSET INTCON2, #4
193:                   }
194:                   
195:                   BLEStatus_InterruptFlagclear();
0002E6  A9C08E     BCLR IFS3, #6
196:               }
0002E8  FA8000     ULNK
0002EA  BE004F     MOV.D [--W15], W0
0002EC  064000     RETFIE
197:               
198:               
199:               /*******************************************************************************
200:                                   RTCC Alarm interrupt
201:               *******************************************************************************/
202:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _ISR _RTCCInterrupt( void )
203:               {
0002EE  BE9F80     MOV.D W0, [W15++]
0002F0  FA0000     LNK #0x0
204:                   if (RTCSTATLbits.ALMEVT == 1) //i.e this is an alarm event
0002F2  800EC1     MOV RTCSTATL, W1
0002F4  200200     MOV #0x20, W0
0002F6  608000     AND W1, W0, W0
0002F8  E00000     CP0 W0
0002FA  320003     BRA Z, .L17
205:                   {
206:                       RTCCAlarmOn = true;
0002FC  B3C010     MOV.B #0x1, W0
0002FE  B7E8AF     MOV.B WREG, RTCCAlarmOn
207:                       RTCSTATLbits.ALMEVT = 0;
000300  A9A1D8     BCLR RTCSTATL, #5
208:                   }    
209:                   IFS3bits.RTCIF = false;
000302  A9C08F     BCLR 0x8F, #6
210:                   u8CurrentState = STATE_ACTIVE;
000304  B3C020     MOV.B #0x2, W0
000306  B7E8B0     MOV.B WREG, u8CurrentState
211:               }
000308  FA8000     ULNK
00030A  BE004F     MOV.D [--W15], W0
00030C  064000     RETFIE
212:               
213:               /*******************************************************************************
214:                                     1 ms TIMER1 INTERRUPT 
215:               *******************************************************************************/
216:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _T1Interrupt (  )
217:               {
00030E  781F80     MOV W0, [W15++]
000310  FA0000     LNK #0x0
218:                   /* Check if the Timer Interrupt/Status is set */
219:                   
220:                   u16Timer1Tick1ms++;
000312  804730     MOV u16Timer1Tick1ms, W0
000314  E80000     INC W0, W0
000316  884730     MOV W0, u16Timer1Tick1ms
221:                   IFS0bits.T1IF = false;
000318  A96088     BCLR IFS0, #3
222:               }
00031A  FA8000     ULNK
00031C  78004F     MOV [--W15], W0
00031E  064000     RETFIE
223:               
224:               /*******************************************************************************
225:                                     100 ms TIMER2 INTERRUPT 
226:               *******************************************************************************/
227:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _T2Interrupt (  )
228:               {
000320  781F80     MOV W0, [W15++]
000322  FA0000     LNK #0x0
229:                   Timer2Tick100ms++;
000324  804740     MOV Timer2Tick100ms, W0
000326  E80000     INC W0, W0
000328  884740     MOV W0, Timer2Tick100ms
230:                   IFS0bits.T2IF = false;
00032A  A9E088     BCLR IFS0, #7
231:               }
00032C  FA8000     ULNK
00032E  78004F     MOV [--W15], W0
000330  064000     RETFIE
232:               
233:               /*******************************************************************************
234:                                     1000 ms TIMER3 INTERRUPT
235:               *******************************************************************************/
236:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _T3Interrupt (  )
237:               {
000332  781F80     MOV W0, [W15++]
000334  FA0000     LNK #0x0
238:                   u16Timer3Tick1s++;
000336  804750     MOV u16Timer3Tick1s, W0
000338  E80000     INC W0, W0
00033A  884750     MOV W0, u16Timer3Tick1s
239:                   IFS0bits.T3IF = false;
00033C  A90089     BCLR 0x89, #0
240:               
241:               }
00033E  FA8000     ULNK
000340  78004F     MOV [--W15], W0
000342  064000     RETFIE
242:               
243:               /*******************************************************************************
244:                                     10 ms TIMER4 INTERRUPT
245:               ******************************************************************************/
246:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _T4Interrupt (  )
247:               {
000344  781F80     MOV W0, [W15++]
000346  FA0000     LNK #0x0
248:                   u16Timer4Tick10ms++;
000348  804760     MOV u16Timer4Tick10ms, W0
00034A  E80000     INC W0, W0
00034C  884760     MOV W0, u16Timer4Tick10ms
249:                   IFS1bits.T4IF = false;
00034E  A9608B     BCLR 0x8B, #3
250:               }
000350  FA8000     ULNK
000352  78004F     MOV [--W15], W0
000354  064000     RETFIE
251:               /*******************************************************************************
252:                                     100 us TIMER5 INTERRUPT
253:               *******************************************************************************/
254:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _T5Interrupt (  )
255:               {
000356  BE9F80     MOV.D W0, [W15++]
000358  FA0000     LNK #0x0
256:                   u32Timer5Tick100us++;
00035A  804770     MOV u32Timer5Tick100us, W0
00035C  804781     MOV ___udivdi3, W1
00035E  400061     ADD W0, #0x1, W0
000360  4880E0     ADDC W1, #0x0, W1
000362  884770     MOV W0, u32Timer5Tick100us
000364  884781     MOV W1, ___udivdi3
257:                   IFS1bits.T5IF = false;
000366  A9808B     BCLR 0x8B, #4
258:               }
000368  FA8000     ULNK
00036A  BE004F     MOV.D [--W15], W0
00036C  064000     RETFIE
259:               
260:               /*******************************************************************************
261:                                   EXCEPTIONS :
262:               *******************************************************************************/
263:               void __attribute__((naked, noreturn, weak)) TRAPS_halt_on_error(uint16_t code)
264:               {
00B5C2  780F00     MOV W0, [W14]
265:                   TRAPS_error_code = code;
00B5C4  78009E     MOV [W14], W1
00B5C6  884141     MOV W1, 0x828
00B5C8  DA4000     BREAK
266:               #ifdef __DEBUG    
267:                   __builtin_software_breakpoint();
268:                   /* If we are in debug mode, cause a software breakpoint in the debugger */
269:               #endif
270:                   asm ("RESET");
00B5CA  FE0000     RESET
271:                   while(1);
00B5CC  37FFFF     BRA .L24
272:                   
273:               }
274:               
275:               /**
276:                * Sets the stack pointer to a backup area of memory, in case we run into
277:                * a stack error (in which case we can't really trust the stack pointer)
278:                */
279:               inline static void use_failsafe_stack(void)
280:               {
00B5CE  FA0000     LNK #0x0
281:                   static uint8_t failsafe_stack[32];
282:                   asm volatile (
00B5D0  225F40     MOV #0x25F4, W0
00B5D2  780780     MOV W0, W15
283:                       "   mov    %[pstack], W15\n"
284:                       :
285:                       : [pstack]"r"(failsafe_stack)
286:                   );
287:               /* Controls where the stack pointer limit is, relative to the end of the
288:                * failsafe stack
289:                */    
290:                   SPLIM = (uint16_t)(((uint8_t *)failsafe_stack) + sizeof(failsafe_stack) 
00B5D4  2260C0     MOV #0x260C, W0
00B5D6  880100     MOV W0, SPLIM
291:                           - FAILSAFE_STACK_GUARDSIZE);
292:               }
00B5D8  FA8000     ULNK
00B5DA  060000     RETURN
293:               /** Oscillator Fail Trap vector**/
294:               void ERROR_HANDLER_NORETURN _OscillatorFail(void)
295:               {
00036E  F80036     PUSH RCOUNT
296:                   INTCON1bits.OSCFAIL = 0;  //Clear the trap flag
000370  A92080     BCLR INTCON1, #1
297:                   TRAPS_halt_on_error(TRAPS_OSC_FAIL);
000372  EB0000     CLR W0
000374  075926     RCALL TRAPS_halt_on_error
298:               }
299:               /** Stack Error Trap Vector**/
300:               void ERROR_HANDLER_NORETURN _StackError(void)
301:               {
000376  F80036     PUSH RCOUNT
302:                   /* We use a failsafe stack: the presence of a stack-pointer error
303:                    * means that we cannot trust the stack to operate correctly unless
304:                    * we set the stack pointer to a safe place.
305:                    */
306:                   use_failsafe_stack(); 
000378  07592A     RCALL use_failsafe_stack
307:                   INTCON1bits.STKERR = 0;  //Clear the trap flag
00037A  A94080     BCLR INTCON1, #2
308:                   TRAPS_halt_on_error(TRAPS_STACK_ERR);
00037C  200010     MOV #0x1, W0
00037E  075921     RCALL TRAPS_halt_on_error
309:               }
310:               /** Address Error Trap Vector**/
311:               void ERROR_HANDLER_NORETURN _AddressError(void)
312:               {
000380  F80036     PUSH RCOUNT
313:                   INTCON1bits.ADDRERR = 0;  //Clear the trap flag
000382  A96080     BCLR INTCON1, #3
314:                   TRAPS_halt_on_error(TRAPS_ADDRESS_ERR);
000384  200020     MOV #0x2, W0
000386  07591D     RCALL TRAPS_halt_on_error
315:               }
316:               /** Math Error Trap Vector**/
317:               void ERROR_HANDLER_NORETURN _MathError(void)
318:               {
000388  F80036     PUSH RCOUNT
319:                   INTCON1bits.MATHERR = 0;  //Clear the trap flag
00038A  A98080     BCLR INTCON1, #4
320:                   TRAPS_halt_on_error(TRAPS_MATH_ERR);
00038C  200030     MOV #0x3, W0
00038E  075919     RCALL TRAPS_halt_on_error
321:               }
322:               
323:               void OSCILLATOR_Initialize(void)
324:               {
00B5DC  FA0000     LNK #0x0
325:                   // CF no clock failure; NOSC FRC; SOSCEN enabled; POSCEN disabled;
326:                   // CLKLOCK unlocked; OSWEN Switch is Complete; IOLOCK not-active; 
327:                   __builtin_write_OSCCONL((uint8_t) (0x0002 & 0x00FF));
00B5DE  200022     MOV #0x2, W2
00B5E0  200460     MOV #0x46, W0
00B5E2  200571     MOV #0x57, W1
00B5E4  201003     MOV #0x100, W3
00B5E6  784980     MOV.B W0, [W3]
00B5E8  784981     MOV.B W1, [W3]
00B5EA  784982     MOV.B W2, [W3]
328:                   // CPDIV 1:1; PLLEN disabled; RCDIV FRC/1; DOZE 1:8; DOZEN disabled; ROI disabled; 
329:                   CLKDIV = 0x3000;
00B5EC  230000     MOV #0x3000, W0
00B5EE  880810     MOV W0, CLKDIV
330:                   // STOR disabled; STORPOL Interrupt when STOR is 1; STSIDL disabled; 
331:                   // STLPOL Interrupt when STLOCK is 1; STLOCK disabled; STSRC SOSC; 
332:                   // STEN enabled; TUN Center frequency; 
333:                   OSCTUN = 0x8000;
00B5F0  280000     MOV #0x8000, W0
00B5F2  880830     MOV W0, OSCTUN
334:                   // ROEN disabled; ROSEL FOSC; ROSIDL disabled; ROSWEN disabled; ROOUT disabled; ROSLP disabled; 
335:                   REFOCONL = 0x0000;
00B5F4  EF2168     CLR REFOCONL
336:                   // RODIV 0; 
337:                   REFOCONH = 0x0000;
00B5F6  EF216A     CLR REFOCONH
338:                   // ROTRIM 0; 
339:                   REFOTRIML = 0x0000;
00B5F8  EF216C     CLR REFOTRIML
340:               }
00B5FA  FA8000     ULNK
00B5FC  060000     RETURN
341:               
342:               void PIN_MANAGER_Initialize(void)
343:               {
00B5FE  FA0000     LNK #0x0
344:                   /****************************************************************************
345:                    *   Output Latch SFR(s)
346:                    ***************************************************************************/
347:                   //**** OUTPUTS LATCHES NOW CONTROLLED BY POWER ENABLE MACROS IN HAL.H
348:                   LATB = 0x0000;//0x5000; //WiFi_DTR, Bluetooth_Wake  HIGH
00B600  EF2676     CLR LATB
349:                   LATC = 0x0000;
00B602  EF268A     CLR LATC
350:                   LATD = 0x0000; 
00B604  EF269E     CLR LATD
351:                   LATE = 0x0000;//0x007F; //CS and Reset lines high at startup
00B606  EF26B2     CLR LATE
352:                   LATF = 0x0000;//0x0028; //WiFiTx,LoRaTx high 
00B608  EF26C6     CLR LATF
353:                   LATG = 0x0000;//0x0040; //Bluetooth_TX  high
00B60A  EF26DA     CLR LATG
354:                   
355:                   
356:                   TRISB = 0x2C6B;  //24VAC_good, Bluetooth_stat1, MISO, T1ADC, T2ADC, VDCIN are inputs
00B60C  22C6B0     MOV #0x2C6B, W0
00B60E  883390     MOV W0, TRISB
357:                   TRISC = 0x0000; // All outputs
00B610  EF2686     CLR TRISC
358:                   TRISD = 0x0C23; //INT0, Bluetooth_CTS, Bluetooth_Rx, INT3, INT1 are  inputs
00B612  20C230     MOV #0xC23, W0
00B614  8834D0     MOV W0, TRISD
359:                   TRISE = 0x0000; // All outputs
00B616  EF26AE     CLR TRISE
360:                   TRISF = 0x0011; // BSY_Epaper, INT2, are inputs
00B618  200110     MOV #0x11, W0
00B61A  883610     MOV W0, TRISF
361:                   TRISG = 0x0380; // LoRa_Rx, WiFi_Rx, WiFi_CTS are inputs
00B61C  203800     MOV #0x380, W0
00B61E  8836B0     MOV W0, TRISG
362:                   
363:                   /****************************************************************************
364:                    * Analog/Digital Configuration SFR
365:                    ***************************************************************************/
366:                   ANSA = 0x0000;
00B620  EF2666     CLR ANSA
367:                   ANSB = 0x2C00;
00B622  22C000     MOV #0x2C00, W0
00B624  8833D0     MOV W0, ANSB
368:                   ANSC = 0x0000;
00B626  EF268E     CLR ANSC
369:                   ANSD = 0x0000;
00B628  EF26A2     CLR ANSD
370:                   ANSE = 0x0000;
00B62A  EF26B6     CLR ANSE
371:                   ANSF = 0x0000;
00B62C  EF26CA     CLR ANSF
372:                   ANSG = 0x0000;
00B62E  EF26DE     CLR ANSG
373:                   ANSH = 0x0000;
00B630  EF26F2     CLR ANSH
374:               
375:                   /****************************************************************************
376:                    * Weak Pull Up and Weak Pull Down SFR(s)
377:                    ***************************************************************************/
378:                   IOCPDA = 0x0000;
00B632  EF2670     CLR IOCPDA
379:                   IOCPDB = 0x008;//24VACgood pull down
00B634  200080     MOV #0x8, W0
00B636  883420     MOV W0, IOCPDB
380:                   IOCPDC = 0x0000;
00B638  EF2698     CLR IOCPDC
381:                   IOCPDD = 0x0000; //0x01D8;//heat_reset, cool_set, cool_reset, fan_set, fan_reset pull down
00B63A  EF26AC     CLR IOCPDD
382:                   IOCPDE = 0x0000; //0x0020;
00B63C  EF26C0     CLR IOCPDE
383:                   IOCPDF = 0x0000; //0x0080;
00B63E  EF26D4     CLR IOCPDF
384:                   IOCPDG = 0x0000; //0x000C;
00B640  EF26E8     CLR IOCPDG
385:                   IOCPDH = 0x0000;
00B642  EF26FC     CLR IOCPDH
386:                   IOCPDJ = 0x0000;
00B644  EF2710     CLR IOCPDJ
387:                   IOCPUA = 0x0000;
00B646  EF266E     CLR IOCPUA
388:                   IOCPUB = 0x0000;
00B648  EF2682     CLR IOCPUB
389:                   IOCPUC = 0x0000;
00B64A  EF2696     CLR IOCPUC
390:                   IOCPUD = 0x0000;
00B64C  EF26AA     CLR IOCPUD
391:                   IOCPUE = 0x0000;//0x0051; //rst_epaper, CS_mem, CS_BME pulled up
00B64E  EF26BE     CLR IOCPUE
392:                   IOCPUF = 0x0000;
00B650  EF26D2     CLR IOCPUF
393:                   IOCPUG = 0x0000;
00B652  EF26E6     CLR IOCPUG
394:                   IOCPUH = 0x0000;
00B654  EF26FA     CLR IOCPUH
395:                   IOCPUJ = 0x0000;
00B656  EF270E     CLR IOCPUJ
396:               
397:                   /****************************************************************************
398:                    * Open Drain SFR(s)
399:                    ***************************************************************************/
400:                   ODCA = 0x0000;
00B658  EF2664     CLR ODCA
401:                   ODCB = 0x0000;
00B65A  EF2678     CLR ODCB
402:                   ODCC = 0x0000;
00B65C  EF268C     CLR ODCC
403:                   ODCD = 0x0000;
00B65E  EF26A0     CLR ODCD
404:                   ODCE = 0x0000;
00B660  EF26B4     CLR ODCE
405:                   ODCF = 0x0000;
00B662  EF26C8     CLR ODCF
406:                   ODCG = 0x0000;
00B664  EF26DC     CLR ODCG
407:                   ODCH = 0x0000;
00B666  EF26F0     CLR ODCH
408:                   ODCJ = 0x0000;
00B668  EF2704     CLR ODCJ
409:                   
410:                   /****************************************************************************
411:                    * Setting the PPS
412:                    ***************************************************************************/
413:                   __builtin_write_OSCCONL(OSCCON & 0xbf); // unlock PPS
00B66A  800801     MOV OSCCON, W1
00B66C  200BF0     MOV #0xBF, W0
00B66E  608100     AND W1, W0, W2
00B670  200460     MOV #0x46, W0
00B672  200571     MOV #0x57, W1
00B674  201003     MOV #0x100, W3
00B676  784980     MOV.B W0, [W3]
00B678  784981     MOV.B W1, [W3]
00B67A  784982     MOV.B W2, [W3]
414:                   
415:                   RPINR0bits.INT1R = 0x000C;   //RD11->EXT_INT:INT1;
00B67C  803C81     MOV RPINR0, W1
00B67E  2C0FF0     MOV #0xC0FF, W0
00B680  608080     AND W1, W0, W1
00B682  20C000     MOV #0xC00, W0
00B684  700001     IOR W0, W1, W0
00B686  883C80     MOV W0, RPINR0
416:                   RPOR8bits.RP16R = 0x0013;   //RF3->UART3:U3TX;
00B688  803F21     MOV RPOR8, W1
00B68A  2FFC00     MOV #0xFFC0, W0
00B68C  608000     AND W1, W0, W0
00B68E  B30130     IOR #0x13, W0
00B690  883F20     MOV W0, RPOR8
417:                   RPOR8bits.RP17R = 0x0005;   //RF5->UART2:U2TX;
00B692  803F21     MOV RPOR8, W1
00B694  2C0FF0     MOV #0xC0FF, W0
00B696  608080     AND W1, W0, W1
00B698  205000     MOV #0x500, W0
00B69A  700001     IOR W0, W1, W0
00B69C  883F20     MOV W0, RPOR8
418:                   RPINR1bits.INT3R = 0x0003;   //RD10->EXT_INT:INT3;
00B69E  803C91     MOV RPINR1, W1
00B6A0  2C0FF0     MOV #0xC0FF, W0
00B6A2  608080     AND W1, W0, W1
00B6A4  203000     MOV #0x300, W0
00B6A6  700001     IOR W0, W1, W0
00B6A8  883C90     MOV W0, RPINR1
419:                   RPINR1bits.INT2R = 0x000A;   //RF4->EXT_INT:INT2;
00B6AA  803C91     MOV RPINR1, W1
00B6AC  2FFC00     MOV #0xFFC0, W0
00B6AE  608000     AND W1, W0, W0
00B6B0  B300A0     IOR #0xA, W0
00B6B2  883C90     MOV W0, RPINR1
420:                   RPOR11bits.RP23R = 0x0004;   //RD2->UART1:U1RTS;
00B6B4  803F51     MOV RPOR11, W1
00B6B6  2C0FF0     MOV #0xC0FF, W0
00B6B8  608000     AND W1, W0, W0
00B6BA  A0A000     BSET W0, #10
00B6BC  883F50     MOV W0, RPOR11
421:                   RPOR4bits.RP8R = 0x0008;   //RB8->SPI1:SCK1OUT;
00B6BE  803EE1     MOV RPOR4, W1
00B6C0  2FFC00     MOV #0xFFC0, W0
00B6C2  608000     AND W1, W0, W0
00B6C4  A03000     BSET W0, #3
00B6C6  883EE0     MOV W0, RPOR4
422:                   RPOR10bits.RP21R = 0x0003;   //RG6->UART1:U1TX;
00B6C8  803F41     MOV RPOR10, W1
00B6CA  2C0FF0     MOV #0xC0FF, W0
00B6CC  608080     AND W1, W0, W1
00B6CE  203000     MOV #0x300, W0
00B6D0  700001     IOR W0, W1, W0
00B6D2  883F40     MOV W0, RPOR10
423:                   RPINR19bits.U2RXR = 0x001A;   //RG7->UART2:U2RX;
00B6D4  803DB1     MOV RPINR19, W1
00B6D6  2FFC00     MOV #0xFFC0, W0
00B6D8  608000     AND W1, W0, W0
00B6DA  B301A0     IOR #0x1A, W0
00B6DC  883DB0     MOV W0, RPINR19
424:                   RPINR18bits.U1CTSR = 0x0018;   //RD1->UART1:U1CTS;
00B6DE  803DA1     MOV RPINR18, W1
00B6E0  2C0FF0     MOV #0xC0FF, W0
00B6E2  608080     AND W1, W0, W1
00B6E4  218000     MOV #0x1800, W0
00B6E6  700001     IOR W0, W1, W0
00B6E8  883DA0     MOV W0, RPINR18
425:                   RPOR3bits.RP7R = 0x0007;   //RB7->SPI1:SDO1;
00B6EA  803ED1     MOV RPOR3, W1
00B6EC  2C0FF0     MOV #0xC0FF, W0
00B6EE  608080     AND W1, W0, W1
00B6F0  207000     MOV #0x700, W0
00B6F2  700001     IOR W0, W1, W0
00B6F4  883ED0     MOV W0, RPOR3
426:                   RPINR18bits.U1RXR = 0x0014;   //RD5->UART1:U1RX;
00B6F6  803DA1     MOV RPINR18, W1
00B6F8  2FFC00     MOV #0xFFC0, W0
00B6FA  608000     AND W1, W0, W0
00B6FC  B30140     IOR #0x14, W0
00B6FE  883DA0     MOV W0, RPINR18
427:                   RPINR2bits.INT4R = 0x0012;   //RB5->EXT_INT:INT4;
00B700  803CA1     MOV RPINR2, W1
00B702  2FFC00     MOV #0xFFC0, W0
00B704  608000     AND W1, W0, W0
00B706  B30120     IOR #0x12, W0
00B708  883CA0     MOV W0, RPINR2
428:                   RPINR21bits.U3CTSR = 0x001B;   //RG9->UART3:U3CTS;
00B70A  803DD1     MOV RPINR21, W1
00B70C  2C0FF0     MOV #0xC0FF, W0
00B70E  608080     AND W1, W0, W1
00B710  21B000     MOV #0x1B00, W0
00B712  700001     IOR W0, W1, W0
00B714  883DD0     MOV W0, RPINR21
429:                   RPINR17bits.U3RXR = 0x0013;   //RG8->UART3:U3RX;
00B716  803D91     MOV RPINR17, W1
00B718  2C0FF0     MOV #0xC0FF, W0
00B71A  608080     AND W1, W0, W1
00B71C  213000     MOV #0x1300, W0
00B71E  700001     IOR W0, W1, W0
00B720  883D90     MOV W0, RPINR17
430:                   RPINR20bits.SDI1R = 0x0006;   //RB6->SPI1:SDI1;
00B722  803DC1     MOV RPINR20, W1
00B724  2FFC00     MOV #0xFFC0, W0
00B726  608000     AND W1, W0, W0
00B728  B30060     IOR #0x6, W0
00B72A  883DC0     MOV W0, RPINR20
431:               
432:                   __builtin_write_OSCCONL(OSCCON | 0x40); // lock   PPS
00B72C  800800     MOV OSCCON, W0
00B72E  780100     MOV W0, W2
00B730  A06002     BSET W2, #6
00B732  200460     MOV #0x46, W0
00B734  200571     MOV #0x57, W1
00B736  201003     MOV #0x100, W3
00B738  784980     MOV.B W0, [W3]
00B73A  784981     MOV.B W1, [W3]
00B73C  784982     MOV.B W2, [W3]
433:                   
434:                   
435:                   //Enabling low power regulator during sleep : saves about 5uA
436:                   RCONbits.RETEN = 1;
00B73E  A8810D     BSET 0x10D, #4
437:                   
438:                   //Disabling all peripherals by default. Will be enabling needed ones manually
439:                   PMD1 = 0xFFFF;
00B740  EB8000     SETM W0
00B742  880BC0     MOV W0, PMD1
440:                   PMD2 = 0xFFFF;
00B744  EB8000     SETM W0
00B746  880BD0     MOV W0, PMD2
441:                   PMD3 = 0xFFFF;
00B748  EB8000     SETM W0
00B74A  880BE0     MOV W0, PMD3
442:                   PMD4 = 0xFFFF;
00B74C  EB8000     SETM W0
00B74E  880BF0     MOV W0, PMD4
443:                   PMD5 = 0xFFFF;
00B750  EB8000     SETM W0
00B752  880C00     MOV W0, PMD5
444:                   PMD6 = 0xFFFF;
00B754  EB8000     SETM W0
00B756  880C10     MOV W0, PMD6
445:                   PMD7 = 0xFFFF;
00B758  EB8000     SETM W0
00B75A  880C20     MOV W0, PMD7
446:                   PMD8 = 0xFFFF;
00B75C  EB8000     SETM W0
00B75E  880C30     MOV W0, PMD8
447:                   
448:                   //enabling just UART1, ADC and SPI1:
449:                   PMD1bits.U1MD = 0; //UART1
00B760  A9A178     BCLR PMD1, #5
450:                   PMD1bits.ADC1MD = 0; //ADC
00B762  A90178     BCLR PMD1, #0
451:                   PMD1bits.SPI1MD = 0; //SPI1
00B764  A96178     BCLR PMD1, #3
452:                   //TODO: enable peripherals needed here:
453:                   //PMD1bits.U2MD = 0; //UART2 : LoRA
454:                   //PMD3bits.U3MD = 0; //UART3 : WiFi
455:                   
456:               }
00B766  FA8000     ULNK
00B768  060000     RETURN
457:               
458:               void INTERRUPT_Initialize (void)
459:               {
00B76A  FA0000     LNK #0x0
460:                   
461:                   INTCON1bits.NSTDIS = 1; //disabling nested interrupts
00B76C  A8E081     BSET 0x81, #7
462:                   
463:                   /***************************************************************************     
464:                    * interrupt priority level : 1 is the lowest, 7 is the highest
465:                   ***************************************************************************/ 
466:               
467:                   IPC16bits.U1ERIP = 1; //    UERI: U1E - UART1 (BLE) Error
00B76E  800641     MOV IPC16, W1
00B770  2FF8F0     MOV #0xFF8F, W0
00B772  608000     AND W1, W0, W0
00B774  A04000     BSET W0, #4
00B776  880640     MOV W0, IPC16
468:                   IPC3bits.U1TXIP = 1;//    UTXI: U1TX - UART1 Transmitter
00B778  800571     MOV IPC3, W1
00B77A  2FFF80     MOV #0xFFF8, W0
00B77C  608000     AND W1, W0, W0
00B77E  A00000     BSET W0, #0
00B780  880570     MOV W0, IPC3
469:                   IPC2bits.U1RXIP = 1; //    URXI: U1RX - UART1 Receiver
00B782  800561     MOV IPC2, W1
00B784  28FFF0     MOV #0x8FFF, W0
00B786  608000     AND W1, W0, W0
00B788  A0C000     BSET W0, #12
00B78A  880560     MOV W0, IPC2
470:                   IPC16bits.U2ERIP = 1; //    UERI: U2E - UART2(LoRa) Error
00B78C  800641     MOV IPC16, W1
00B78E  2F8FF0     MOV #0xF8FF, W0
00B790  608000     AND W1, W0, W0
00B792  A08000     BSET W0, #8
00B794  880640     MOV W0, IPC16
471:                   IPC7bits.U2TXIP = 1; //    UTXI: U2TX - UART2 Transmitter
00B796  8005B1     MOV IPC7, W1
00B798  28FFF0     MOV #0x8FFF, W0
00B79A  608000     AND W1, W0, W0
00B79C  A0C000     BSET W0, #12
00B79E  8805B0     MOV W0, IPC7
472:                   IPC7bits.U2RXIP = 1; //    URXI: U2RX - UART2 Receiver
00B7A0  8005B1     MOV IPC7, W1
00B7A2  2F8FF0     MOV #0xF8FF, W0
00B7A4  608000     AND W1, W0, W0
00B7A6  A08000     BSET W0, #8
00B7A8  8805B0     MOV W0, IPC7
473:                   IPC20bits.U3ERIP = 1; //    UERI: U3E - UART3(WiFi) Error
00B7AA  800681     MOV IPC20, W1
00B7AC  2FF8F0     MOV #0xFF8F, W0
00B7AE  608000     AND W1, W0, W0
00B7B0  A04000     BSET W0, #4
00B7B2  880680     MOV W0, IPC20
474:                   IPC20bits.U3TXIP = 1; //    UTXI: U3TX - UART3 Transmitter
00B7B4  800681     MOV IPC20, W1
00B7B6  28FFF0     MOV #0x8FFF, W0
00B7B8  608000     AND W1, W0, W0
00B7BA  A0C000     BSET W0, #12
00B7BC  880680     MOV W0, IPC20
475:                   IPC20bits.U3RXIP = 1; //    URXI: U3RX - UART3 Receiver
00B7BE  800681     MOV IPC20, W1
00B7C0  2F8FF0     MOV #0xF8FF, W0
00B7C2  608000     AND W1, W0, W0
00B7C4  A08000     BSET W0, #8
00B7C6  880680     MOV W0, IPC20
476:               
477:                   IPC0bits.INT0IP = 1;//    INT0I: INT0 - Timer button
00B7C8  800541     MOV IPC0, W1
00B7CA  2FFF80     MOV #0xFFF8, W0
00B7CC  608000     AND W1, W0, W0
00B7CE  A00000     BSET W0, #0
00B7D0  880540     MOV W0, IPC0
478:                   IPC5bits.INT1IP = 1; //    INT1I: INT1 -Down button
00B7D2  800591     MOV IPC5, W1
00B7D4  2FFF80     MOV #0xFFF8, W0
00B7D6  608000     AND W1, W0, W0
00B7D8  A00000     BSET W0, #0
00B7DA  880590     MOV W0, IPC5
479:                   IPC13bits.INT3IP = 1; //    INT3I: INT3 - Power button   
00B7DC  800611     MOV IPC13, W1
00B7DE  2FF8F0     MOV #0xFF8F, W0
00B7E0  608000     AND W1, W0, W0
00B7E2  A04000     BSET W0, #4
00B7E4  880610     MOV W0, IPC13
480:                   IPC7bits.INT2IP = 1; //    INT2I: INT2 - Up button
00B7E6  8005B1     MOV IPC7, W1
00B7E8  2FF8F0     MOV #0xFF8F, W0
00B7EA  608000     AND W1, W0, W0
00B7EC  A04000     BSET W0, #4
00B7EE  8805B0     MOV W0, IPC7
481:                   IPC13bits.INT4IP = 1; //BLE Status 1 signal
00B7F0  800611     MOV IPC13, W1
00B7F2  2F8FF0     MOV #0xF8FF, W0
00B7F4  608000     AND W1, W0, W0
00B7F6  A08000     BSET W0, #8
00B7F8  880610     MOV W0, IPC13
482:                   
483:                   IPC7bits.T5IP = 1; //    TI: T5 - Timer5
00B7FA  8005B1     MOV IPC7, W1
00B7FC  2FFF80     MOV #0xFFF8, W0
00B7FE  608000     AND W1, W0, W0
00B800  A00000     BSET W0, #0
00B802  8805B0     MOV W0, IPC7
484:                   IPC6bits.T4IP = 1;//    TI: T4 - Timer4
00B804  8005A1     MOV IPC6, W1
00B806  28FFF0     MOV #0x8FFF, W0
00B808  608000     AND W1, W0, W0
00B80A  A0C000     BSET W0, #12
00B80C  8805A0     MOV W0, IPC6
485:                   IPC1bits.T2IP = 1;//    TI: T2 - Timer2
00B80E  800551     MOV IPC1, W1
00B810  28FFF0     MOV #0x8FFF, W0
00B812  608000     AND W1, W0, W0
00B814  A0C000     BSET W0, #12
00B816  880550     MOV W0, IPC1
486:               
487:                   
488:                   /****************************************************************************
489:                    * Clearing and Enabling UART interrupts
490:                    ***************************************************************************/
491:                   IFS0bits.U1RXIF = 0; //clearing up the U1Rx interrupt for Bluetooth
00B818  A96089     BCLR 0x89, #3
492:                   IEC0bits.U1RXIE = 1;
00B81A  A86099     BSET 0x99, #3
493:                   
494:                   //TODO: Enable LoRa and WiFi interrupts when needed
495:                   IFS1bits.U2RXIF = 0;  //Clear LoRa Receive interrupt flag
00B81C  A9C08B     BCLR 0x8B, #6
496:                   //IEC1bits.U2RXIE = 1;  //Enable LoRa Receive interrupt
497:                   
498:                   IFS5bits.U3RXIF = 0; //clearing flag - WiFi
00B81E  A94092     BCLR IFS5, #2
499:                   //IEC5bits.U3RXIE = 1; //enabling receive interrupt for WiFi
500:                   
501:                   /****************************************************************************
502:                    * Clearing and Enabling button interrupts
503:                   ***************************************************************************/
504:                   UpButton_NegativeEdgeSet();
00B820  A84082     BSET INTCON2, #2
505:                   UpButton_InterruptFlagClear();    
00B822  A9A08B     BCLR 0x8B, #5
506:                   UpButton_InterruptEnable();
00B824  A8A09B     BSET 0x9B, #5
507:                   
508:                   DownButton_NegativeEdgeSet();
00B826  A82082     BSET INTCON2, #1
509:                   DownButton_InterruptFlagClear();    
00B828  A9808A     BCLR IFS1, #4
510:                   DownButton_InterruptEnable();
00B82A  A8809A     BSET IEC1, #4
511:                   
512:                   TimerButton_NegativeEdgeSet();
00B82C  A80082     BSET INTCON2, #0
513:                   TimerButton_InterruptFlagClear();    
00B82E  A90088     BCLR IFS0, #0
514:                   TimerButton_InterruptEnable();
00B830  A80098     BSET IEC0, #0
515:                   
516:                   PowerButton_NegativeEdgeSet();
00B832  A86082     BSET INTCON2, #3
517:                   PowerButton_InterruptFlagClear();
00B834  A9A08E     BCLR IFS3, #5
518:                   PowerButton_InterruptEnable();
00B836  A8A09E     BSET IEC3, #5
519:                   
520:                   //BLE STATUS INTERRUPT:
521:                   //BLE connected interrupt is enabled after RN4871 init
522:                   BLEStatus_NegativeEdgeSet(); //goes to zero when connected
00B838  A88082     BSET INTCON2, #4
523:                   //BLEStatus_InterruptFlagclear();
524:                   //BLEStatus_InterruptEnable();
525:               }
00B83A  FA8000     ULNK
00B83C  060000     RETURN
526:               
527:               /**
528:                * 1ms timer
529:                */
530:               void TMR1_Initialize (void) //TMR1: 1ms tick
531:               {
00B83E  FA0000     LNK #0x0
532:                   //TMR1 0; 
533:                   TMR1 = 0x0000;
00B840  EF2190     CLR TMR1
534:                   //Period = 0.001 s; Frequency = 16000000 Hz; PR1 16000; 
535:                   PR1 = 0x3E80; //interrupt every 1ms: (16000/16E6) = 1ms
00B842  23E800     MOV #0x3E80, W0
00B844  880C90     MOV W0, PR1
536:                   //TCKPS 1:1; TON enabled; TSIDL disabled; TCS FOSC/2; TECS SOSC; TSYNC disabled; TGATE disabled; 
537:                   T1CON = 0x0000;
00B846  EF2194     CLR T1CON
538:                   IFS0bits.T1IF = false;
00B848  A96088     BCLR IFS0, #3
539:                   IEC0bits.T1IE = true;
00B84A  A86098     BSET IEC0, #3
540:               }
00B84C  FA8000     ULNK
00B84E  060000     RETURN
541:               
542:               void TMR1_Start( void )
543:               {
00B850  FA0000     LNK #0x0
544:                   u16Timer1Tick1ms = 0; //resetting the tick counter    
00B852  EF28E6     CLR u16Timer1Tick1ms
545:                   IEC0bits.T1IE = true;//Enable the interrupt   
00B854  A86098     BSET IEC0, #3
546:                   T1CONbits.TON = 1; //starting up the timer
00B856  A8E195     BSET 0x195, #7
547:               }
00B858  FA8000     ULNK
00B85A  060000     RETURN
548:               
549:               void TMR1_Stop( void )
550:               {
00B85C  FA0000     LNK #0x0
551:                   T1CONbits.TON = false; //Stopping timer
00B85E  A9E195     BCLR 0x195, #7
552:                   //Disabling the interrupt*/
553:                   IEC0bits.T1IE = false;    
00B860  A96098     BCLR IEC0, #3
554:                   u16Timer1Tick1ms = 0;
00B862  EF28E6     CLR u16Timer1Tick1ms
555:               }
00B864  FA8000     ULNK
00B866  060000     RETURN
556:               void TMR1_Reset(void)
557:               {
00B868  FA0000     LNK #0x0
558:                   TMR1 = 0x0000;
00B86A  EF2190     CLR TMR1
559:                   u16Timer1Tick1ms = 0;
00B86C  EF28E6     CLR u16Timer1Tick1ms
560:               }
00B86E  FA8000     ULNK
00B870  060000     RETURN
561:               
562:               void TMR2_Initialize (void) //TMR2: 100ms tick
563:               {
00B872  FA0000     LNK #0x0
564:                   //TMR2 0; 
565:                   TMR2 = 0x0000;
00B874  EF2196     CLR TMR2
566:                   //Period = 0.1 s; Frequency = 16000000 Hz; PR2 25000; 
567:                   PR2 = 0x61A8; //interrupt every 100ms: (25000/16E6)*64 = 0.1s 
00B876  261A80     MOV #0x61A8, W0
00B878  880CE0     MOV W0, PR2
568:                   //TCKPS 1:64; T32 16 Bit; TON enabled; TSIDL disabled; TCS FOSC/2; TECS SOSC; TGATE disabled; 
569:                   T2CON = 0x0020;
00B87A  200200     MOV #0x20, W0
00B87C  880D00     MOV W0, T2CON
570:                   IFS0bits.T2IF = false;
00B87E  A9E088     BCLR IFS0, #7
571:                   IEC0bits.T2IE = true;
00B880  A8E098     BSET IEC0, #7
572:               }
00B882  FA8000     ULNK
00B884  060000     RETURN
573:               
574:               void TMR2_Start( void )
575:               {
00B886  FA0000     LNK #0x0
576:                   /*Enable the interrupt*/
577:                   IEC0bits.T2IE = true;
00B888  A8E098     BSET IEC0, #7
578:                   Timer2Tick100ms = 0;
00B88A  EF28E8     CLR Timer2Tick100ms
579:                   /* Start the Timer */
580:                   T2CONbits.TON = 1;
00B88C  A8E1A1     BSET 0x1A1, #7
581:               }
00B88E  FA8000     ULNK
00B890  060000     RETURN
582:               void TMR2_Stop( void )
583:               {
00B892  FA0000     LNK #0x0
584:                   /* Stop the Timer */
585:                   Timer2Tick100ms = 0;
00B894  EF28E8     CLR Timer2Tick100ms
586:                   T2CONbits.TON = false;
00B896  A9E1A1     BCLR 0x1A1, #7
587:                   
588:                   /*Disable the interrupt*/
589:                   IEC0bits.T2IE = false;
00B898  A9E098     BCLR IEC0, #7
590:               }
00B89A  FA8000     ULNK
00B89C  060000     RETURN
591:               
592:               void TMR2_Reset(void)
593:               {
00B89E  FA0000     LNK #0x0
594:                   TMR2 = 0x0000;
00B8A0  EF2196     CLR TMR2
595:                   Timer2Tick100ms = 0;
00B8A2  EF28E8     CLR Timer2Tick100ms
596:               }
00B8A4  FA8000     ULNK
00B8A6  060000     RETURN
597:               void TMR3_Initialize (void) //TMR3 : 1s tick
598:               {
00B8A8  FA0000     LNK #0x0
599:                   TMR3 = 0x0000;
00B8AA  EF219A     CLR TMR3
600:                   //Period = 1 s; Frequency = 16000000 Hz; PR4 2000; 
601:                   PR3 = 0xF424;
00B8AC  2F4240     MOV #0xF424, W0
00B8AE  880CF0     MOV W0, PR3
602:                   //TCKPS 1:256; T32 16 Bit; TON disabled; TSIDL disabled; TCS FOSC/2; TECS SOSC; TGATE disabled; 
603:                   T3CON = 0x0030;
00B8B0  200300     MOV #0x30, W0
00B8B2  880D10     MOV W0, T3CON
604:                   IFS1bits.T4IF = false;
00B8B4  A9608B     BCLR 0x8B, #3
605:                   IEC1bits.T4IE = false;
00B8B6  A9609B     BCLR 0x9B, #3
606:               
607:               }
00B8B8  FA8000     ULNK
00B8BA  060000     RETURN
608:               void TMR3_Start( void )
609:               {
00B8BC  FA0000     LNK #0x0
610:                   /*Enable the interrupt*/
611:                   IFS0bits.T3IF = false;
00B8BE  A90089     BCLR 0x89, #0
612:                   IEC0bits.T3IE = true;
00B8C0  A80099     BSET 0x99, #0
613:                   u16Timer3Tick1s = 0;
00B8C2  EF28EA     CLR u16Timer3Tick1s
614:                   /* Start the Timer */
615:                   T3CONbits.TON = 1;
00B8C4  A8E1A3     BSET 0x1A3, #7
616:               }
00B8C6  FA8000     ULNK
00B8C8  060000     RETURN
617:               void TMR3_Stop( void )
618:               {
00B8CA  FA0000     LNK #0x0
619:                   /* Stop the Timer */
620:                   T3CONbits.TON = false;
00B8CC  A9E1A3     BCLR 0x1A3, #7
621:                   
622:                   /*Disable the interrupt*/
623:                   IEC0bits.T3IE = false;
00B8CE  A90099     BCLR 0x99, #0
624:               }
00B8D0  FA8000     ULNK
00B8D2  060000     RETURN
625:               void TMR3_Reset(void)
626:               {
00B8D4  FA0000     LNK #0x0
627:                   TMR3 = 0x0000;
00B8D6  EF219A     CLR TMR3
628:                   u16Timer3Tick1s = 0;
00B8D8  EF28EA     CLR u16Timer3Tick1s
629:               }
00B8DA  FA8000     ULNK
00B8DC  060000     RETURN
630:               
631:               void TMR4_Initialize (void) //TMR4 : 10ms tick
632:               {
00B8DE  FA0000     LNK #0x0
633:                   //TMR4 0; 
634:                   TMR4 = 0x0000;
00B8E0  EF21A4     CLR TMR4
635:                   //Period = 0.01 s; Frequency = 16000000 Hz; PR4 20000; 
636:                   PR4 = 0x4E20;
00B8E2  24E200     MOV #0x4E20, W0
00B8E4  880D50     MOV W0, PR4
637:                   //TCKPS 1:8; T32 16 Bit; TON disabled; TSIDL disabled; TCS FOSC/2; TECS SOSC; TGATE disabled; 
638:                   T4CON = 0x0010;
00B8E6  200100     MOV #0x10, W0
00B8E8  880D70     MOV W0, T4CON
639:                   
640:                   IFS0bits.T3IF = false;
00B8EA  A90089     BCLR 0x89, #0
641:                   IEC0bits.T3IE = false;
00B8EC  A90099     BCLR 0x99, #0
642:               
643:               }
00B8EE  FA8000     ULNK
00B8F0  060000     RETURN
644:               void TMR4_Start( void )
645:               {
00B8F2  FA0000     LNK #0x0
646:                   /*Enable the interrupt*/
647:                   IEC1bits.T4IE = true;
00B8F4  A8609B     BSET 0x9B, #3
648:                   u16Timer4Tick10ms = 0;
00B8F6  EF28EC     CLR u16Timer4Tick10ms
649:                   /* Start the Timer */
650:                   T4CONbits.TON = 1;
00B8F8  A8E1AF     BSET 0x1AF, #7
651:               }
00B8FA  FA8000     ULNK
00B8FC  060000     RETURN
652:               
653:               void TMR4_Stop( void )
654:               {
00B8FE  FA0000     LNK #0x0
655:                   /* Stop the Timer */
656:                   T4CONbits.TON = false;
00B900  A9E1AF     BCLR 0x1AF, #7
657:                   
658:                   /*Disable the interrupt*/
659:                   IEC1bits.T4IE = false;
00B902  A9609B     BCLR 0x9B, #3
660:               }
00B904  FA8000     ULNK
00B906  060000     RETURN
661:               void TMR4_Reset(void)
662:               {
00B908  FA0000     LNK #0x0
663:                   TMR4 = 0x0000;
00B90A  EF21A4     CLR TMR4
664:                   u16Timer4Tick10ms = 0;
00B90C  EF28EC     CLR u16Timer4Tick10ms
665:               }
00B90E  FA8000     ULNK
00B910  060000     RETURN
666:               
667:               void TMR5_Initialize (void) //TMR5 : 100us tick
668:               {
00B912  FA0000     LNK #0x0
669:                   //TMR5 0; 
670:                   TMR5 = 0x0000;
00B914  EF21A8     CLR TMR5
671:                   //Period = 0.0001 s; Frequency = 16000000 Hz; PR5 200; 
672:                   PR5 = 0x00C8;
00B916  200C80     MOV #0xC8, W0
00B918  880D60     MOV W0, PR5
673:                   //TCKPS 1:8; TON disabled; TSIDL disabled; TCS FOSC/2; TECS SOSC; TGATE disabled; 
674:                   T5CON = 0x0010;
00B91A  200100     MOV #0x10, W0
00B91C  880D80     MOV W0, T5CON
675:                   
676:                   IFS1bits.T5IF = false;
00B91E  A9808B     BCLR 0x8B, #4
677:                   IEC1bits.T5IE = false;
00B920  A9809B     BCLR 0x9B, #4
678:               }
00B922  FA8000     ULNK
00B924  060000     RETURN
679:               
680:               void TMR5_Reset(void)
681:               {
00B926  FA0000     LNK #0x0
682:                   TMR5 = 0x0000;
00B928  EF21A8     CLR TMR5
683:                   u32Timer5Tick100us = 0;
00B92A  EF28EE     CLR u32Timer5Tick100us
00B92C  EF28F0     CLR ___udivdi3
684:               }
00B92E  FA8000     ULNK
00B930  060000     RETURN
685:               void TMR5_Start( void )
686:               {
00B932  FA0000     LNK #0x0
687:                   /*Enabling interrupt*/
688:                   IFS1bits.T5IF = false;
00B934  A9808B     BCLR 0x8B, #4
689:                   IEC1bits.T5IE = true;
00B936  A8809B     BSET 0x9B, #4
690:                   u32Timer5Tick100us = 0;
00B938  EF28EE     CLR u32Timer5Tick100us
00B93A  EF28F0     CLR ___udivdi3
691:                   /* Start the Timer */
692:                   T5CONbits.TON = 1;
00B93C  A8E1B1     BSET 0x1B1, #7
693:               }
00B93E  FA8000     ULNK
00B940  060000     RETURN
694:               void TMR5_Stop( void )
695:               {
00B942  FA0000     LNK #0x0
696:                   /* Stop the Timer */
697:                   T5CONbits.TON = false;
00B944  A9E1B1     BCLR 0x1B1, #7
698:                   IEC1bits.T5IE = false;
00B946  A9809B     BCLR 0x9B, #4
699:               
700:               }
00B948  FA8000     ULNK
00B94A  060000     RETURN
701:               
702:               
703:               void SPI1_Initialize (void)
704:               {
00B94C  FA0000     LNK #0x0
705:                   // AUDEN disabled; FRMEN disabled; AUDMOD I2S; FRMSYPW One clock wide; 
706:                   //AUDMONO stereo; FRMCNT 0; MSSEN disabled; FRMPOL disabled; 
707:                   //IGNROV disabled; SPISGNEXT not sign-extended; FRMSYNC disabled; URDTEN disabled; IGNTUR disabled; 
708:                   SPI1CON1H = 0x0000;
00B94E  EF23F6     CLR SPI1CON1H
709:                   // WLENGTH 0; 
710:                   SPI1CON2L = 0x0000; //data length set by mode
00B950  EF23F8     CLR SPI1CON2L
711:                   // SPIROV disabled; FRMERR disabled; 
712:                   SPI1STATL = 0x0000;
00B952  EF23FC     CLR SPI1STATL
713:                   // SPI1BRGL 1; 
714:                   SPI1BRGL = 0x0003; //2MHZ 0x0003, 1MHz 0x0007, 500KHz = 0x000F
00B954  200030     MOV #0x3, W0
00B956  882020     MOV W0, SPI1BRGL
715:                   // SPITBFEN disabled; SPITUREN disabled; FRMERREN disabled; SRMTEN disabled; 
716:                   // SPIRBEN disabled; BUSYEN disabled; SPITBEN disabled; SPIROVEN disabled; SPIRBFEN disabled; 
717:                   SPI1IMSKL = 0x0000;
00B958  EF2408     CLR SPI1IMSKL
718:                   // RXMSK 0; TXWIEN disabled; TXMSK 0; RXWIEN disabled; 
719:                   SPI1IMSKH = 0x0000;
00B95A  EF240A     CLR SPI1IMSKH
720:                   // SPI1URDTL 0; 
721:                   SPI1URDTL = 0x0000;
00B95C  EF240C     CLR SPI1URDTL
722:                   // SPI1URDTH 0; 
723:                   SPI1URDTH = 0x0000;
00B95E  EF240E     CLR SPI1URDTH
724:                   // SPIEN enabled; DISSDO disabled; MCLKEN FOSC/2; CKP Idle:Low, Active:High; 
725:                   // SSEN disabled; MSTEN Master; MODE16 disabled; SMP Middle; DISSCK disabled; 
726:                   // SPIFE Frame Sync pulse precedes; CKE Idle to Active; MODE32 disabled; 
727:                   // SPISIDL disabled; ENHBUF enabled; DISSDI disabled; 
728:                   //SPI1CON1L = 0x8060; //sampling at mid Mode 3. Previous end sampling: 0x8060; 
729:                   SPI1CON1Lbits.MSTEN = 1; //Master mode enabled
00B960  A8A3F4     BSET SPI1CON1L, #5
730:                   SPI1CON1Lbits.SMP = 0; //1=data sampled at the end 0 = in the middle of data output time
00B962  A923F5     BCLR 0x3F5, #1
731:                   //CPOL = 0, CPHA = 0 : SPI Mode 0
732:                   SPI1CON1Lbits.CKP = 0; //1=clock idles high, 0 = clock idles low -> same as CPOL
00B964  A9C3F4     BCLR SPI1CON1L, #6
733:                   SPI1CON1Lbits.CKE = 1; //1 = transmit happens on active to idle, 0 = tx on idle to active, -> inverse of CHPA
00B966  A803F5     BSET 0x3F5, #0
734:                   SPI1CON1Lbits.ENHBUF = 0;
00B968  A903F4     BCLR SPI1CON1L, #0
735:                   
736:                   
737:                   SPI1CON1Hbits.IGNROV = 1; //ignore rx overflow errors
00B96A  A8A3F7     BSET 0x3F7, #5
738:                   //SPI1CON1Lbits.SPIEN = 1; //will be enabling the peripheral manually when needed
739:               }
00B96C  FA8000     ULNK
00B96E  060000     RETURN
740:               void SPI1_Write8bit(uint8_t data)
741:               {
00B970  FA0004     LNK #0x4
00B972  984720     MOV.B W0, [W14+2]
742:                   uint8_t rxData = 0;
00B974  EB4000     CLR.B W0
00B976  784F00     MOV.B W0, [W14]
743:                   while (SPI1STATLbits.SPITBF == true) {} //wait if transmit buffer is full
00B978  000000     NOP
00B97A  801FE0     MOV SPI1STATL, W0
00B97C  600062     AND W0, #0x2, W0
00B97E  E00000     CP0 W0
00B980  3AFFFC     BRA NZ, .L55
744:                   SPI1BUFL = data;
00B982  90402E     MOV.B [W14+2], W0
00B984  FB8000     ZE W0, W0
00B986  882000     MOV W0, SPI1BUFL
745:                   while (SPI1STATLbits.SPIBUSY == true) {} //wait until data is transmitted
00B988  000000     NOP
00B98A  801FE1     MOV SPI1STATL, W1
00B98C  208000     MOV #0x800, W0
00B98E  608000     AND W1, W0, W0
00B990  E00000     CP0 W0
00B992  3AFFFB     BRA NZ, .L56
746:                   rxData = SPI1BUFL; //to clear out the rx buffer just in case
00B994  802000     MOV SPI1BUFL, W0
00B996  784F00     MOV.B W0, [W14]
747:               }
00B998  FA8000     ULNK
00B99A  060000     RETURN
748:               
749:               uint8_t SPI1_Exchange8bit(uint8_t data){
00B99C  FA0004     LNK #0x4
00B99E  984720     MOV.B W0, [W14+2]
750:                  uint8_t rxData; 
751:                  rxData = SPI1BUFL; //to clear out the rx buffer just in case
00B9A0  802000     MOV SPI1BUFL, W0
00B9A2  784F00     MOV.B W0, [W14]
752:                  SPI1STATLbits.SPIROV = 0; //clearing the overrun bit
00B9A4  A9C3FC     BCLR SPI1STATL, #6
753:                  while (SPI1STATLbits.SPITBF == true) {} //wait if transmit buffer is full
00B9A6  000000     NOP
00B9A8  801FE0     MOV SPI1STATL, W0
00B9AA  600062     AND W0, #0x2, W0
00B9AC  E00000     CP0 W0
00B9AE  3AFFFC     BRA NZ, .L58
754:                  SPI1BUFL = data;   
00B9B0  90402E     MOV.B [W14+2], W0
00B9B2  FB8000     ZE W0, W0
00B9B4  882000     MOV W0, SPI1BUFL
755:                  while (SPI1STATLbits.SPIBUSY == true){} //wait while transactions are not complete
00B9B6  000000     NOP
00B9B8  801FE1     MOV SPI1STATL, W1
00B9BA  208000     MOV #0x800, W0
00B9BC  608000     AND W1, W0, W0
00B9BE  E00000     CP0 W0
00B9C0  3AFFFB     BRA NZ, .L59
756:                  while (SPI1STATLbits.SPIRBF != true) {} //wait while rx buffer is not full
00B9C2  000000     NOP
00B9C4  801FE0     MOV SPI1STATL, W0
00B9C6  600061     AND W0, #0x1, W0
00B9C8  E00000     CP0 W0
00B9CA  32FFFC     BRA Z, .L60
757:                  Nop(); //1 clk cycle delay for trailing bit
00B9CC  000000     NOP
758:                  rxData = SPI1BUFL;    
00B9CE  802000     MOV SPI1BUFL, W0
00B9D0  784F00     MOV.B W0, [W14]
759:                  return (rxData);   
00B9D2  78401E     MOV.B [W14], W0
760:               }
00B9D4  FA8000     ULNK
00B9D6  060000     RETURN
761:               
762:               uint16_t SPI1_Exchange16bit(uint16_t data){
00B9D8  FA0006     LNK #0x6
00B9DA  980720     MOV W0, [W14+4]
763:                  uint16_t receiveDataL;
764:                  uint16_t receiveDataH;
765:                  while (SPI1STATLbits.SPITBF == true) {} //wait if transmit buffer is full
00B9DC  000000     NOP
00B9DE  801FE0     MOV SPI1STATL, W0
00B9E0  600062     AND W0, #0x2, W0
00B9E2  E00000     CP0 W0
00B9E4  3AFFFC     BRA NZ, .L62
766:                  SPI1BUFL = data>>8; //high byte
00B9E6  90002E     MOV [W14+4], W0
00B9E8  DE0048     LSR W0, #8, W0
00B9EA  882000     MOV W0, SPI1BUFL
767:                  while (SPI1STATLbits.SPIBUSY == true){} //wait while transactions are not complete
00B9EC  000000     NOP
00B9EE  801FE1     MOV SPI1STATL, W1
00B9F0  208000     MOV #0x800, W0
00B9F2  608000     AND W1, W0, W0
00B9F4  E00000     CP0 W0
00B9F6  3AFFFB     BRA NZ, .L63
768:                  while (SPI1STATLbits.SPIRBF != true) {} //wait while rx buffer is not full
00B9F8  000000     NOP
00B9FA  801FE0     MOV SPI1STATL, W0
00B9FC  600061     AND W0, #0x1, W0
00B9FE  E00000     CP0 W0
00BA00  32FFFC     BRA Z, .L64
769:                  Nop(); //1 clk cycle delay for trailing bit
00BA02  000000     NOP
770:                  receiveDataH = SPI1BUFL;    
00BA04  802001     MOV SPI1BUFL, W1
00BA06  780F01     MOV W1, [W14]
771:                  while (SPI1STATLbits.SPITBF == true) {} //wait if transmit buffer is full
00BA08  000000     NOP
00BA0A  801FE0     MOV SPI1STATL, W0
00BA0C  600062     AND W0, #0x2, W0
00BA0E  E00000     CP0 W0
00BA10  3AFFFC     BRA NZ, .L65
772:                  SPI1BUFL = data; //low byte
00BA12  9000AE     MOV [W14+4], W1
00BA14  882001     MOV W1, SPI1BUFL
773:                  while (SPI1STATLbits.SPIBUSY == true){} //wait while transactions are not complete
00BA16  000000     NOP
00BA18  801FE1     MOV SPI1STATL, W1
00BA1A  208000     MOV #0x800, W0
00BA1C  608000     AND W1, W0, W0
00BA1E  E00000     CP0 W0
00BA20  3AFFFB     BRA NZ, .L66
774:                  while (SPI1STATLbits.SPIRBF != true) {} //wait while rx buffer is not full
00BA22  000000     NOP
00BA24  801FE0     MOV SPI1STATL, W0
00BA26  600061     AND W0, #0x1, W0
00BA28  E00000     CP0 W0
00BA2A  32FFFC     BRA Z, .L67
775:                  Nop(); //1 clk cycle delay for trailing bit
00BA2C  000000     NOP
776:                  receiveDataL = SPI1BUFL; 
00BA2E  802001     MOV SPI1BUFL, W1
00BA30  980711     MOV W1, [W14+2]
777:                  return (receiveDataH<<8)|receiveDataL;   
00BA32  78001E     MOV [W14], W0
00BA34  DD00C8     SL W0, #8, W1
00BA36  90001E     MOV [W14+2], W0
00BA38  700001     IOR W0, W1, W0
778:               }
00BA3A  FA8000     ULNK
00BA3C  060000     RETURN
779:               
780:               /*******************************************************************************
781:                                    UART1 used for Bluetooth Comms
782:               *******************************************************************************/
783:               void UART1_Initialize(void)
784:               {
00BA3E  FA0000     LNK #0x0
785:                   // STSEL 1; IREN disabled; PDSEL 8N; UARTEN enabled; RTSMD disabled; 
786:                   // USIDL disabled; WAKE disabled; ABAUD disabled; LPBACK disabled; 
787:                   // BRGH enabled; URXINV disabled; UEN TX_RX; 
788:                  U1MODE = (0x8008 & ~(1<<15));  // disabling UARTEN bit   
00BA40  200080     MOV #0x8, W0
00BA42  881CC0     MOV W0, U1MODE
789:                  // UTXISEL0 TX_ONE_CHAR; UTXINV disabled; OERR NO_ERROR_cleared; URXISEL RX_ONE_CHAR; UTXBRK COMPLETED; UTXEN disabled; ADDEN disabled; 
790:                  U1STA = 0x0000;
00BA44  EF239A     CLR U1STA
791:                  // BaudRate = 115200; Frequency = 4000000 Hz; U1BRG 8; 
792:                  U1BRG = BRGH_115200;
00BA46  200210     MOV #0x21, W0
00BA48  881D00     MOV W0, U1BRG
793:                  // ADMADDR 0; ADMMASK 0; 
794:                  U1ADMD = 0x0000;
00BA4A  EF23A2     CLR U1ADMD
795:                  // T0PD 1 ETU; PTRCL T0; TXRPT Retransmits the error byte once; CONV Direct; SCEN disabled; 
796:                  U1SCCON = 0x0000;
00BA4C  EF23A4     CLR U1SCCON
797:                  // TXRPTIF disabled; TXRPTIE disabled; WTCIF disabled; WTCIE disabled; PARIE disabled; GTCIF disabled; GTCIE disabled; RXRPTIE disabled; RXRPTIF disabled; 
798:                  U1SCINT = 0x0000;
00BA4E  EF23A6     CLR U1SCINT
799:                  // GTC 0; 
800:                  U1GTC = 0x0000;
00BA50  EF23A8     CLR U1GTC
801:                  // WTCL 0; 
802:                  U1WTCL = 0x0000;
00BA52  EF23AC     CLR U1WTCL
803:                  // WTCH 0; 
804:                  U1WTCH = 0x0000;
00BA54  EF23AA     CLR U1WTCH
805:                  
806:                  U1MODEbits.UARTEN = 1;  // enabling UART ON bit
00BA56  A8E399     BSET 0x399, #7
807:                  U1STAbits.UTXEN = 1;
00BA58  A8439B     BSET 0x39B, #2
808:               }
00BA5A  FA8000     ULNK
00BA5C  060000     RETURN
809:               
810:               void UART1_EnableFlowControl(void)
811:               {
00BA5E  FA0000     LNK #0x0
812:                   U1MODE = (U1MODE & 0xf7ff) | 0x0200;    //Enable RTC/CTS flow control
00BA60  801CC1     MOV U1MODE, W1
00BA62  2F5FF0     MOV #0xF5FF, W0
00BA64  608000     AND W1, W0, W0
00BA66  A09000     BSET W0, #9
00BA68  881CC0     MOV W0, U1MODE
813:               }
00BA6A  FA8000     ULNK
00BA6C  060000     RETURN
814:               
815:               /**
816:                * Pushes a null terminated C string to TXREG
817:                * @param msg - pointer to the string that is null terminated
818:                */
819:               void UART1_SendString(const char *msg)
820:               {
00BA6E  FA0004     LNK #0x4
00BA70  980710     MOV W0, [W14+2]
821:                   uint8_t msgLen=0;
00BA72  EB4000     CLR.B W0
00BA74  984710     MOV.B W0, [W14+1]
822:                   uint8_t i=0;
00BA76  EB4000     CLR.B W0
00BA78  784F00     MOV.B W0, [W14]
823:                   msgLen = strlen(msg);
00BA7A  90001E     MOV [W14+2], W0
00BA7C  07AA2A     RCALL _strlen
00BA7E  984710     MOV.B W0, [W14+1]
824:                   for (i=0; i<= msgLen-1; i++){
00BA80  EB4000     CLR.B W0
00BA82  784F00     MOV.B W0, [W14]
00BA84  37000D     BRA .L71
00BA9E  E84F1E     INC.B [W14], [W14]
00BAA0  FB809E     ZE [W14], W1
00BAA2  90401E     MOV.B [W14+1], W0
00BAA4  FB8000     ZE W0, W0
00BAA6  E90000     DEC W0, W0
00BAA8  508F80     SUB W1, W0, [W15]
00BAAA  34FFED     BRA LE, .L75
825:                       while (U1STAbits.UTXBF){} //wait until at least one character 
00BA86  000000     NOP
00BA88  801CD1     MOV U1STA, W1
00BA8A  202000     MOV #0x200, W0
00BA8C  608000     AND W1, W0, W0
00BA8E  E00000     CP0 W0
00BA90  3AFFFB     BRA NZ, .L72
826:                       U1TXREG = msg[i];         //can be written to the transmit buffer
00BA92  FB801E     ZE [W14], W0
00BA94  90009E     MOV [W14+2], W1
00BA96  408000     ADD W1, W0, W0
00BA98  784010     MOV.B [W0], W0
00BA9A  FB0000     SE W0, W0
00BA9C  881CE0     MOV W0, U1TXREG
827:                   }
828:                   //now we wait for transmit shift register to get empty
829:                   while (!U1STAbits.TRMT){}
00BAAC  000000     NOP
00BAAE  801CD1     MOV U1STA, W1
00BAB0  201000     MOV #0x100, W0
00BAB2  608000     AND W1, W0, W0
00BAB4  E00000     CP0 W0
00BAB6  32FFFB     BRA Z, .L74
830:               }
00BAB8  FA8000     ULNK
00BABA  060000     RETURN
831:               
832:               /**
833:                * Pushes a single byte of data in TXREG
834:                * @param msg - byte
835:                */
836:               void UART1_SendByte(uint8_t msg)
837:               {
00BABC  FA0002     LNK #0x2
00BABE  784F00     MOV.B W0, [W14]
838:                   while (U1STAbits.UTXBF){} //wait until at least one character 
00BAC0  000000     NOP
00BAC2  801CD1     MOV U1STA, W1
00BAC4  202000     MOV #0x200, W0
00BAC6  608000     AND W1, W0, W0
00BAC8  E00000     CP0 W0
00BACA  3AFFFB     BRA NZ, .L77
839:                   U1TXREG = msg;
00BACC  FB801E     ZE [W14], W0
00BACE  881CE0     MOV W0, U1TXREG
840:                   while (!U1STAbits.TRMT){}
00BAD0  000000     NOP
00BAD2  801CD1     MOV U1STA, W1
00BAD4  201000     MOV #0x100, W0
00BAD6  608000     AND W1, W0, W0
00BAD8  E00000     CP0 W0
00BADA  32FFFB     BRA Z, .L78
841:               }
00BADC  FA8000     ULNK
00BADE  060000     RETURN
842:               
843:               void UART1_SendBytes(uint8_t *byte, uint8_t startIndex, uint8_t cmdLen)
844:               {
00BAE0  FA0006     LNK #0x6
00BAE2  980710     MOV W0, [W14+2]
00BAE4  984741     MOV.B W1, [W14+4]
00BAE6  984752     MOV.B W2, [W14+5]
845:                   uint8_t i = 0;
00BAE8  EB4000     CLR.B W0
00BAEA  784F00     MOV.B W0, [W14]
846:                   for (i=startIndex; i< startIndex+cmdLen; i++)
00BAEC  9040CE     MOV.B [W14+4], W1
00BAEE  784F01     MOV.B W1, [W14]
00BAF0  37000D     BRA .L80
00BB0A  E84F1E     INC.B [W14], [W14]
00BB0C  FB809E     ZE [W14], W1
00BB0E  90404E     MOV.B [W14+4], W0
00BB10  FB8100     ZE W0, W2
00BB12  90405E     MOV.B [W14+5], W0
00BB14  FB8000     ZE W0, W0
00BB16  410000     ADD W2, W0, W0
00BB18  508F80     SUB W1, W0, [W15]
00BB1A  35FFEB     BRA LT, .L84
847:                   {
848:                      while (U1STAbits.UTXBF){} //wait until at least one character 
00BAF2  000000     NOP
00BAF4  801CD1     MOV U1STA, W1
00BAF6  202000     MOV #0x200, W0
00BAF8  608000     AND W1, W0, W0
00BAFA  E00000     CP0 W0
00BAFC  3AFFFB     BRA NZ, .L81
849:                       U1TXREG = byte[i];         //can be written to the transmit buffer 
00BAFE  FB801E     ZE [W14], W0
00BB00  90009E     MOV [W14+2], W1
00BB02  408000     ADD W1, W0, W0
00BB04  784010     MOV.B [W0], W0
00BB06  FB8000     ZE W0, W0
00BB08  881CE0     MOV W0, U1TXREG
850:                   }
851:                   //now we wait for transmit shift register to get empty
852:                   while (!U1STAbits.TRMT){}
00BB1C  000000     NOP
00BB1E  801CD1     MOV U1STA, W1
00BB20  201000     MOV #0x100, W0
00BB22  608000     AND W1, W0, W0
00BB24  E00000     CP0 W0
00BB26  32FFFB     BRA Z, .L83
853:               }
00BB28  FA8000     ULNK
00BB2A  060000     RETURN
854:               
855:               /**
856:                * Keeps reading the RXREG until there are no more bytes left
857:                */
858:               void UART1_FlushRxFIFO(void)
859:               {
00BB2C  FA0002     LNK #0x2
860:                   uint8_t tmp;
861:                   while (U1STAbits.URXDA) //while there is data present
00BB2E  370002     BRA .L86
00BB34  801CD0     MOV U1STA, W0
00BB36  600061     AND W0, #0x1, W0
00BB38  E00000     CP0 W0
00BB3A  3AFFFA     BRA NZ, .L87
862:                   {
863:                       tmp = U1RXREG; //read and discard
00BB30  801CF0     MOV U1RXREG, W0
00BB32  784F00     MOV.B W0, [W14]
864:                   }  
865:               }
00BB3C  FA8000     ULNK
00BB3E  060000     RETURN
866:               
867:               
868:               
869:               /*******************************************************************************
870:                                    UART2 - used for LoRa comms:
871:               *******************************************************************************/
872:               void UART2_Initialize(void)
873:               {
00BB40  FA0000     LNK #0x0
874:                   // STSEL 1; IREN disabled; PDSEL 8N; UARTEN enabled; RTSMD disabled; 
875:                   // USIDL disabled; WAKE disabled; ABAUD disabled; LPBACK disabled; 
876:                   // BRGH enabled; URXINV disabled; UEN TX_RX; 
877:                  U2MODE = (0x8008 & ~(1<<15));  // disabling UARTEN bit   
00BB42  200080     MOV #0x8, W0
00BB44  881D70     MOV W0, U2MODE
878:                  // UTXISEL0 TX_ONE_CHAR; UTXINV disabled; OERR NO_ERROR_cleared; URXISEL RX_ONE_CHAR; UTXBRK COMPLETED; UTXEN disabled; ADDEN disabled; 
879:                  U2STA = 0x0000;
00BB46  EF23B0     CLR U2STA
880:                  // BaudRate 
881:                  U2BRG = BRGH_57600;
00BB48  200440     MOV #0x44, W0
00BB4A  881DB0     MOV W0, U2BRG
882:                  // ADMADDR 0; ADMMASK 0; 
883:                  U2ADMD = 0x0000;
00BB4C  EF23B8     CLR U2ADMD
884:                  // T0PD 1 ETU; PTRCL T0; TXRPT Retransmits the error byte once; CONV Direct; SCEN disabled; 
885:                  U2SCCON = 0x0000;
00BB4E  EF23BA     CLR U2SCCON
886:                  // TXRPTIF disabled; TXRPTIE disabled; WTCIF disabled; WTCIE disabled; PARIE disabled; GTCIF disabled; GTCIE disabled; RXRPTIE disabled; RXRPTIF disabled; 
887:                  U2SCINT = 0x0000;
00BB50  EF23BC     CLR U2SCINT
888:                  // GTC 0; 
889:                  U2GTC = 0x0000;
00BB52  EF23BE     CLR U2GTC
890:                  // WTCL 0; 
891:                  U2WTCL = 0x0000;
00BB54  EF23C2     CLR U2WTCL
892:                  // WTCH 0; 
893:                  U2WTCH = 0x0000;
00BB56  EF23C0     CLR U2WTCH
894:               
895:                  U2MODEbits.UARTEN = 1;  // enabling UART ON bit
00BB58  A8E3AF     BSET 0x3AF, #7
896:                  U2STAbits.UTXEN = 1;
00BB5A  A843B1     BSET 0x3B1, #2
897:                   
898:               }
00BB5C  FA8000     ULNK
00BB5E  060000     RETURN
899:               
900:               /**
901:                * Pushes a null terminated C string to TXREG
902:                * @param msg - pointer to the string that is null terminated
903:                */
904:               void UART2_SendString(char *msg)
905:               {
00BB60  FA0004     LNK #0x4
00BB62  980710     MOV W0, [W14+2]
906:                   uint8_t msgLen=0;
00BB64  EB4000     CLR.B W0
00BB66  984710     MOV.B W0, [W14+1]
907:                   uint8_t i=0;
00BB68  EB4000     CLR.B W0
00BB6A  784F00     MOV.B W0, [W14]
908:                   msgLen = strlen(msg);
00BB6C  90001E     MOV [W14+2], W0
00BB6E  07A9B1     RCALL _strlen
00BB70  984710     MOV.B W0, [W14+1]
909:                   for (i=0; i<= msgLen-1; i++){
00BB72  EB4000     CLR.B W0
00BB74  784F00     MOV.B W0, [W14]
00BB76  37000D     BRA .L90
00BB90  E84F1E     INC.B [W14], [W14]
00BB92  FB809E     ZE [W14], W1
00BB94  90401E     MOV.B [W14+1], W0
00BB96  FB8000     ZE W0, W0
00BB98  E90000     DEC W0, W0
00BB9A  508F80     SUB W1, W0, [W15]
00BB9C  34FFED     BRA LE, .L94
910:                       while (U2STAbits.UTXBF){} //wait until at least one character 
00BB78  000000     NOP
00BB7A  801D81     MOV U2STA, W1
00BB7C  202000     MOV #0x200, W0
00BB7E  608000     AND W1, W0, W0
00BB80  E00000     CP0 W0
00BB82  3AFFFB     BRA NZ, .L91
911:                       U2TXREG = msg[i];         //can be written to the transmit buffer
00BB84  FB801E     ZE [W14], W0
00BB86  90009E     MOV [W14+2], W1
00BB88  408000     ADD W1, W0, W0
00BB8A  784010     MOV.B [W0], W0
00BB8C  FB0000     SE W0, W0
00BB8E  881D90     MOV W0, U2TXREG
912:                   }
913:                   //now we wait for transmit shift register to get empty
914:                   while (!U2STAbits.TRMT){}
00BB9E  000000     NOP
00BBA0  801D81     MOV U2STA, W1
00BBA2  201000     MOV #0x100, W0
00BBA4  608000     AND W1, W0, W0
00BBA6  E00000     CP0 W0
00BBA8  32FFFB     BRA Z, .L93
915:               
916:               }
00BBAA  FA8000     ULNK
00BBAC  060000     RETURN
917:               
918:               void UART2_SendBytes(uint8_t *byte, uint8_t startIndex, uint8_t cmdLen)
919:               {
00BBAE  FA0006     LNK #0x6
00BBB0  980710     MOV W0, [W14+2]
00BBB2  984741     MOV.B W1, [W14+4]
00BBB4  984752     MOV.B W2, [W14+5]
920:                   uint8_t i = 0;
00BBB6  EB4000     CLR.B W0
00BBB8  784F00     MOV.B W0, [W14]
921:                   for (i=startIndex; i< startIndex+cmdLen; i++)
00BBBA  9040CE     MOV.B [W14+4], W1
00BBBC  784F01     MOV.B W1, [W14]
00BBBE  37000D     BRA .L96
00BBD8  E84F1E     INC.B [W14], [W14]
00BBDA  FB809E     ZE [W14], W1
00BBDC  90404E     MOV.B [W14+4], W0
00BBDE  FB8100     ZE W0, W2
00BBE0  90405E     MOV.B [W14+5], W0
00BBE2  FB8000     ZE W0, W0
00BBE4  410000     ADD W2, W0, W0
00BBE6  508F80     SUB W1, W0, [W15]
00BBE8  35FFEB     BRA LT, .L100
922:                   {
923:                      while (U2STAbits.UTXBF){} //wait until at least one character 
00BBC0  000000     NOP
00BBC2  801D81     MOV U2STA, W1
00BBC4  202000     MOV #0x200, W0
00BBC6  608000     AND W1, W0, W0
00BBC8  E00000     CP0 W0
00BBCA  3AFFFB     BRA NZ, .L97
924:                       U2TXREG = byte[i];         //can be written to the transmit buffer 
00BBCC  FB801E     ZE [W14], W0
00BBCE  90009E     MOV [W14+2], W1
00BBD0  408000     ADD W1, W0, W0
00BBD2  784010     MOV.B [W0], W0
00BBD4  FB8000     ZE W0, W0
00BBD6  881D90     MOV W0, U2TXREG
925:                   }
926:                   //now we wait for transmit shift register to get empty
927:                   while (!U2STAbits.TRMT){}
00BBEA  000000     NOP
00BBEC  801D81     MOV U2STA, W1
00BBEE  201000     MOV #0x100, W0
00BBF0  608000     AND W1, W0, W0
00BBF2  E00000     CP0 W0
00BBF4  32FFFB     BRA Z, .L99
928:               }
00BBF6  FA8000     ULNK
00BBF8  060000     RETURN
929:               
930:               void UART2_SendByte(uint8_t byte)
931:               {
00BBFA  FA0004     LNK #0x4
00BBFC  984720     MOV.B W0, [W14+2]
932:                   uint16_t i = 0;
00BBFE  EB0000     CLR W0
00BC00  780F00     MOV W0, [W14]
933:                   while (U2STAbits.UTXBF){} //wait until at least one character 
00BC02  000000     NOP
00BC04  801D81     MOV U2STA, W1
00BC06  202000     MOV #0x200, W0
00BC08  608000     AND W1, W0, W0
00BC0A  E00000     CP0 W0
00BC0C  3AFFFB     BRA NZ, .L102
934:                   U2TXREG = byte;        //can be written to the transmit buffer 
00BC0E  90402E     MOV.B [W14+2], W0
00BC10  FB8000     ZE W0, W0
00BC12  881D90     MOV W0, U2TXREG
935:                   //now we wait for transmit shift register to get empty
936:                   while (!U2STAbits.TRMT && i < 5000)
00BC14  370004     BRA .L103
00BC1E  801D81     MOV U2STA, W1
00BC20  201000     MOV #0x100, W0
00BC22  608000     AND W1, W0, W0
00BC24  E00000     CP0 W0
00BC26  3A0004     BRA NZ, .L101
00BC28  213870     MOV #0x1387, W0
00BC2A  78009E     MOV [W14], W1
00BC2C  508F80     SUB W1, W0, [W15]
00BC2E  36FFF3     BRA LEU, .L105
937:                   {
938:                       __delay_us(1);
00BC16  200100     MOV #0x10, W0
00BC18  200001     MOV #0x0, W1
00BC1A  0709DB     RCALL ___delay32, .Letext0, .LFE18
939:                       i++;
00BC1C  E80F1E     INC [W14], [W14]
940:                   }
941:               }
00BC30  FA8000     ULNK
00BC32  060000     RETURN
942:               
943:               
944:               /*******************************************************************************
945:                               UART3 used for Digi WiFI Module
946:               *******************************************************************************/
947:               void UART3_Initialize(void)
948:               {  
00BC34  FA0000     LNK #0x0
949:                   // STSEL 1; IREN disabled; PDSEL 8N; UARTEN enabled; RTSMD disabled; 
950:                   // USIDL disabled; WAKE disabled; ABAUD disabled; LPBACK disabled; 
951:                   // BRGH enabled; URXINV disabled; UEN TX_RX; 
952:                  U3MODE = (0x8008 & ~(1<<15));  // disabling UARTEN bit   
00BC36  200080     MOV #0x8, W0
00BC38  881E20     MOV W0, U3MODE
953:                  // UTXISEL0 TX_ONE_CHAR; UTXINV disabled; OERR NO_ERROR_cleared; URXISEL RX_ONE_CHAR; UTXBRK COMPLETED; UTXEN disabled; ADDEN disabled; 
954:                  U3STA = 0x0000;
00BC3A  EF23C6     CLR U3STA
955:                  // BaudRate = 57600
956:                  U3BRG = BRGH_57600;
00BC3C  200440     MOV #0x44, W0
00BC3E  881E60     MOV W0, U3BRG
957:                  // ADMADDR 0; ADMMASK 0; 
958:                  U3ADMD = 0x0000;
00BC40  EF23CE     CLR U3ADMD
959:               
960:                   U3MODEbits.UARTEN = 1;  // enabling UART ON bit
00BC42  A8E3C5     BSET 0x3C5, #7
961:                   U3STAbits.UTXEN = 1; //enabling transmit
00BC44  A843C7     BSET 0x3C7, #2
962:               }
00BC46  FA8000     ULNK
00BC48  060000     RETURN
963:               
964:               /**
965:                * Pushes a single byte of data in TXREG
966:                * @param msg - byte
967:                */
968:               void UART3_SendByte(uint8_t msg)
969:               {
00BC4A  FA0002     LNK #0x2
00BC4C  784F00     MOV.B W0, [W14]
970:                   while (U3STAbits.UTXBF){} //wait until at least one character 
00BC4E  000000     NOP
00BC50  801E31     MOV U3STA, W1
00BC52  202000     MOV #0x200, W0
00BC54  608000     AND W1, W0, W0
00BC56  E00000     CP0 W0
00BC58  3AFFFB     BRA NZ, .L108
971:                   U3TXREG = msg;
00BC5A  FB801E     ZE [W14], W0
00BC5C  881E40     MOV W0, U3TXREG
972:                   while (!U3STAbits.TRMT){}
00BC5E  000000     NOP
00BC60  801E31     MOV U3STA, W1
00BC62  201000     MOV #0x100, W0
00BC64  608000     AND W1, W0, W0
00BC66  E00000     CP0 W0
00BC68  32FFFB     BRA Z, .L109
973:               }
00BC6A  FA8000     ULNK
00BC6C  060000     RETURN
974:               
975:               /**
976:                * Pushes a null terminated C string to TXREG
977:                * @param msg - pointer to the string that is null terminated
978:                */
979:               void UART3_SendString(char *msg)
980:               {
00BC6E  FA0004     LNK #0x4
00BC70  980710     MOV W0, [W14+2]
981:                   uint8_t msgLen=0;
00BC72  EB4000     CLR.B W0
00BC74  984710     MOV.B W0, [W14+1]
982:                   uint8_t i=0;
00BC76  EB4000     CLR.B W0
00BC78  784F00     MOV.B W0, [W14]
983:                   msgLen = strlen(msg);
00BC7A  90001E     MOV [W14+2], W0
00BC7C  07A92A     RCALL _strlen
00BC7E  984710     MOV.B W0, [W14+1]
984:                   for (i=0; i<= msgLen-1; i++){
00BC80  EB4000     CLR.B W0
00BC82  784F00     MOV.B W0, [W14]
00BC84  37000D     BRA .L111
00BC9E  E84F1E     INC.B [W14], [W14]
00BCA0  FB809E     ZE [W14], W1
00BCA2  90401E     MOV.B [W14+1], W0
00BCA4  FB8000     ZE W0, W0
00BCA6  E90000     DEC W0, W0
00BCA8  508F80     SUB W1, W0, [W15]
00BCAA  34FFED     BRA LE, .L115
985:                       while (U3STAbits.UTXBF){} //wait until at least one character 
00BC86  000000     NOP
00BC88  801E31     MOV U3STA, W1
00BC8A  202000     MOV #0x200, W0
00BC8C  608000     AND W1, W0, W0
00BC8E  E00000     CP0 W0
00BC90  3AFFFB     BRA NZ, .L112
986:                       U3TXREG = msg[i];         //can be written to the transmit buffer
00BC92  FB801E     ZE [W14], W0
00BC94  90009E     MOV [W14+2], W1
00BC96  408000     ADD W1, W0, W0
00BC98  784010     MOV.B [W0], W0
00BC9A  FB0000     SE W0, W0
00BC9C  881E40     MOV W0, U3TXREG
987:                   }
988:                   //now we wait for transmit shift register to get empty
989:                   while (!U3STAbits.TRMT) {}
00BCAC  000000     NOP
00BCAE  801E31     MOV U3STA, W1
00BCB0  201000     MOV #0x100, W0
00BCB2  608000     AND W1, W0, W0
00BCB4  E00000     CP0 W0
00BCB6  32FFFB     BRA Z, .L114
990:               }
00BCB8  FA8000     ULNK
00BCBA  060000     RETURN
991:               
992:               void UART3_SendBytes(uint8_t *byte, uint8_t startIndex, uint8_t cmdLen)
993:               {
00BCBC  FA0006     LNK #0x6
00BCBE  980710     MOV W0, [W14+2]
00BCC0  984741     MOV.B W1, [W14+4]
00BCC2  984752     MOV.B W2, [W14+5]
994:                   uint8_t i = 0;
00BCC4  EB4000     CLR.B W0
00BCC6  784F00     MOV.B W0, [W14]
995:                   for (i=startIndex; i< startIndex+cmdLen; i++)
00BCC8  9040CE     MOV.B [W14+4], W1
00BCCA  784F01     MOV.B W1, [W14]
00BCCC  37000D     BRA .L117
00BCE6  E84F1E     INC.B [W14], [W14]
00BCE8  FB809E     ZE [W14], W1
00BCEA  90404E     MOV.B [W14+4], W0
00BCEC  FB8100     ZE W0, W2
00BCEE  90405E     MOV.B [W14+5], W0
00BCF0  FB8000     ZE W0, W0
00BCF2  410000     ADD W2, W0, W0
00BCF4  508F80     SUB W1, W0, [W15]
00BCF6  35FFEB     BRA LT, .L121
996:                   {
997:                      while (U3STAbits.UTXBF){} //wait until at least one character 
00BCCE  000000     NOP
00BCD0  801E31     MOV U3STA, W1
00BCD2  202000     MOV #0x200, W0
00BCD4  608000     AND W1, W0, W0
00BCD6  E00000     CP0 W0
00BCD8  3AFFFB     BRA NZ, .L118
998:                       U3TXREG = byte[i];       //can be written to the transmit buffer 
00BCDA  FB801E     ZE [W14], W0
00BCDC  90009E     MOV [W14+2], W1
00BCDE  408000     ADD W1, W0, W0
00BCE0  784010     MOV.B [W0], W0
00BCE2  FB8000     ZE W0, W0
00BCE4  881E40     MOV W0, U3TXREG
999:                   }
1000:                  //now we wait for transmit shift register to get empty
1001:                  while (!U5STAbits.TRMT) {}
00BCF8  000000     NOP
00BCFA  801EF1     MOV U5STA, W1
00BCFC  201000     MOV #0x100, W0
00BCFE  608000     AND W1, W0, W0
00BD00  E00000     CP0 W0
00BD02  32FFFB     BRA Z, .L120
1002:              }
00BD04  FA8000     ULNK
00BD06  060000     RETURN
1003:              
1004:              void ADC1_Initialize (void)
1005:              {
00BD08  FA0000     LNK #0x0
1006:                  
1007:                 AD1CON1 = 0x8400; //ADON, Mode = 12bit, 
00BD0A  284000     MOV #0x8400, W0
00BD0C  883A30     MOV W0, AD1CON1
1008:                 //AD1CON2bits.PVCFG = 0x00; //VREF+ is VDD,  VREF- is VSS
1009:                 AD1CON2 = 0x0000;
00BD0E  EF2748     CLR AD1CON2
1010:                 AD1CON3 = 0x0A04; //TAD = 10
00BD10  20A040     MOV #0xA04, W0
00BD12  883A50     MOV W0, AD1CON3
1011:                 //AD1CON5bits.BGREQ = 1; //Band gap is enabled
1012:                 
1013:                 AD1CHS = 0x0000;// CH0SA AN0; CH0SB AN0; CH0NB AVSS; CH0NA AVSS;
00BD14  EF274C     CLR AD1CHS
1014:                 AD1CHITH = 0x0000;
00BD16  EF2756     CLR AD1CHITH
1015:                 AD1CSSH = 0x0000;
00BD18  EF274E     CLR AD1CSSH
1016:                 AD1CSSL = 0x0000;
00BD1A  EF2750     CLR AD1CSSL
1017:                 AD1CTMENH = 0x0000;
00BD1C  EF275A     CLR AD1CTMENH
1018:                 ANCFG = 0x0000;
00BD1E  EF22F4     CLR ANCFG
1019:                 
1020:                 AD1CON1bits.ADON=1; //enabling ADC module
00BD20  A8E747     BSET 0x747, #7
1021:              }
00BD22  FA8000     ULNK
00BD24  060000     RETURN
1022:              
1023:              uint16_t ADC1_ReadChannel(uint8_t ch)
1024:              {
00BD26  FA0004     LNK #0x4
00BD28  984720     MOV.B W0, [W14+2]
1025:                 uint16_t result16 = 0;
00BD2A  EB0000     CLR W0
00BD2C  780F00     MOV W0, [W14]
1026:                 AD1CHS =  ch;
00BD2E  90402E     MOV.B [W14+2], W0
00BD30  FB8000     ZE W0, W0
00BD32  883A60     MOV W0, AD1CHS
1027:                 AD1CON1bits.SAMP = 1; //initiating sampling
00BD34  A82746     BSET AD1CON1, #1
1028:                 __delay_us(100);
00BD36  206400     MOV #0x640, W0
00BD38  200001     MOV #0x0, W1
00BD3A  07094B     RCALL ___delay32, .Letext0, .LFE18
1029:                 AD1CON1bits.SAMP = 0; //end sampling, begin conversion
00BD3C  A92746     BCLR AD1CON1, #1
1030:                 Nop();
00BD3E  000000     NOP
1031:                 while (AD1CON1bits.DONE != 1){} //wait for done bit to go high
00BD40  000000     NOP
00BD42  803A30     MOV AD1CON1, W0
00BD44  600061     AND W0, #0x1, W0
00BD46  E00000     CP0 W0
00BD48  32FFFC     BRA Z, .L124
1032:                 Nop();
00BD4A  000000     NOP
1033:                 Nop();
00BD4C  000000     NOP
1034:                 result16 = ADC1BUF0;
00BD4E  803891     MOV ADC1BUF0, W1
00BD50  780F01     MOV W1, [W14]
1035:                 return result16;
00BD52  78001E     MOV [W14], W0
1036:              }
00BD54  FA8000     ULNK
00BD56  060000     RETURN
1037:              
1038:              
1039:              
1040:              //Cryptographic engine - currently used for random number generation
1041:              void CRYPTO_Initialize(void)
1042:              {
00BD58  FA0000     LNK #0x0
1043:                  CRYCONLbits.CRYON = 1;
00BD5A  A8E51D     BSET 0x51D, #7
1044:              }
00BD5C  FA8000     ULNK
00BD5E  060000     RETURN
1045:              
1046:              uint8_t CRYPTO_Get8BitRandomNumber(void)
1047:              {
00BD60  FA0002     LNK #0x2
1048:                  uint8_t rNumber = 0;
00BD62  EB4000     CLR.B W0
00BD64  784F00     MOV.B W0, [W14]
1049:                  
1050:                  CRYCONLbits.OPMOD = 0b1010;
00BD66  8028E1     MOV CRYCONL, W1
00BD68  2FF0F0     MOV #0xFF0F, W0
00BD6A  608080     AND W1, W0, W1
00BD6C  200A00     MOV #0xA0, W0
00BD6E  700001     IOR W0, W1, W0
00BD70  8828E0     MOV W0, CRYCONL
1051:                  CRYCONLbits.CRYGO = 1;
00BD72  A8051D     BSET 0x51D, #0
1052:                  asm("NOP");
00BD74  000000     NOP
1053:                  while (CRYCONLbits.CRYGO == 1)
00BD76  370001     BRA .L127
00BD7A  8028E1     MOV CRYCONL, W1
00BD7C  201000     MOV #0x100, W0
00BD7E  608000     AND W1, W0, W0
00BD80  E00000     CP0 W0
00BD82  3AFFFA     BRA NZ, .L128
1054:                  {
1055:                      asm("NOP");
00BD78  000000     NOP
1056:                  }
1057:                  rNumber = (uint8_t)(CRYTXTA);
00BD84  802A40     MOV CRYTXTA0, W0
00BD86  784F00     MOV.B W0, [W14]
1058:                  return rNumber;
00BD88  78401E     MOV.B [W14], W0
1059:              }
00BD8A  FA8000     ULNK
00BD8C  060000     RETURN
1060:              uint32_t ReadSerialNumber(void)
1061:              {
00BD8E  FA0004     LNK #0x4
1062:                  //SQTP number is stored at 0x02AF78 by the IPE programmer
1063:                  uint16_t word0 = 0;
00BD90  EB0000     CLR W0
00BD92  780F00     MOV W0, [W14]
1064:                  uint16_t word1 = 0;
00BD94  EB0000     CLR W0
00BD96  980710     MOV W0, [W14+2]
1065:                  
1066:                  TBLPAG = 0x0002; 
00BD98  200020     MOV #0x2, W0
00BD9A  8802A0     MOV W0, TBLPAG
1067:                  word0 = __builtin_tblrdl(0x02AF78);
00BD9C  2AF780     MOV #0xAF78, W0
00BD9E  BA0F10     TBLRDL [W0], [W14]
1068:                  word1 = __builtin_tblrdh(0x02AF78);
00BDA0  2AF780     MOV #0xAF78, W0
00BDA2  BA8010     TBLRDH [W0], W0
00BDA4  980710     MOV W0, [W14+2]
1069:                  return ( (uint32_t)word0<<16 | word1);
00BDA6  78001E     MOV [W14], W0
00BDA8  EB0080     CLR W1
00BDAA  DD01C0     SL W0, #0, W3
00BDAC  200002     MOV #0x0, W2
00BDAE  90001E     MOV [W14+2], W0
00BDB0  EB0080     CLR W1
00BDB2  710000     IOR W2, W0, W0
00BDB4  718081     IOR W3, W1, W1
1070:              }
00BDB6  FA8000     ULNK
00BDB8  060000     RETURN
---  C:/Users/pvan002/Box Sync/low_income_thermostats/lita_sw/R1/FRAM.c  --------------------------------
1:                 /*
2:                 ===========================================================================================
3:                 SOURCE FILE FRAM.c
4:                 PURPOSE Functions for Fujistsu Serial FRAM chips  **24BIT ADRESS SPACE**
5:                 AUTHOR Madhu Annapragada, Automation Research Group
6:                 DATE CREATED January, 20, 2011
7:                 REVISION: A                                  
8:                    CHANGES :NONE from Rev A
9:                                                                 
10:                                                                
11:                :REQUIREMENTS: 
12:                         1) SPI2 should be set up as Master with Low to high transitions
13:                         2) All functions here are passed the bank select line for cases where
14:                            there is more than one memory chip. Chip select lines are named
15:                            CS_MEM1, CS_MEM2 etc.
16:                
17:                ===========================================================================================*/
18:                
19:                #include <xc.h>
20:                #include "Main.h"
21:                #include "HAL.h"
22:                #include "FRAM.h"
23:                
24:                /**
25:                 * Sets the chip select line high or low 
26:                 * bank selects the memory chip to be accessed
27:                 * 
28:                 * @param HighOrLow 0 pulls cs low, 1 sets it high
29:                 * @param bank memory bank. starting from 0
30:                 */
31:                void FRAMSetChipSelect(uint8_t HighOrLow, uint8_t bank)
32:                {
00C474  FA0002     LNK #0x2
00C476  784F00     MOV.B W0, [W14]
00C478  984711     MOV.B W1, [W14+1]
33:                    switch (bank)
00C47A  90401E     MOV.B [W14+1], W0
00C47C  FB8000     ZE W0, W0
00C47E  E00000     CP0 W0
00C480  320003     BRA Z, .L3
00C482  500FE1     SUB W0, #0x1, [W15]
00C484  32000F     BRA Z, .L11
00C486  370007     BRA .L10
34:                    {
35:                        case 0:
36:                            if (HighOrLow == 0)
00C488  78401E     MOV.B [W14], W0
00C48A  E00400     CP0.B W0
00C48C  3A0002     BRA NZ, .L5
37:                            {
38:                                CS_MEM1_SetLow();
00C48E  A986B2     BCLR LATE, #4
39:                            }
40:                            else
41:                            {
42:                                CS_MEM1_SetHigh();
00C492  A886B2     BSET LATE, #4
43:                            }
44:                            break;
00C490  37000A     BRA .L1
00C494  370008     BRA .L1
45:                        case 1: //Not Used in LIT
46:                            if (HighOrLow == 0)
47:                            {
48:                               // CS_MEM2_SetLow();
49:                            }
50:                            else
51:                            {
52:                               // CS_MEM2_SetHigh();
53:                            }
54:                            break;
00C4A4  000000     NOP
55:                        default:
56:                            if (HighOrLow == 0)
00C496  78401E     MOV.B [W14], W0
00C498  E00400     CP0.B W0
00C49A  3A0002     BRA NZ, .L8
57:                            {
58:                                CS_MEM1_SetLow();
00C49C  A986B2     BCLR LATE, #4
59:                            }
60:                            else
61:                            {
62:                                CS_MEM1_SetHigh();
00C4A0  A886B2     BSET LATE, #4
63:                            }
64:                            break;
00C49E  370003     BRA .L1
00C4A2  370001     BRA .L1
65:                    }
66:                }
00C4A6  FA8000     ULNK
00C4A8  060000     RETURN
67:                
68:                /**
69:                 * USES SPI 1 bus - change as needed
70:                 * @param data
71:                 * @return 
72:                 */
73:                uint8_t  FramDataExchangeByte(uint8_t data)
74:                {
00C4AA  FA0004     LNK #0x4
00C4AC  984720     MOV.B W0, [W14+2]
75:                    uint8_t retval = 0;
00C4AE  EB4000     CLR.B W0
00C4B0  784F00     MOV.B W0, [W14]
76:                    retval = SPI1_Exchange8bit(data);
00C4B2  90402E     MOV.B [W14+2], W0
00C4B4  07FA73     RCALL SPI1_Exchange8bit
00C4B6  784F00     MOV.B W0, [W14]
77:                    return retval;
00C4B8  78401E     MOV.B [W14], W0
78:                }
00C4BA  FA8000     ULNK
00C4BC  060000     RETURN
79:                
80:                /**
81:                 *          READ STATUS REGISTER
82:                 * @param bank
83:                 * @return  byte with the value of the status register
84:                 */
85:                uint8_t FRAMReadStatusRegister(uint8_t bank)
86:                {
00C4BE  FA0004     LNK #0x4
00C4C0  984720     MOV.B W0, [W14+2]
87:                    uint8_t status = 0;
00C4C2  EB4000     CLR.B W0
00C4C4  784F00     MOV.B W0, [W14]
88:                    
89:                    FRAMSetChipSelect(0,bank);    
00C4C6  9040AE     MOV.B [W14+2], W1
00C4C8  EB4000     CLR.B W0
00C4CA  07FFD4     RCALL FRAMSetChipSelect
90:                    FramDataExchangeByte(RDSR);
00C4CC  B3C050     MOV.B #0x5, W0
00C4CE  07FFED     RCALL FramDataExchangeByte
91:                    status = FramDataExchangeByte(0);    
00C4D0  EB4000     CLR.B W0
00C4D2  07FFEB     RCALL FramDataExchangeByte
00C4D4  784F00     MOV.B W0, [W14]
92:                    FRAMSetChipSelect(1,bank);
00C4D6  9040AE     MOV.B [W14+2], W1
00C4D8  B3C010     MOV.B #0x1, W0
00C4DA  07FFCC     RCALL FRAMSetChipSelect
93:                    
94:                    return status;
00C4DC  78401E     MOV.B [W14], W0
95:                }
00C4DE  FA8000     ULNK
00C4E0  060000     RETURN
96:                
97:                void FRAMClearBlockProtect(uint8_t bank)
98:                {
00C4E2  FA0002     LNK #0x2
00C4E4  784F00     MOV.B W0, [W14]
99:                    FRAMSetChipSelect(0,bank);    
00C4E6  78409E     MOV.B [W14], W1
00C4E8  EB4000     CLR.B W0
00C4EA  07FFC4     RCALL FRAMSetChipSelect
100:                   FramDataExchangeByte(WRSR);
00C4EC  B3C010     MOV.B #0x1, W0
00C4EE  07FFDD     RCALL FramDataExchangeByte
101:                   FramDataExchangeByte(0);    
00C4F0  EB4000     CLR.B W0
00C4F2  07FFDB     RCALL FramDataExchangeByte
102:                   FRAMSetChipSelect(1,bank);
00C4F4  78409E     MOV.B [W14], W1
00C4F6  B3C010     MOV.B #0x1, W0
00C4F8  07FFBD     RCALL FRAMSetChipSelect
103:               }
00C4FA  FA8000     ULNK
00C4FC  060000     RETURN
104:               
105:               uint32_t FRAMReadID(uint8_t bank)
106:               {
00C4FE  FA000A     LNK #0xA
00C500  984F00     MOV.B W0, [W14+8]
107:                  uint8_t datalsb, data1, data2, datamsb;
108:                  uint32_t data = 0;
00C502  B80060     MUL.UU W0, #0, W0
00C504  BE8F00     MOV.D W0, [W14]
109:               
110:                  FRAMSetChipSelect(0,bank);
00C506  90488E     MOV.B [W14+8], W1
00C508  EB4000     CLR.B W0
00C50A  07FFB4     RCALL FRAMSetChipSelect
111:                  FramDataExchangeByte(RDID); //first the read op code   
00C50C  B3C9F0     MOV.B #0x9F, W0
00C50E  07FFCD     RCALL FramDataExchangeByte
112:                  datalsb = FramDataExchangeByte(0); //eight dummy bytes to generate the clock required to read in data
00C510  EB4000     CLR.B W0
00C512  07FFCB     RCALL FramDataExchangeByte
00C514  984740     MOV.B W0, [W14+4]
113:                  data1 = FramDataExchangeByte(0);
00C516  EB4000     CLR.B W0
00C518  07FFC8     RCALL FramDataExchangeByte
00C51A  984750     MOV.B W0, [W14+5]
114:                  data2 = FramDataExchangeByte(0);
00C51C  EB4000     CLR.B W0
00C51E  07FFC5     RCALL FramDataExchangeByte
00C520  984760     MOV.B W0, [W14+6]
115:                  datamsb = FramDataExchangeByte(0);
00C522  EB4000     CLR.B W0
00C524  07FFC2     RCALL FramDataExchangeByte
00C526  984770     MOV.B W0, [W14+7]
116:                  FRAMSetChipSelect(1,bank);
00C528  90488E     MOV.B [W14+8], W1
00C52A  B3C010     MOV.B #0x1, W0
00C52C  07FFA3     RCALL FRAMSetChipSelect
117:                  data = ((uint32_t)datamsb <<24) | ((uint32_t)data2 <<16) | ((uint32_t)data1 <<8) | datalsb;
00C52E  90407E     MOV.B [W14+7], W0
00C530  FB8000     ZE W0, W0
00C532  EB0080     CLR W1
00C534  DD01C8     SL W0, #8, W3
00C536  200002     MOV #0x0, W2
00C538  90406E     MOV.B [W14+6], W0
00C53A  FB8000     ZE W0, W0
00C53C  EB0080     CLR W1
00C53E  DD00C0     SL W0, #0, W1
00C540  200000     MOV #0x0, W0
00C542  710100     IOR W2, W0, W2
00C544  718181     IOR W3, W1, W3
00C546  90405E     MOV.B [W14+5], W0
00C548  FB8200     ZE W0, W4
00C54A  EB0280     CLR W5
00C54C  DD2848     SL W5, #8, W0
00C54E  DE20C8     LSR W4, #8, W1
00C550  700081     IOR W0, W1, W1
00C552  DD2048     SL W4, #8, W0
00C554  710100     IOR W2, W0, W2
00C556  718181     IOR W3, W1, W3
00C558  90404E     MOV.B [W14+4], W0
00C55A  FB8000     ZE W0, W0
00C55C  EB0080     CLR W1
00C55E  711F00     IOR W2, W0, [W14++]
00C560  719701     IOR W3, W1, [W14--]
118:                  return data;
00C562  BE001E     MOV.D [W14], W0
119:                   
120:               }
00C564  FA8000     ULNK
00C566  060000     RETURN
121:               void FRAMWriteEnable(uint8_t bank)
122:               {
00C568  FA0002     LNK #0x2
00C56A  784F00     MOV.B W0, [W14]
123:                  FRAMSetChipSelect(0,bank);
00C56C  78409E     MOV.B [W14], W1
00C56E  EB4000     CLR.B W0
00C570  07FF81     RCALL FRAMSetChipSelect
124:                  FramDataExchangeByte(WREN); //enable write mode
00C572  B3C060     MOV.B #0x6, W0
00C574  07FF9A     RCALL FramDataExchangeByte
125:                  FRAMSetChipSelect(1,bank);
00C576  78409E     MOV.B [W14], W1
00C578  B3C010     MOV.B #0x1, W0
00C57A  07FF7C     RCALL FRAMSetChipSelect
126:                   
127:               }
00C57C  FA8000     ULNK
00C57E  060000     RETURN
128:               
129:               /**
130:                * Puts device into sleep
131:                * Wake up is automatic on any high to low transition of the CS line
132:                * @param bank
133:                */
134:               void FRAMSleep(uint8_t bank)
135:               {
00C580  FA0002     LNK #0x2
00C582  784F00     MOV.B W0, [W14]
136:                   FRAMSetChipSelect(0,bank);
00C584  78409E     MOV.B [W14], W1
00C586  EB4000     CLR.B W0
00C588  07FF75     RCALL FRAMSetChipSelect
137:                   FramDataExchangeByte(SLEEP);
00C58A  B3CB90     MOV.B #0xB9, W0
00C58C  07FF8E     RCALL FramDataExchangeByte
138:                   FRAMSetChipSelect(1,bank);
00C58E  78409E     MOV.B [W14], W1
00C590  B3C010     MOV.B #0x1, W0
00C592  07FF70     RCALL FRAMSetChipSelect
139:               }
00C594  FA8000     ULNK
00C596  060000     RETURN
140:               
141:               /**
142:                *  Wake up the FRAM before doing any
143:                * read / writes 
144:                */
145:               void FRAMWake(uint8_t bank)
146:               {
00C598  FA0002     LNK #0x2
00C59A  784F00     MOV.B W0, [W14]
147:                   FRAMSetChipSelect(0,bank);
00C59C  78409E     MOV.B [W14], W1
00C59E  EB4000     CLR.B W0
00C5A0  07FF69     RCALL FRAMSetChipSelect
148:                   __delay_us(500);
00C5A2  21F400     MOV #0x1F40, W0
00C5A4  200001     MOV #0x0, W1
00C5A6  070515     RCALL ___delay32, .Letext0, .LFE18
149:                   FRAMSetChipSelect(1,bank);
00C5A8  78409E     MOV.B [W14], W1
00C5AA  B3C010     MOV.B #0x1, W0
00C5AC  07FF63     RCALL FRAMSetChipSelect
150:               }
00C5AE  FA8000     ULNK
00C5B0  060000     RETURN
151:               
152:               /*=========================================
153:                     Function: FRAM Write Byte 
154:               - writes a byte of data to the specified 
155:               address
156:               (24bit address - )
157:               ==========================================*/
158:               void FRAMWriteByte(uint8_t data, uint32_t address, uint8_t bank) 
159:               {
00C5B2  FA000C     LNK #0xC
00C5B4  984740     MOV.B W0, [W14+4]
00C5B6  980732     MOV W2, [W14+6]
00C5B8  980743     MOV W3, [W14+8]
00C5BA  984F21     MOV.B W1, [W14+10]
160:                  uint8_t byte2,byte1,byte0, status;
161:                  byte2 = (uint8_t)(address >>  16);
00C5BC  90003E     MOV [W14+6], W0
00C5BE  9000CE     MOV [W14+8], W1
00C5C0  DE0840     LSR W1, #0, W0
00C5C2  984710     MOV.B W0, [W14+1]
162:                  byte1 = (uint8_t)(address >>  8);
00C5C4  90003E     MOV [W14+6], W0
00C5C6  9000CE     MOV [W14+8], W1
00C5C8  DD0948     SL W1, #8, W2
00C5CA  DE0048     LSR W0, #8, W0
00C5CC  710000     IOR W2, W0, W0
00C5CE  DE08C8     LSR W1, #8, W1
00C5D0  984720     MOV.B W0, [W14+2]
163:                  byte0 = (uint8_t)(address);
00C5D2  90003E     MOV [W14+6], W0
00C5D4  984730     MOV.B W0, [W14+3]
164:                  
165:                  //enabling the write enable latch:
166:                  FRAMWriteEnable(bank); 
00C5D6  90482E     MOV.B [W14+10], W0
00C5D8  07FFC7     RCALL FRAMWriteEnable
167:                  
168:                  //checking on the state of the WEL bit in the status register:
169:                  status = FRAMReadStatusRegister(bank);
00C5DA  90482E     MOV.B [W14+10], W0
00C5DC  07FF70     RCALL FRAMReadStatusRegister
00C5DE  784F00     MOV.B W0, [W14]
170:                  while ((status & 2) != 2)
00C5E0  370012     BRA .L20
00C606  FB801E     ZE [W14], W0
00C608  600062     AND W0, #0x2, W0
00C60A  E00000     CP0 W0
00C60C  32FFEA     BRA Z, .L22
171:                  {
172:                      __delay_us(10);
00C5E2  200A00     MOV #0xA0, W0
00C5E4  200001     MOV #0x0, W1
00C5E6  0704F5     RCALL ___delay32, .Letext0, .LFE18
173:                      status = FRAMReadStatusRegister(bank);
00C5E8  90482E     MOV.B [W14+10], W0
00C5EA  07FF69     RCALL FRAMReadStatusRegister
00C5EC  784F00     MOV.B W0, [W14]
174:                      //checking to see if block protection is on and disabling it if it is:
175:                      if (((status & 4) == 4) || ((status & 8) == 8))
00C5EE  FB801E     ZE [W14], W0
00C5F0  600064     AND W0, #0x4, W0
00C5F2  E00000     CP0 W0
00C5F4  3A0004     BRA NZ, .L21
00C5F6  FB801E     ZE [W14], W0
00C5F8  600068     AND W0, #0x8, W0
00C5FA  E00000     CP0 W0
00C5FC  320004     BRA Z, .L20
176:                      {
177:                          FRAMClearBlockProtect(bank);
00C5FE  90482E     MOV.B [W14+10], W0
00C600  07FF70     RCALL FRAMClearBlockProtect
178:                          FRAMWriteEnable(bank);
00C602  90482E     MOV.B [W14+10], W0
00C604  07FFB1     RCALL FRAMWriteEnable
179:                      }
180:                  }
181:                  
182:                  FRAMSetChipSelect(0,bank);
00C60E  9048AE     MOV.B [W14+10], W1
00C610  EB4000     CLR.B W0
00C612  07FF30     RCALL FRAMSetChipSelect
183:                  FramDataExchangeByte(WRITE); //first the write op code
00C614  B3C020     MOV.B #0x2, W0
00C616  07FF49     RCALL FramDataExchangeByte
184:                  FramDataExchangeByte(byte2); //next the three address bytes - MSB first
00C618  90401E     MOV.B [W14+1], W0
00C61A  07FF47     RCALL FramDataExchangeByte
185:                  FramDataExchangeByte(byte1);
00C61C  90402E     MOV.B [W14+2], W0
00C61E  07FF45     RCALL FramDataExchangeByte
186:                  FramDataExchangeByte(byte0);
00C620  90403E     MOV.B [W14+3], W0
00C622  07FF43     RCALL FramDataExchangeByte
187:                  FramDataExchangeByte(data); //eight bytes of data
00C624  90404E     MOV.B [W14+4], W0
00C626  07FF41     RCALL FramDataExchangeByte
188:                  FRAMSetChipSelect(1,bank);
00C628  9048AE     MOV.B [W14+10], W1
00C62A  B3C010     MOV.B #0x1, W0
00C62C  07FF23     RCALL FRAMSetChipSelect
189:                  
190:                  return;
191:               }
00C62E  FA8000     ULNK
00C630  060000     RETURN
192:               
193:               /*=========================================
194:                     Function: FRAM Write Word
195:               - writes 2 bytes of data to the specified 
196:               address
197:               (24bit address)
198:               ==========================================*/
199:               void FRAMWriteWord(uint16_t data, uint32_t address, uint8_t bank) 
200:               {
00C632  FA000E     LNK #0xE
00C634  980730     MOV W0, [W14+6]
00C636  980742     MOV W2, [W14+8]
00C638  980753     MOV W3, [W14+10]
00C63A  984F41     MOV.B W1, [W14+12]
201:                  uint8_t byte2,byte1,byte0, status, temp;
202:                  byte2 = (uint8_t)(address >>  16);
00C63C  90004E     MOV [W14+8], W0
00C63E  9000DE     MOV [W14+10], W1
00C640  DE0840     LSR W1, #0, W0
00C642  984710     MOV.B W0, [W14+1]
203:                  byte1 = (uint8_t)(address >>  8);
00C644  90004E     MOV [W14+8], W0
00C646  9000DE     MOV [W14+10], W1
00C648  DD0948     SL W1, #8, W2
00C64A  DE0048     LSR W0, #8, W0
00C64C  710000     IOR W2, W0, W0
00C64E  DE08C8     LSR W1, #8, W1
00C650  984720     MOV.B W0, [W14+2]
204:                  byte0 = (uint8_t)(address);
00C652  90004E     MOV [W14+8], W0
00C654  984730     MOV.B W0, [W14+3]
205:                  
206:                  //enabling the write enable latch:
207:                   FRAMWriteEnable(bank);
00C656  90484E     MOV.B [W14+12], W0
00C658  07FF87     RCALL FRAMWriteEnable
208:                  
209:                  //checking on the state of the WEL bit in the status register:
210:                  status = FRAMReadStatusRegister(bank);
00C65A  90484E     MOV.B [W14+12], W0
00C65C  07FF30     RCALL FRAMReadStatusRegister
00C65E  784F00     MOV.B W0, [W14]
211:                  while ((status & 2) != 2)
00C660  37001E     BRA .L24
00C69E  FB801E     ZE [W14], W0
00C6A0  600062     AND W0, #0x2, W0
00C6A2  E00000     CP0 W0
00C6A4  32FFDE     BRA Z, .L28
212:                  {
213:                      //checking to see if block protection is on and disabling it if it is:
214:                      if (((status & 4) == 4) || ((status & 8) == 8))
00C662  FB801E     ZE [W14], W0
00C664  600064     AND W0, #0x4, W0
00C666  E00000     CP0 W0
00C668  3A0004     BRA NZ, .L25
00C66A  FB801E     ZE [W14], W0
00C66C  600068     AND W0, #0x8, W0
00C66E  E00000     CP0 W0
00C670  320004     BRA Z, .L26
215:                      {
216:                          FRAMClearBlockProtect(bank);
00C672  90484E     MOV.B [W14+12], W0
00C674  07FF36     RCALL FRAMClearBlockProtect
217:                          FRAMWriteEnable(bank);
00C676  90484E     MOV.B [W14+12], W0
00C678  07FF77     RCALL FRAMWriteEnable
218:                      }
219:                      __delay_us(10);
00C67A  200A00     MOV #0xA0, W0
00C67C  200001     MOV #0x0, W1
00C67E  0704A9     RCALL ___delay32, .Letext0, .LFE18
220:                      status = FRAMReadStatusRegister(bank);
00C680  90484E     MOV.B [W14+12], W0
00C682  07FF1D     RCALL FRAMReadStatusRegister
00C684  784F00     MOV.B W0, [W14]
221:                      //checking to see if block protection is on and disabling it if it is:
222:                      if (((status & 4) == 4) || ((status & 8) == 8))
00C686  FB801E     ZE [W14], W0
00C688  600064     AND W0, #0x4, W0
00C68A  E00000     CP0 W0
00C68C  3A0004     BRA NZ, .L27
00C68E  FB801E     ZE [W14], W0
00C690  600068     AND W0, #0x8, W0
00C692  E00000     CP0 W0
00C694  320004     BRA Z, .L24
223:                      {
224:                          FRAMClearBlockProtect(bank);
00C696  90484E     MOV.B [W14+12], W0
00C698  07FF24     RCALL FRAMClearBlockProtect
225:                          FRAMWriteEnable(bank);
00C69A  90484E     MOV.B [W14+12], W0
00C69C  07FF65     RCALL FRAMWriteEnable
226:                      }
227:                  }
228:                  
229:                  FRAMSetChipSelect(0,bank);
00C6A6  9048CE     MOV.B [W14+12], W1
00C6A8  EB4000     CLR.B W0
00C6AA  07FEE4     RCALL FRAMSetChipSelect
230:                  FramDataExchangeByte(WRITE); //first the write op code
00C6AC  B3C020     MOV.B #0x2, W0
00C6AE  07FEFD     RCALL FramDataExchangeByte
231:                  FramDataExchangeByte(byte2); //next the three address bytes - MSB first
00C6B0  90401E     MOV.B [W14+1], W0
00C6B2  07FEFB     RCALL FramDataExchangeByte
232:                  FramDataExchangeByte(byte1);
00C6B4  90402E     MOV.B [W14+2], W0
00C6B6  07FEF9     RCALL FramDataExchangeByte
233:                  FramDataExchangeByte(byte0);
00C6B8  90403E     MOV.B [W14+3], W0
00C6BA  07FEF7     RCALL FramDataExchangeByte
234:                  temp = (uint8_t)(data); //lsb first   
00C6BC  90003E     MOV [W14+6], W0
00C6BE  984740     MOV.B W0, [W14+4]
235:                  FramDataExchangeByte(temp); //eight bytes of data
00C6C0  90404E     MOV.B [W14+4], W0
00C6C2  07FEF3     RCALL FramDataExchangeByte
236:                  temp = (uint8_t)(data>>8); //msb  
00C6C4  90003E     MOV [W14+6], W0
00C6C6  DE0048     LSR W0, #8, W0
00C6C8  984740     MOV.B W0, [W14+4]
237:                  FramDataExchangeByte(temp); //eight bytes of data
00C6CA  90404E     MOV.B [W14+4], W0
00C6CC  07FEEE     RCALL FramDataExchangeByte
238:                  FRAMSetChipSelect(1,bank);
00C6CE  9048CE     MOV.B [W14+12], W1
00C6D0  B3C010     MOV.B #0x1, W0
00C6D2  07FED0     RCALL FRAMSetChipSelect
239:                  
240:                  return;
241:               }
00C6D4  FA8000     ULNK
00C6D6  060000     RETURN
242:               
243:               
244:               
245:               /*=========================================
246:                     Function: FRAM Write Long
247:               - writes 4 bytes of data to the specified 
248:               address
249:               (24bit address)
250:               ==========================================*/
251:               void FRAMWriteLong(uint32_t data, uint32_t address, uint8_t bank) 
252:               {
00C6D8  FA0010     LNK #0x10
00C6DA  980730     MOV W0, [W14+6]
00C6DC  980741     MOV W1, [W14+8]
00C6DE  980752     MOV W2, [W14+10]
00C6E0  980763     MOV W3, [W14+12]
00C6E2  984F64     MOV.B W4, [W14+14]
253:                  uint8_t byte2,byte1,byte0,status, temp;
254:                  byte2 = (uint8_t)(address >>  16);
00C6E4  90005E     MOV [W14+10], W0
00C6E6  9000EE     MOV [W14+12], W1
00C6E8  DE0840     LSR W1, #0, W0
00C6EA  984710     MOV.B W0, [W14+1]
255:                  byte1 = (uint8_t)(address >>  8);
00C6EC  90005E     MOV [W14+10], W0
00C6EE  9000EE     MOV [W14+12], W1
00C6F0  DD0948     SL W1, #8, W2
00C6F2  DE0048     LSR W0, #8, W0
00C6F4  710000     IOR W2, W0, W0
00C6F6  DE08C8     LSR W1, #8, W1
00C6F8  984720     MOV.B W0, [W14+2]
256:                  byte0 = (uint8_t)(address);
00C6FA  90005E     MOV [W14+10], W0
00C6FC  984730     MOV.B W0, [W14+3]
257:                  
258:                  //enabling the write enable latch:
259:                  FRAMWriteEnable(bank);
00C6FE  90486E     MOV.B [W14+14], W0
00C700  07FF33     RCALL FRAMWriteEnable
260:                  
261:                  //checking on the state of the WEL bit in the status register:
262:                  status = FRAMReadStatusRegister(bank);
00C702  90486E     MOV.B [W14+14], W0
00C704  07FEDC     RCALL FRAMReadStatusRegister
00C706  784F00     MOV.B W0, [W14]
263:                  while ((status & 2) != 2)
00C708  370012     BRA .L30
00C72E  FB801E     ZE [W14], W0
00C730  600062     AND W0, #0x2, W0
00C732  E00000     CP0 W0
00C734  32FFEA     BRA Z, .L32
264:                  {
265:                      __delay_us(10);
00C70A  200A00     MOV #0xA0, W0
00C70C  200001     MOV #0x0, W1
00C70E  070461     RCALL ___delay32, .Letext0, .LFE18
266:                      status = FRAMReadStatusRegister(bank);
00C710  90486E     MOV.B [W14+14], W0
00C712  07FED5     RCALL FRAMReadStatusRegister
00C714  784F00     MOV.B W0, [W14]
267:                      if (((status & 4) == 4) || ((status & 8) == 8))
00C716  FB801E     ZE [W14], W0
00C718  600064     AND W0, #0x4, W0
00C71A  E00000     CP0 W0
00C71C  3A0004     BRA NZ, .L31
00C71E  FB801E     ZE [W14], W0
00C720  600068     AND W0, #0x8, W0
00C722  E00000     CP0 W0
00C724  320004     BRA Z, .L30
268:                      {
269:                          FRAMClearBlockProtect(bank);
00C726  90486E     MOV.B [W14+14], W0
00C728  07FEDC     RCALL FRAMClearBlockProtect
270:                          FRAMWriteEnable(bank);
00C72A  90486E     MOV.B [W14+14], W0
00C72C  07FF1D     RCALL FRAMWriteEnable
271:                      }
272:                  }
273:                  
274:                  FRAMSetChipSelect(0,bank);
00C736  9048EE     MOV.B [W14+14], W1
00C738  EB4000     CLR.B W0
00C73A  07FE9C     RCALL FRAMSetChipSelect
275:                  FramDataExchangeByte(WRITE); //first the write op code
00C73C  B3C020     MOV.B #0x2, W0
00C73E  07FEB5     RCALL FramDataExchangeByte
276:                  FramDataExchangeByte(byte2); //next the two address bytes - MSB first
00C740  90401E     MOV.B [W14+1], W0
00C742  07FEB3     RCALL FramDataExchangeByte
277:                  FramDataExchangeByte(byte1);
00C744  90402E     MOV.B [W14+2], W0
00C746  07FEB1     RCALL FramDataExchangeByte
278:                  FramDataExchangeByte(byte0);
00C748  90403E     MOV.B [W14+3], W0
00C74A  07FEAF     RCALL FramDataExchangeByte
279:                  temp = (uint8_t)(data); //lsb first   
00C74C  90003E     MOV [W14+6], W0
00C74E  984740     MOV.B W0, [W14+4]
280:                  FramDataExchangeByte(temp); //eight bytes of data
00C750  90404E     MOV.B [W14+4], W0
00C752  07FEAB     RCALL FramDataExchangeByte
281:                  temp = (uint8_t)(data>>8);   
00C754  90003E     MOV [W14+6], W0
00C756  9000CE     MOV [W14+8], W1
00C758  DD0948     SL W1, #8, W2
00C75A  DE0048     LSR W0, #8, W0
00C75C  710000     IOR W2, W0, W0
00C75E  DE08C8     LSR W1, #8, W1
00C760  984740     MOV.B W0, [W14+4]
282:                  FramDataExchangeByte(temp); //eight bytes of data
00C762  90404E     MOV.B [W14+4], W0
00C764  07FEA2     RCALL FramDataExchangeByte
283:                  temp = (uint8_t)(data>>16);   
00C766  90003E     MOV [W14+6], W0
00C768  9000CE     MOV [W14+8], W1
00C76A  DE0840     LSR W1, #0, W0
00C76C  984740     MOV.B W0, [W14+4]
284:                  FramDataExchangeByte(temp); //eight bytes of data
00C76E  90404E     MOV.B [W14+4], W0
00C770  07FE9C     RCALL FramDataExchangeByte
285:                  temp = (uint8_t)(data>>24);   
00C772  90003E     MOV [W14+6], W0
00C774  9000CE     MOV [W14+8], W1
00C776  DE0848     LSR W1, #8, W0
00C778  984740     MOV.B W0, [W14+4]
286:                  FramDataExchangeByte(temp); //eight bytes of data
00C77A  90404E     MOV.B [W14+4], W0
00C77C  07FE96     RCALL FramDataExchangeByte
287:                  FRAMSetChipSelect(1,bank);
00C77E  9048EE     MOV.B [W14+14], W1
00C780  B3C010     MOV.B #0x1, W0
00C782  07FE78     RCALL FRAMSetChipSelect
288:                  return;
289:               }
00C784  FA8000     ULNK
00C786  060000     RETURN
290:               
291:               /*=========================================
292:                     Function: FRAM Write Long Long
293:               - writes 8 bytes of data to the specified 
294:               address
295:               (24bit address)
296:               ==========================================*/
297:               void FRAMWriteLongLong(uint64_t data, uint32_t address, uint8_t bank) 
298:               {
00C788  FA0014     LNK #0x14
00C78A  980730     MOV W0, [W14+6]
00C78C  980741     MOV W1, [W14+8]
00C78E  980752     MOV W2, [W14+10]
00C790  980763     MOV W3, [W14+12]
00C792  980774     MOV W4, [W14+14]
00C794  980F05     MOV W5, [W14+16]
00C796  985726     MOV.B W6, [W14+18]
299:                  uint8_t byte2,byte1,byte0,status, temp;
300:                  byte2 = (uint8_t)(address >>  16);
00C798  90007E     MOV [W14+14], W0
00C79A  90088E     MOV [W14+16], W1
00C79C  DE0840     LSR W1, #0, W0
00C79E  984710     MOV.B W0, [W14+1]
301:                  byte1 = (uint8_t)(address >>  8);
00C7A0  90007E     MOV [W14+14], W0
00C7A2  90088E     MOV [W14+16], W1
00C7A4  DD0948     SL W1, #8, W2
00C7A6  DE0048     LSR W0, #8, W0
00C7A8  710000     IOR W2, W0, W0
00C7AA  DE08C8     LSR W1, #8, W1
00C7AC  984720     MOV.B W0, [W14+2]
302:                  byte0 = (uint8_t)(address);
00C7AE  90007E     MOV [W14+14], W0
00C7B0  984730     MOV.B W0, [W14+3]
303:                  
304:                  //enabling the write enable latch:
305:                  FRAMWriteEnable(bank);
00C7B2  90502E     MOV.B [W14+18], W0
00C7B4  07FED9     RCALL FRAMWriteEnable
306:                  
307:                  //checking on the state of the WEL bit in the status register:
308:                  status = FRAMReadStatusRegister(bank);
00C7B6  90502E     MOV.B [W14+18], W0
00C7B8  07FE82     RCALL FRAMReadStatusRegister
00C7BA  784F00     MOV.B W0, [W14]
309:                  while ((status & 2) != 2)
00C7BC  370012     BRA .L34
00C7E2  FB801E     ZE [W14], W0
00C7E4  600062     AND W0, #0x2, W0
00C7E6  E00000     CP0 W0
00C7E8  32FFEA     BRA Z, .L36
310:                  {
311:                      __delay_us(10);
00C7BE  200A00     MOV #0xA0, W0
00C7C0  200001     MOV #0x0, W1
00C7C2  070407     RCALL ___delay32, .Letext0, .LFE18
312:                      status = FRAMReadStatusRegister(bank);
00C7C4  90502E     MOV.B [W14+18], W0
00C7C6  07FE7B     RCALL FRAMReadStatusRegister
00C7C8  784F00     MOV.B W0, [W14]
313:                      if (((status & 4) == 4) || ((status & 8) == 8))
00C7CA  FB801E     ZE [W14], W0
00C7CC  600064     AND W0, #0x4, W0
00C7CE  E00000     CP0 W0
00C7D0  3A0004     BRA NZ, .L35
00C7D2  FB801E     ZE [W14], W0
00C7D4  600068     AND W0, #0x8, W0
00C7D6  E00000     CP0 W0
00C7D8  320004     BRA Z, .L34
314:                      {
315:                          FRAMClearBlockProtect(bank);
00C7DA  90502E     MOV.B [W14+18], W0
00C7DC  07FE82     RCALL FRAMClearBlockProtect
316:                          FRAMWriteEnable(bank);
00C7DE  90502E     MOV.B [W14+18], W0
00C7E0  07FEC3     RCALL FRAMWriteEnable
317:                      }
318:                  }
319:                  
320:                  FRAMSetChipSelect(0,bank);
00C7EA  9050AE     MOV.B [W14+18], W1
00C7EC  EB4000     CLR.B W0
00C7EE  07FE42     RCALL FRAMSetChipSelect
321:                  FramDataExchangeByte(WRITE); //first the write op code
00C7F0  B3C020     MOV.B #0x2, W0
00C7F2  07FE5B     RCALL FramDataExchangeByte
322:                  FramDataExchangeByte(byte2); //next the two address bytes - MSB first
00C7F4  90401E     MOV.B [W14+1], W0
00C7F6  07FE59     RCALL FramDataExchangeByte
323:                  FramDataExchangeByte(byte1);
00C7F8  90402E     MOV.B [W14+2], W0
00C7FA  07FE57     RCALL FramDataExchangeByte
324:                  FramDataExchangeByte(byte0);
00C7FC  90403E     MOV.B [W14+3], W0
00C7FE  07FE55     RCALL FramDataExchangeByte
325:                  temp = (uint8_t)(data); //lsb first   
00C800  90003E     MOV [W14+6], W0
00C802  984740     MOV.B W0, [W14+4]
326:                  FramDataExchangeByte(temp); //byte 0
00C804  90404E     MOV.B [W14+4], W0
00C806  07FE51     RCALL FramDataExchangeByte
327:                  temp = (uint8_t)(data>>8);   
00C808  90003E     MOV [W14+6], W0
00C80A  9000CE     MOV [W14+8], W1
00C80C  90015E     MOV [W14+10], W2
00C80E  9001EE     MOV [W14+12], W3
00C810  DE0048     LSR W0, #8, W0
00C812  DD0A48     SL W1, #8, W4
00C814  720000     IOR W4, W0, W0
00C816  984740     MOV.B W0, [W14+4]
328:                  FramDataExchangeByte(temp); //byte 1
00C818  90404E     MOV.B [W14+4], W0
00C81A  07FE47     RCALL FramDataExchangeByte
329:                  temp = (uint8_t)(data>>16);   
00C81C  90003E     MOV [W14+6], W0
00C81E  9000CE     MOV [W14+8], W1
00C820  90015E     MOV [W14+10], W2
00C822  9001EE     MOV [W14+12], W3
00C824  780001     MOV W1, W0
00C826  984740     MOV.B W0, [W14+4]
330:                  FramDataExchangeByte(temp); //byte 2
00C828  90404E     MOV.B [W14+4], W0
00C82A  07FE3F     RCALL FramDataExchangeByte
331:                  temp = (uint8_t)(data>>24);   
00C82C  90003E     MOV [W14+6], W0
00C82E  9000CE     MOV [W14+8], W1
00C830  90015E     MOV [W14+10], W2
00C832  9001EE     MOV [W14+12], W3
00C834  DE0848     LSR W1, #8, W0
00C836  DD1248     SL W2, #8, W4
00C838  720000     IOR W4, W0, W0
00C83A  984740     MOV.B W0, [W14+4]
332:                  FramDataExchangeByte(temp); //byte 3
00C83C  90404E     MOV.B [W14+4], W0
00C83E  07FE35     RCALL FramDataExchangeByte
333:                  temp = (uint8_t)(data>>32);   
00C840  90003E     MOV [W14+6], W0
00C842  9000CE     MOV [W14+8], W1
00C844  90015E     MOV [W14+10], W2
00C846  9001EE     MOV [W14+12], W3
00C848  780002     MOV W2, W0
00C84A  984740     MOV.B W0, [W14+4]
334:                  FramDataExchangeByte(temp); //byte 4
00C84C  90404E     MOV.B [W14+4], W0
00C84E  07FE2D     RCALL FramDataExchangeByte
335:                  temp = (uint8_t)(data>>40);   
00C850  90003E     MOV [W14+6], W0
00C852  9000CE     MOV [W14+8], W1
00C854  90015E     MOV [W14+10], W2
00C856  9001EE     MOV [W14+12], W3
00C858  DE1048     LSR W2, #8, W0
00C85A  DD1A48     SL W3, #8, W4
00C85C  720000     IOR W4, W0, W0
00C85E  984740     MOV.B W0, [W14+4]
336:                  FramDataExchangeByte(temp); //byte 5
00C860  90404E     MOV.B [W14+4], W0
00C862  07FE23     RCALL FramDataExchangeByte
337:                  temp = (uint8_t)(data>>48);   
00C864  90003E     MOV [W14+6], W0
00C866  9000CE     MOV [W14+8], W1
00C868  90015E     MOV [W14+10], W2
00C86A  9001EE     MOV [W14+12], W3
00C86C  780003     MOV W3, W0
00C86E  984740     MOV.B W0, [W14+4]
338:                  FramDataExchangeByte(temp); //byte 6
00C870  90404E     MOV.B [W14+4], W0
00C872  07FE1B     RCALL FramDataExchangeByte
339:                  temp = (uint8_t)(data>>56);   
00C874  90003E     MOV [W14+6], W0
00C876  9000CE     MOV [W14+8], W1
00C878  90015E     MOV [W14+10], W2
00C87A  9001EE     MOV [W14+12], W3
00C87C  DE1848     LSR W3, #8, W0
00C87E  984740     MOV.B W0, [W14+4]
340:                  FramDataExchangeByte(temp); //byte 7
00C880  90404E     MOV.B [W14+4], W0
00C882  07FE13     RCALL FramDataExchangeByte
341:                  FRAMSetChipSelect(1,bank);
00C884  9050AE     MOV.B [W14+18], W1
00C886  B3C010     MOV.B #0x1, W0
00C888  07FDF5     RCALL FRAMSetChipSelect
342:                  return;
343:               }
00C88A  FA8000     ULNK
00C88C  060000     RETURN
344:               
345:               /*=========================================
346:                     Function: FRAM read
347:               - returns a byte of data from the specified 
348:               address
349:               (24bit address)
350:               ==========================================*/
351:               uint8_t FRAMReadByte(uint32_t address, uint8_t bank) 
352:               {
00C88E  FA000A     LNK #0xA
00C890  980720     MOV W0, [W14+4]
00C892  980731     MOV W1, [W14+6]
00C894  984F02     MOV.B W2, [W14+8]
353:                  uint8_t byte2,byte1,byte0, data;
354:                  byte2 = (uint8_t)(address >>  16);
00C896  90002E     MOV [W14+4], W0
00C898  9000BE     MOV [W14+6], W1
00C89A  DE0840     LSR W1, #0, W0
00C89C  784F00     MOV.B W0, [W14]
355:                  byte1 = (uint8_t)(address >>  8);
00C89E  90002E     MOV [W14+4], W0
00C8A0  9000BE     MOV [W14+6], W1
00C8A2  DD0948     SL W1, #8, W2
00C8A4  DE0048     LSR W0, #8, W0
00C8A6  710000     IOR W2, W0, W0
00C8A8  DE08C8     LSR W1, #8, W1
00C8AA  984710     MOV.B W0, [W14+1]
356:                  byte0 = (uint8_t)(address);
00C8AC  90002E     MOV [W14+4], W0
00C8AE  984720     MOV.B W0, [W14+2]
357:                  
358:                  FRAMSetChipSelect(0,bank);
00C8B0  90488E     MOV.B [W14+8], W1
00C8B2  EB4000     CLR.B W0
00C8B4  07FDDF     RCALL FRAMSetChipSelect
359:                  FramDataExchangeByte(READ); //first the read op code
00C8B6  B3C030     MOV.B #0x3, W0
00C8B8  07FDF8     RCALL FramDataExchangeByte
360:                  FramDataExchangeByte(byte2); //next the three address bytes - MSB first
00C8BA  78401E     MOV.B [W14], W0
00C8BC  07FDF6     RCALL FramDataExchangeByte
361:                  FramDataExchangeByte(byte1);
00C8BE  90401E     MOV.B [W14+1], W0
00C8C0  07FDF4     RCALL FramDataExchangeByte
362:                  FramDataExchangeByte(byte0);
00C8C2  90402E     MOV.B [W14+2], W0
00C8C4  07FDF2     RCALL FramDataExchangeByte
363:                  data = FramDataExchangeByte(0); //eight dummy bytes to generate the clock required to read in data
00C8C6  EB4000     CLR.B W0
00C8C8  07FDF0     RCALL FramDataExchangeByte
00C8CA  984730     MOV.B W0, [W14+3]
364:                  FRAMSetChipSelect(1,bank);
00C8CC  90488E     MOV.B [W14+8], W1
00C8CE  B3C010     MOV.B #0x1, W0
00C8D0  07FDD1     RCALL FRAMSetChipSelect
365:                  return data;
00C8D2  90403E     MOV.B [W14+3], W0
366:               }
00C8D4  FA8000     ULNK
00C8D6  060000     RETURN
367:               
368:               /*=========================================
369:                     Function: FRAM read word
370:               - returns two bytes of data from the specified 
371:               address
372:               (24bit address)
373:               ==========================================*/
374:               uint16_t FRAMReadWord(uint32_t address, uint8_t bank) 
375:               {
00C8D8  FA000E     LNK #0xE
00C8DA  980740     MOV W0, [W14+8]
00C8DC  980751     MOV W1, [W14+10]
00C8DE  984F42     MOV.B W2, [W14+12]
376:                  uint8_t byte2,byte1,byte0,datalsb, datamsb;
377:                  uint16_t data = 0;
00C8E0  EB0000     CLR W0
00C8E2  780F00     MOV W0, [W14]
378:                  byte2 = (uint8_t)(address >>  16);
00C8E4  90004E     MOV [W14+8], W0
00C8E6  9000DE     MOV [W14+10], W1
00C8E8  DE0840     LSR W1, #0, W0
00C8EA  984720     MOV.B W0, [W14+2]
379:                  byte1 = (uint8_t)(address >>  8);
00C8EC  90004E     MOV [W14+8], W0
00C8EE  9000DE     MOV [W14+10], W1
00C8F0  DD0948     SL W1, #8, W2
00C8F2  DE0048     LSR W0, #8, W0
00C8F4  710000     IOR W2, W0, W0
00C8F6  DE08C8     LSR W1, #8, W1
00C8F8  984730     MOV.B W0, [W14+3]
380:                  byte0 = (uint8_t)(address);
00C8FA  90004E     MOV [W14+8], W0
00C8FC  984740     MOV.B W0, [W14+4]
381:                  
382:                  FRAMSetChipSelect(0,bank);
00C8FE  9048CE     MOV.B [W14+12], W1
00C900  EB4000     CLR.B W0
00C902  07FDB8     RCALL FRAMSetChipSelect
383:                  FramDataExchangeByte(READ); //first the read op code
00C904  B3C030     MOV.B #0x3, W0
00C906  07FDD1     RCALL FramDataExchangeByte
384:                  FramDataExchangeByte(byte2); //next the three address bytes - MSB first
00C908  90402E     MOV.B [W14+2], W0
00C90A  07FDCF     RCALL FramDataExchangeByte
385:                  FramDataExchangeByte(byte1);
00C90C  90403E     MOV.B [W14+3], W0
00C90E  07FDCD     RCALL FramDataExchangeByte
386:                  FramDataExchangeByte(byte0);
00C910  90404E     MOV.B [W14+4], W0
00C912  07FDCB     RCALL FramDataExchangeByte
387:                  datalsb = FramDataExchangeByte(0); //eight dummy bytes to generate the clock required to read in data
00C914  EB4000     CLR.B W0
00C916  07FDC9     RCALL FramDataExchangeByte
00C918  984750     MOV.B W0, [W14+5]
388:                  datamsb = FramDataExchangeByte(0);
00C91A  EB4000     CLR.B W0
00C91C  07FDC6     RCALL FramDataExchangeByte
00C91E  984760     MOV.B W0, [W14+6]
389:                  FRAMSetChipSelect(1,bank);
00C920  9048CE     MOV.B [W14+12], W1
00C922  B3C010     MOV.B #0x1, W0
00C924  07FDA7     RCALL FRAMSetChipSelect
390:                  data = (uint16_t)datamsb <<8 | datalsb;
00C926  90406E     MOV.B [W14+6], W0
00C928  FB8000     ZE W0, W0
00C92A  DD00C8     SL W0, #8, W1
00C92C  90405E     MOV.B [W14+5], W0
00C92E  FB8000     ZE W0, W0
00C930  708F00     IOR W1, W0, [W14]
391:                  return data;
00C932  78001E     MOV [W14], W0
392:               }
00C934  FA8000     ULNK
00C936  060000     RETURN
393:               
394:               /*=========================================
395:                     Function: FRAM read long
396:               - returns four bytes of data from the specified 
397:               address
398:               (24bit address)
399:               ==========================================*/
400:               uint32_t FRAMReadLong(uint32_t address, uint8_t bank) 
401:               {
00C938  FA0012     LNK #0x12
00C93A  980760     MOV W0, [W14+12]
00C93C  980771     MOV W1, [W14+14]
00C93E  985702     MOV.B W2, [W14+16]
402:                  uint8_t byte2,byte1,byte0, datalsb, data1, data2, datamsb;
403:                  uint32_t data = 0;
00C940  B80060     MUL.UU W0, #0, W0
00C942  BE8F00     MOV.D W0, [W14]
404:                  
405:                  byte2 = (uint8_t)(address >>  16);
00C944  90006E     MOV [W14+12], W0
00C946  9000FE     MOV [W14+14], W1
00C948  DE0840     LSR W1, #0, W0
00C94A  984740     MOV.B W0, [W14+4]
406:                  byte1 = (uint8_t)(address >>  8);
00C94C  90006E     MOV [W14+12], W0
00C94E  9000FE     MOV [W14+14], W1
00C950  DD0948     SL W1, #8, W2
00C952  DE0048     LSR W0, #8, W0
00C954  710000     IOR W2, W0, W0
00C956  DE08C8     LSR W1, #8, W1
00C958  984750     MOV.B W0, [W14+5]
407:                  byte0 = (uint8_t)(address);
00C95A  90006E     MOV [W14+12], W0
00C95C  984760     MOV.B W0, [W14+6]
408:                  
409:                  FRAMSetChipSelect(0,bank);
00C95E  90508E     MOV.B [W14+16], W1
00C960  EB4000     CLR.B W0
00C962  07FD88     RCALL FRAMSetChipSelect
410:                  FramDataExchangeByte(READ); //first the read op code
00C964  B3C030     MOV.B #0x3, W0
00C966  07FDA1     RCALL FramDataExchangeByte
411:                  FramDataExchangeByte(byte2); //next the three address bytes - MSB first
00C968  90404E     MOV.B [W14+4], W0
00C96A  07FD9F     RCALL FramDataExchangeByte
412:                  FramDataExchangeByte(byte1);
00C96C  90405E     MOV.B [W14+5], W0
00C96E  07FD9D     RCALL FramDataExchangeByte
413:                  FramDataExchangeByte(byte0);
00C970  90406E     MOV.B [W14+6], W0
00C972  07FD9B     RCALL FramDataExchangeByte
414:                  datalsb = FramDataExchangeByte(0); //eight dummy bytes to generate the clock required to read in data
00C974  EB4000     CLR.B W0
00C976  07FD99     RCALL FramDataExchangeByte
00C978  984770     MOV.B W0, [W14+7]
415:                  data1 = FramDataExchangeByte(0);
00C97A  EB4000     CLR.B W0
00C97C  07FD96     RCALL FramDataExchangeByte
00C97E  984F00     MOV.B W0, [W14+8]
416:                  data2 = FramDataExchangeByte(0);
00C980  EB4000     CLR.B W0
00C982  07FD93     RCALL FramDataExchangeByte
00C984  984F10     MOV.B W0, [W14+9]
417:                  datamsb = FramDataExchangeByte(0);
00C986  EB4000     CLR.B W0
00C988  07FD90     RCALL FramDataExchangeByte
00C98A  984F20     MOV.B W0, [W14+10]
418:                  FRAMSetChipSelect(1,bank);
00C98C  90508E     MOV.B [W14+16], W1
00C98E  B3C010     MOV.B #0x1, W0
00C990  07FD71     RCALL FRAMSetChipSelect
419:                  data = ((uint32_t)datamsb <<24) | ((uint32_t)data2 <<16) | ((uint32_t)data1 <<8) | datalsb;
00C992  90482E     MOV.B [W14+10], W0
00C994  FB8000     ZE W0, W0
00C996  EB0080     CLR W1
00C998  DD01C8     SL W0, #8, W3
00C99A  200002     MOV #0x0, W2
00C99C  90481E     MOV.B [W14+9], W0
00C99E  FB8000     ZE W0, W0
00C9A0  EB0080     CLR W1
00C9A2  DD00C0     SL W0, #0, W1
00C9A4  200000     MOV #0x0, W0
00C9A6  710100     IOR W2, W0, W2
00C9A8  718181     IOR W3, W1, W3
00C9AA  90480E     MOV.B [W14+8], W0
00C9AC  FB8200     ZE W0, W4
00C9AE  EB0280     CLR W5
00C9B0  DD2848     SL W5, #8, W0
00C9B2  DE20C8     LSR W4, #8, W1
00C9B4  700081     IOR W0, W1, W1
00C9B6  DD2048     SL W4, #8, W0
00C9B8  710100     IOR W2, W0, W2
00C9BA  718181     IOR W3, W1, W3
00C9BC  90407E     MOV.B [W14+7], W0
00C9BE  FB8000     ZE W0, W0
00C9C0  EB0080     CLR W1
00C9C2  711F00     IOR W2, W0, [W14++]
00C9C4  719701     IOR W3, W1, [W14--]
420:                  return data;
00C9C6  BE001E     MOV.D [W14], W0
421:               }
00C9C8  FA8000     ULNK
00C9CA  060000     RETURN
422:               
423:               /*=========================================
424:                     Function: FRAM read long long
425:               - returns eight bytes of data from the specified 
426:               address
427:               (24bit address)
428:               ==========================================*/
429:               uint64_t FRAMReadLongLong(uint32_t address, uint8_t bank) 
430:               {
00C9CC  FA001A     LNK #0x1A
00C9CE  BE9F88     MOV.D W8, [W15++]
00C9D0  BE9F8A     MOV.D W10, [W15++]
00C9D2  980F20     MOV W0, [W14+20]
00C9D4  980F31     MOV W1, [W14+22]
00C9D6  985F02     MOV.B W2, [W14+24]
431:                  uint8_t byte2,byte1,byte0, datalsb, data1, data2, data3, data4, data5, data6, datamsb;
432:                  uint64_t data = 0;
00C9D8  B80060     MUL.UU W0, #0, W0
00C9DA  B81160     MUL.UU W2, #0, W2
00C9DC  BE9F00     MOV.D W0, [W14++]
00C9DE  BE9702     MOV.D W2, [W14--]
433:                  
434:                  byte2 = (uint8_t)(address >>  16);
00C9E0  90082E     MOV [W14+20], W0
00C9E2  9008BE     MOV [W14+22], W1
00C9E4  DE0840     LSR W1, #0, W0
00C9E6  984F00     MOV.B W0, [W14+8]
435:                  byte1 = (uint8_t)(address >>  8);
00C9E8  90082E     MOV [W14+20], W0
00C9EA  9008BE     MOV [W14+22], W1
00C9EC  DD0948     SL W1, #8, W2
00C9EE  DE0048     LSR W0, #8, W0
00C9F0  710000     IOR W2, W0, W0
00C9F2  DE08C8     LSR W1, #8, W1
00C9F4  984F10     MOV.B W0, [W14+9]
436:                  byte0 = (uint8_t)(address);
00C9F6  90082E     MOV [W14+20], W0
00C9F8  984F20     MOV.B W0, [W14+10]
437:                  
438:                  FRAMSetChipSelect(0,bank);
00C9FA  90588E     MOV.B [W14+24], W1
00C9FC  EB4000     CLR.B W0
00C9FE  07FD3A     RCALL FRAMSetChipSelect
439:                  FramDataExchangeByte(READ); //first the read op code
00CA00  B3C030     MOV.B #0x3, W0
00CA02  07FD53     RCALL FramDataExchangeByte
440:                  FramDataExchangeByte(byte2); //next the three address bytes - MSB first
00CA04  90480E     MOV.B [W14+8], W0
00CA06  07FD51     RCALL FramDataExchangeByte
441:                  FramDataExchangeByte(byte1);
00CA08  90481E     MOV.B [W14+9], W0
00CA0A  07FD4F     RCALL FramDataExchangeByte
442:                  FramDataExchangeByte(byte0);
00CA0C  90482E     MOV.B [W14+10], W0
00CA0E  07FD4D     RCALL FramDataExchangeByte
443:                  datalsb = FramDataExchangeByte(0); //eight dummy bytes to generate the clock required to read in data
00CA10  EB4000     CLR.B W0
00CA12  07FD4B     RCALL FramDataExchangeByte
00CA14  984F30     MOV.B W0, [W14+11]
444:                  data1 = FramDataExchangeByte(0);
00CA16  EB4000     CLR.B W0
00CA18  07FD48     RCALL FramDataExchangeByte
00CA1A  984F40     MOV.B W0, [W14+12]
445:                  data2 = FramDataExchangeByte(0);
00CA1C  EB4000     CLR.B W0
00CA1E  07FD45     RCALL FramDataExchangeByte
00CA20  984F50     MOV.B W0, [W14+13]
446:                  data3 = FramDataExchangeByte(0);
00CA22  EB4000     CLR.B W0
00CA24  07FD42     RCALL FramDataExchangeByte
00CA26  984F60     MOV.B W0, [W14+14]
447:                  data4 = FramDataExchangeByte(0);
00CA28  EB4000     CLR.B W0
00CA2A  07FD3F     RCALL FramDataExchangeByte
00CA2C  984F70     MOV.B W0, [W14+15]
448:                  data5 = FramDataExchangeByte(0);
00CA2E  EB4000     CLR.B W0
00CA30  07FD3C     RCALL FramDataExchangeByte
00CA32  985700     MOV.B W0, [W14+16]
449:                  data6 = FramDataExchangeByte(0);
00CA34  EB4000     CLR.B W0
00CA36  07FD39     RCALL FramDataExchangeByte
00CA38  985710     MOV.B W0, [W14+17]
450:                  datamsb = FramDataExchangeByte(0);
00CA3A  EB4000     CLR.B W0
00CA3C  07FD36     RCALL FramDataExchangeByte
00CA3E  985720     MOV.B W0, [W14+18]
451:                  FRAMSetChipSelect(1,bank);
00CA40  90588E     MOV.B [W14+24], W1
00CA42  B3C010     MOV.B #0x1, W0
00CA44  07FD17     RCALL FRAMSetChipSelect
452:                  data = ((uint64_t)datamsb <<56) | ((uint64_t)data6 <<48) | ((uint64_t)data5 <<40) |
00CA46  90502E     MOV.B [W14+18], W0
00CA48  FB8000     ZE W0, W0
00CA4A  EB0080     CLR W1
00CA4C  B81160     MUL.UU W2, #0, W2
00CA4E  BE0302     MOV.D W2, W6
00CA50  BE0200     MOV.D W0, W4
00CA52  DD23C8     SL W4, #8, W7
00CA54  EB0300     CLR W6
00CA56  B82260     MUL.UU W4, #0, W4
00CA58  90501E     MOV.B [W14+17], W0
00CA5A  FB8000     ZE W0, W0
00CA5C  EB0080     CLR W1
00CA5E  B81160     MUL.UU W2, #0, W2
00CA60  780180     MOV W0, W3
00CA62  EB0100     CLR W2
00CA64  B80060     MUL.UU W0, #0, W0
00CA66  720400     IOR W4, W0, W8
00CA68  728481     IOR W5, W1, W9
00CA6A  730502     IOR W6, W2, W10
00CA6C  738583     IOR W7, W3, W11
00CA6E  90500E     MOV.B [W14+16], W0
00CA70  FB8000     ZE W0, W0
00CA72  EB0080     CLR W1
00CA74  B81160     MUL.UU W2, #0, W2
00CA76  DD09C8     SL W1, #8, W3
00CA78  DE0248     LSR W0, #8, W4
00CA7A  720183     IOR W4, W3, W3
00CA7C  DD0148     SL W0, #8, W2
00CA7E  B80060     MUL.UU W0, #0, W0
00CA80  740200     IOR W8, W0, W4
00CA82  748281     IOR W9, W1, W5
00CA84  750302     IOR W10, W2, W6
00CA86  758383     IOR W11, W3, W7
00CA94  720400     IOR W4, W0, W8
00CA96  728481     IOR W5, W1, W9
00CA98  730502     IOR W6, W2, W10
00CA9A  738583     IOR W7, W3, W11
00CB00  721F00     IOR W4, W0, [W14++]
00CB02  729F01     IOR W5, W1, [W14++]
00CB04  731F02     IOR W6, W2, [W14++]
00CB06  738F03     IOR W7, W3, [W14]
00CB08  B1006E     SUB #0x6, W14
453:                          ((uint64_t)data4<<32) | ((uint64_t)data3 <<24) | ((uint64_t)data2 <<16) | 
00CA88  90487E     MOV.B [W14+15], W0
00CA8A  FB8000     ZE W0, W0
00CA8C  EB0080     CLR W1
00CA8E  B81160     MUL.UU W2, #0, W2
00CA90  BE0100     MOV.D W0, W2
00CA92  B80060     MUL.UU W0, #0, W0
00CA9C  90486E     MOV.B [W14+14], W0
00CA9E  FB8000     ZE W0, W0
00CAA0  EB0080     CLR W1
00CAA2  B81160     MUL.UU W2, #0, W2
00CAA4  DD11C8     SL W2, #8, W3
00CAA6  DE0A48     LSR W1, #8, W4
00CAA8  720183     IOR W4, W3, W3
00CAAA  DD0948     SL W1, #8, W2
00CAAC  DE0248     LSR W0, #8, W4
00CAAE  720102     IOR W4, W2, W2
00CAB0  DD00C8     SL W0, #8, W1
00CAB2  EB0000     CLR W0
00CAB4  740200     IOR W8, W0, W4
00CAB6  748281     IOR W9, W1, W5
00CAB8  750302     IOR W10, W2, W6
00CABA  758383     IOR W11, W3, W7
00CABC  90485E     MOV.B [W14+13], W0
00CABE  FB8000     ZE W0, W0
00CAC0  EB0080     CLR W1
00CAC2  B81160     MUL.UU W2, #0, W2
00CAC4  780182     MOV W2, W3
00CAC6  780101     MOV W1, W2
00CAC8  780080     MOV W0, W1
00CACA  EB0000     CLR W0
00CACC  720400     IOR W4, W0, W8
00CACE  728481     IOR W5, W1, W9
00CAD0  730502     IOR W6, W2, W10
00CAD2  738583     IOR W7, W3, W11
00CAF0  740200     IOR W8, W0, W4
00CAF2  748281     IOR W9, W1, W5
00CAF4  750302     IOR W10, W2, W6
00CAF6  758383     IOR W11, W3, W7
454:                          ((uint64_t)data1 <<8) | datalsb;
00CAD4  90484E     MOV.B [W14+12], W0
00CAD6  FB8000     ZE W0, W0
00CAD8  EB0080     CLR W1
00CADA  B81160     MUL.UU W2, #0, W2
00CADC  DD19C8     SL W3, #8, W3
00CADE  DE1248     LSR W2, #8, W4
00CAE0  720183     IOR W4, W3, W3
00CAE2  DD1148     SL W2, #8, W2
00CAE4  DE0A48     LSR W1, #8, W4
00CAE6  720102     IOR W4, W2, W2
00CAE8  DD08C8     SL W1, #8, W1
00CAEA  DE0248     LSR W0, #8, W4
00CAEC  720081     IOR W4, W1, W1
00CAEE  DD0048     SL W0, #8, W0
00CAF8  90483E     MOV.B [W14+11], W0
00CAFA  FB8000     ZE W0, W0
00CAFC  EB0080     CLR W1
00CAFE  B81160     MUL.UU W2, #0, W2
455:                  return data;
00CB0A  BE003E     MOV.D [W14++], W0
00CB0C  BE012E     MOV.D [W14--], W2
456:               }
00CB0E  BE054F     MOV.D [--W15], W10
00CB10  BE044F     MOV.D [--W15], W8
00CB12  FA8000     ULNK
00CB14  060000     RETURN
457:               
---  C:/Users/pvan002/Box Sync/low_income_thermostats/lita_sw/R1/BME680.c  ------------------------------
1:                 /**\mainpage
2:                  * Copyright (C) 2017 - 2018 Bosch Sensortec GmbH
3:                  *
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions are met:
6:                  *
7:                  * Redistributions of source code must retain the above copyright
8:                  * notice, this list of conditions and the following disclaimer.
9:                  *
10:                 * Redistributions in binary form must reproduce the above copyright
11:                 * notice, this list of conditions and the following disclaimer in the
12:                 * documentation and/or other materials provided with the distribution.
13:                 *
14:                 * Neither the name of the copyright holder nor the names of the
15:                 * contributors may be used to endorse or promote products derived from
16:                 * this software without specific prior written permission.
17:                 *
18:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
19:                 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
20:                 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
21:                 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
22:                 * DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER
23:                 * OR CONTRIBUTORS BE LIABLE FOR ANY
24:                 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
25:                 * OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO,
26:                 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
27:                 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
28:                 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
29:                 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
30:                 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
31:                 * ANY WAY OUT OF THE USE OF THIS
32:                 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
33:                 *
34:                 * The information provided is believed to be accurate and reliable.
35:                 * The copyright holder assumes no responsibility
36:                 * for the consequences of use
37:                 * of such information nor for any infringement of patents or
38:                 * other rights of third parties which may result from its use.
39:                 * No license is granted by implication or otherwise under any patent or
40:                 * patent rights of the copyright holder.
41:                 *
42:                 * File		bme680.c
43:                 * @date	19 Jun 2018
44:                 * @version	3.5.9
45:                 *
46:                 */
47:                
48:                /*! @file bme680.c
49:                 @brief Sensor driver for BME680 sensor */
50:                #include "bme680.h"
51:                
52:                /*!
53:                 * @brief This internal API is used to read the calibrated data from the sensor.
54:                 *
55:                 * This function is used to retrieve the calibration
56:                 * data from the image registers of the sensor.
57:                 *
58:                 * @note Registers 89h  to A1h for calibration data 1 to 24
59:                 *        from bit 0 to 7
60:                 * @note Registers E1h to F0h for calibration data 25 to 40
61:                 *        from bit 0 to 7
62:                 * @param[in] dev	:Structure instance of bme680_dev.
63:                 *
64:                 * @return Result of API execution status.
65:                 * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
66:                 */
67:                static int8_t get_calib_data(struct bme680_dev *dev);
68:                
69:                /*!
70:                 * @brief This internal API is used to set the gas configuration of the sensor.
71:                 *
72:                 * @param[in] dev	:Structure instance of bme680_dev.
73:                 *
74:                 * @return Result of API execution status.
75:                 * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
76:                 */
77:                static int8_t set_gas_config(struct bme680_dev *dev);
78:                
79:                /*!
80:                 * @brief This internal API is used to get the gas configuration of the sensor.
81:                 * @note heatr_temp and heatr_dur values are currently register data
82:                 * and not the actual values set
83:                 *
84:                 * @param[in] dev	:Structure instance of bme680_dev.
85:                 *
86:                 * @return Result of API execution status.
87:                 * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
88:                 */
89:                static int8_t get_gas_config(struct bme680_dev *dev);
90:                
91:                /*!
92:                 * @brief This internal API is used to calculate the Heat duration value.
93:                 *
94:                 * @param[in] dur	:Value of the duration to be shared.
95:                 *
96:                 * @return uint8_t threshold duration after calculation.
97:                 */
98:                static uint8_t calc_heater_dur(uint16_t dur);
99:                
100:               #ifndef BME680_FLOAT_POINT_COMPENSATION
101:               
102:               /*!
103:                * @brief This internal API is used to calculate the temperature value.
104:                *
105:                * @param[in] dev	:Structure instance of bme680_dev.
106:                * @param[in] temp_adc	:Contains the temperature ADC value .
107:                *
108:                * @return uint32_t calculated temperature.
109:                */
110:               static int16_t calc_temperature(uint32_t temp_adc, struct bme680_dev *dev);
111:               
112:               /*!
113:                * @brief This internal API is used to calculate the pressure value.
114:                *
115:                * @param[in] dev	:Structure instance of bme680_dev.
116:                * @param[in] pres_adc	:Contains the pressure ADC value .
117:                *
118:                * @return uint32_t calculated pressure.
119:                */
120:               static uint32_t calc_pressure(uint32_t pres_adc, const struct bme680_dev *dev);
121:               
122:               /*!
123:                * @brief This internal API is used to calculate the humidity value.
124:                *
125:                * @param[in] dev	:Structure instance of bme680_dev.
126:                * @param[in] hum_adc	:Contains the humidity ADC value.
127:                *
128:                * @return uint32_t calculated humidity.
129:                */
130:               static uint32_t calc_humidity(uint16_t hum_adc, const struct bme680_dev *dev);
131:               
132:               /*!
133:                * @brief This internal API is used to calculate the Gas Resistance value.
134:                *
135:                * @param[in] dev		:Structure instance of bme680_dev.
136:                * @param[in] gas_res_adc	:Contains the Gas Resistance ADC value.
137:                * @param[in] gas_range		:Contains the range of gas values.
138:                *
139:                * @return uint32_t calculated gas resistance.
140:                */
141:               static uint32_t calc_gas_resistance(uint16_t gas_res_adc, uint8_t gas_range, const struct bme680_dev *dev);
142:               
143:               /*!
144:                * @brief This internal API is used to calculate the Heat Resistance value.
145:                *
146:                * @param[in] dev	: Structure instance of bme680_dev
147:                * @param[in] temp	: Contains the target temperature value.
148:                *
149:                * @return uint8_t calculated heater resistance.
150:                */
151:               static uint8_t calc_heater_res(uint16_t temp, const struct bme680_dev *dev);
152:               
153:               #else
154:               /*!
155:                * @brief This internal API is used to calculate the
156:                * temperature value value in float format
157:                *
158:                * @param[in] dev	:Structure instance of bme680_dev.
159:                * @param[in] temp_adc	:Contains the temperature ADC value .
160:                *
161:                * @return Calculated temperature in float
162:                */
163:               static float calc_temperature(uint32_t temp_adc, struct bme680_dev *dev);
164:               
165:               /*!
166:                * @brief This internal API is used to calculate the
167:                * pressure value value in float format
168:                *
169:                * @param[in] dev	:Structure instance of bme680_dev.
170:                * @param[in] pres_adc	:Contains the pressure ADC value .
171:                *
172:                * @return Calculated pressure in float.
173:                */
174:               static float calc_pressure(uint32_t pres_adc, const struct bme680_dev *dev);
175:               
176:               /*!
177:                * @brief This internal API is used to calculate the
178:                * humidity value value in float format
179:                *
180:                * @param[in] dev	:Structure instance of bme680_dev.
181:                * @param[in] hum_adc	:Contains the humidity ADC value.
182:                *
183:                * @return Calculated humidity in float.
184:                */
185:               static float calc_humidity(uint16_t hum_adc, const struct bme680_dev *dev);
186:               
187:               /*!
188:                * @brief This internal API is used to calculate the
189:                * gas resistance value value in float format
190:                *
191:                * @param[in] dev		:Structure instance of bme680_dev.
192:                * @param[in] gas_res_adc	:Contains the Gas Resistance ADC value.
193:                * @param[in] gas_range		:Contains the range of gas values.
194:                *
195:                * @return Calculated gas resistance in float.
196:                */
197:               static float calc_gas_resistance(uint16_t gas_res_adc, uint8_t gas_range, const struct bme680_dev *dev);
198:               
199:               /*!
200:                * @brief This internal API is used to calculate the
201:                * heater resistance value in float format
202:                *
203:                * @param[in] temp	: Contains the target temperature value.
204:                * @param[in] dev	: Structure instance of bme680_dev.
205:                *
206:                * @return Calculated heater resistance in float.
207:                */
208:               static float calc_heater_res(uint16_t temp, const struct bme680_dev *dev);
209:               
210:               #endif
211:               
212:               /*!
213:                * @brief This internal API is used to calculate the field data of sensor.
214:                *
215:                * @param[out] data :Structure instance to hold the data
216:                * @param[in] dev	:Structure instance of bme680_dev.
217:                *
218:                *  @return int8_t result of the field data from sensor.
219:                */
220:               static int8_t read_field_data(struct bme680_field_data *data, struct bme680_dev *dev);
221:               
222:               /*!
223:                * @brief This internal API is used to set the memory page
224:                * based on register address.
225:                *
226:                * The value of memory page
227:                *  value  | Description
228:                * --------|--------------
229:                *   0     | BME680_PAGE0_SPI
230:                *   1     | BME680_PAGE1_SPI
231:                *
232:                * @param[in] dev	:Structure instance of bme680_dev.
233:                * @param[in] reg_addr	:Contains the register address array.
234:                *
235:                * @return Result of API execution status
236:                * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
237:                */
238:               static int8_t set_mem_page(uint8_t reg_addr, struct bme680_dev *dev);
239:               
240:               /*!
241:                * @brief This internal API is used to get the memory page based
242:                * on register address.
243:                *
244:                * The value of memory page
245:                *  value  | Description
246:                * --------|--------------
247:                *   0     | BME680_PAGE0_SPI
248:                *   1     | BME680_PAGE1_SPI
249:                *
250:                * @param[in] dev	:Structure instance of bme680_dev.
251:                *
252:                * @return Result of API execution status
253:                * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
254:                */
255:               static int8_t get_mem_page(struct bme680_dev *dev);
256:               
257:               /*!
258:                * @brief This internal API is used to validate the device pointer for
259:                * null conditions.
260:                *
261:                * @param[in] dev	:Structure instance of bme680_dev.
262:                *
263:                * @return Result of API execution status
264:                * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
265:                */
266:               static int8_t null_ptr_check(const struct bme680_dev *dev);
267:               
268:               /*!
269:                * @brief This internal API is used to check the boundary
270:                * conditions.
271:                *
272:                * @param[in] value	:pointer to the value.
273:                * @param[in] min	:minimum value.
274:                * @param[in] max	:maximum value.
275:                * @param[in] dev	:Structure instance of bme680_dev.
276:                *
277:                * @return Result of API execution status
278:                * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
279:                */
280:               static int8_t boundary_check(uint8_t *value, uint8_t min, uint8_t max, struct bme680_dev *dev);
281:               
282:               /****************** Global Function Definitions *******************************/
283:               /*!
284:                *@brief This API is the entry point.
285:                *It reads the chip-id and calibration data from the sensor.
286:                */
287:               int8_t bme680_init(struct bme680_dev *dev)
288:               {
0055E4  FA0004     LNK #0x4
0055E6  980710     MOV W0, [W14+2]
289:               	int8_t rslt;
290:               
291:               	/* Check for null pointer in the device structure*/
292:               	rslt = null_ptr_check(dev);
0055E8  90001E     MOV [W14+2], W0
0055EA  070B4F     RCALL _null_ptr_check, .LFE23, .LFB24
0055EC  784F00     MOV.B W0, [W14]
293:               	if (rslt == BME680_OK) {
0055EE  78401E     MOV.B [W14], W0
0055F0  E00400     CP0.B W0
0055F2  3A001B     BRA NZ, .L2
294:               		/* Soft reset to restore it to default values*/
295:               		rslt = bme680_soft_reset(dev);
0055F4  90001E     MOV [W14+2], W0
0055F6  0700AD     RCALL bme680_soft_reset
0055F8  784F00     MOV.B W0, [W14]
296:               		if (rslt == BME680_OK) {
0055FA  78401E     MOV.B [W14], W0
0055FC  E00400     CP0.B W0
0055FE  3A0015     BRA NZ, .L2
297:               			rslt = bme680_get_regs(BME680_CHIP_ID_ADDR, &dev->chip_id, 1, dev);
005600  90001E     MOV [W14+2], W0
005602  90019E     MOV [W14+2], W3
005604  200012     MOV #0x1, W2
005606  780080     MOV W0, W1
005608  B3CD00     MOV.B #0xD0, W0
00560A  070012     RCALL bme680_get_regs
00560C  784F00     MOV.B W0, [W14]
298:               			if (rslt == BME680_OK) {
00560E  78401E     MOV.B [W14], W0
005610  E00400     CP0.B W0
005612  3A000B     BRA NZ, .L2
299:               				if (dev->chip_id == BME680_CHIP_ID) {
005614  90001E     MOV [W14+2], W0
005616  784090     MOV.B [W0], W1
005618  B3C610     MOV.B #0x61, W0
00561A  50CF80     SUB.B W1, W0, [W15]
00561C  3A0004     BRA NZ, .L3
300:               					/* Get the Calibration data */
301:               					rslt = get_calib_data(dev);
00561E  90001E     MOV [W14+2], W0
005620  0703B6     RCALL _get_calib_data, .LFE10, .LFB11
005622  784F00     MOV.B W0, [W14]
005624  370002     BRA .L2
302:               				} else {
303:               					rslt = BME680_E_DEV_NOT_FOUND;
005626  B3CFD0     MOV.B #0xFD, W0
005628  784F00     MOV.B W0, [W14]
304:               				}
305:               			}
306:               		}
307:               	}
308:               
309:               	return rslt;
00562A  78401E     MOV.B [W14], W0
310:               }
00562C  FA8000     ULNK
00562E  060000     RETURN
311:               
312:               /*!
313:                * @brief This API reads the data from the given register address of the sensor.
314:                */
315:               int8_t bme680_get_regs(uint8_t reg_addr, uint8_t *reg_data, uint16_t len, struct bme680_dev *dev)
316:               {
005630  FA000A     LNK #0xA
005632  984720     MOV.B W0, [W14+2]
005634  980721     MOV W1, [W14+4]
005636  980732     MOV W2, [W14+6]
005638  980743     MOV W3, [W14+8]
317:               	int8_t rslt;
318:               
319:               	/* Check for null pointer in the device structure*/
320:               	rslt = null_ptr_check(dev);
00563A  90004E     MOV [W14+8], W0
00563C  070B26     RCALL _null_ptr_check, .LFE23, .LFB24
00563E  784F00     MOV.B W0, [W14]
321:               	if (rslt == BME680_OK) {
005640  78401E     MOV.B [W14], W0
005642  E00400     CP0.B W0
005644  3A001E     BRA NZ, .L5
322:               		if (dev->intf == BME680_SPI_INTF) {
005646  90004E     MOV [W14+8], W0
005648  900010     MOV [W0+2], W0
00564A  E00000     CP0 W0
00564C  3A000A     BRA NZ, .L6
323:               			/* Set the memory page */
324:               			rslt = set_mem_page(reg_addr, dev);
00564E  9000CE     MOV [W14+8], W1
005650  90402E     MOV.B [W14+2], W0
005652  070A84     RCALL _set_mem_page, .LFE20, .LFB21
005654  784F00     MOV.B W0, [W14]
325:               			if (rslt == BME680_OK)
005656  78401E     MOV.B [W14], W0
005658  E00400     CP0.B W0
00565A  3A0003     BRA NZ, .L6
326:               				reg_addr = reg_addr | BME680_SPI_RD_MSK;
00565C  90402E     MOV.B [W14+2], W0
00565E  A07400     BSET.B W0, #7
005660  984720     MOV.B W0, [W14+2]
327:               		}
328:               		dev->com_rslt = dev->read(dev->dev_id, reg_addr, reg_data, len);
005662  90004E     MOV [W14+8], W0
005664  902220     MOV [W0+68], W4
005666  90004E     MOV [W14+8], W0
005668  904010     MOV.B [W0+1], W0
00566A  9001BE     MOV [W14+6], W3
00566C  90012E     MOV [W14+4], W2
00566E  9040AE     MOV.B [W14+2], W1
005670  010004     CALL W4
005672  9000CE     MOV [W14+8], W1
005674  98C8A0     MOV.B W0, [W1+74]
329:               		if (dev->com_rslt != 0)
005676  90004E     MOV [W14+8], W0
005678  90C820     MOV.B [W0+74], W0
00567A  E00400     CP0.B W0
00567C  320002     BRA Z, .L5
330:               			rslt = BME680_E_COM_FAIL;
00567E  B3CFE0     MOV.B #0xFE, W0
005680  784F00     MOV.B W0, [W14]
331:               	}
332:               
333:               	return rslt;
005682  78401E     MOV.B [W14], W0
334:               }
005684  FA8000     ULNK
005686  060000     RETURN
335:               
336:               /*!
337:                * @brief This API writes the given data to the register address
338:                * of the sensor.
339:                */
340:               int8_t bme680_set_regs(const uint8_t *reg_addr, const uint8_t *reg_data, uint8_t len, struct bme680_dev *dev)
341:               {
005688  FA0034     LNK #0x34
00568A  981760     MOV W0, [W14+44]
00568C  981771     MOV W1, [W14+46]
00568E  987702     MOV.B W2, [W14+48]
005690  981F13     MOV W3, [W14+50]
342:               	int8_t rslt;
343:               	/* Length of the temporary buffer is 2*(length of register)*/
344:               	uint8_t tmp_buff[BME680_TMP_BUFFER_LENGTH] = { 0 };
005692  4700E4     ADD W14, #0x4, W1
005694  090013     REPEAT #0x13
005696  EB1880     CLR [W1++]
345:               	uint16_t index;
346:               
347:               	/* Check for null pointer in the device structure*/
348:               	rslt = null_ptr_check(dev);
005698  90181E     MOV [W14+50], W0
00569A  070AF7     RCALL _null_ptr_check, .LFE23, .LFB24
00569C  784F00     MOV.B W0, [W14]
349:               	if (rslt == BME680_OK) {
00569E  78401E     MOV.B [W14], W0
0056A0  E00400     CP0.B W0
0056A2  3A0054     BRA NZ, .L8
350:               		if ((len > 0) && (len < BME680_TMP_BUFFER_LENGTH / 2)) {
0056A4  90700E     MOV.B [W14+48], W0
0056A6  E00400     CP0.B W0
0056A8  32004D     BRA Z, .L9
0056AA  90700E     MOV.B [W14+48], W0
0056AC  504FF3     SUB.B W0, #0x13, [W15]
0056AE  3E004A     BRA GTU, .L9
351:               			/* Interleave the 2 arrays */
352:               			for (index = 0; index < len; index++) {
0056B0  EB0000     CLR W0
0056B2  980710     MOV W0, [W14+2]
0056B4  370029     BRA .L10
005702  90001E     MOV [W14+2], W0
005704  E80000     INC W0, W0
005706  980710     MOV W0, [W14+2]
005708  90700E     MOV.B [W14+48], W0
00570A  FB8080     ZE W0, W1
00570C  90001E     MOV [W14+2], W0
00570E  508F80     SUB W1, W0, [W15]
005710  3EFFD2     BRA GTU, .L13
353:               				if (dev->intf == BME680_SPI_INTF) {
0056B6  90181E     MOV [W14+50], W0
0056B8  900010     MOV [W0+2], W0
0056BA  E00000     CP0 W0
0056BC  3A0011     BRA NZ, .L11
354:               					/* Set the memory page */
355:               					rslt = set_mem_page(reg_addr[index], dev);
0056BE  9010EE     MOV [W14+44], W1
0056C0  90001E     MOV [W14+2], W0
0056C2  408000     ADD W1, W0, W0
0056C4  784010     MOV.B [W0], W0
0056C6  90189E     MOV [W14+50], W1
0056C8  070A49     RCALL _set_mem_page, .LFE20, .LFB21
0056CA  784F00     MOV.B W0, [W14]
356:               					tmp_buff[(2 * index)] = reg_addr[index] & BME680_SPI_WR_MSK;
0056CC  90001E     MOV [W14+2], W0
0056CE  400000     ADD W0, W0, W0
0056D0  90116E     MOV [W14+44], W2
0056D2  90009E     MOV [W14+2], W1
0056D4  410081     ADD W2, W1, W1
0056D6  784091     MOV.B [W1], W1
0056D8  A17401     BCLR.B W1, #7
0056DA  470000     ADD W14, W0, W0
0056DC  984041     MOV.B W1, [W0+4]
0056DE  370008     BRA .L12
357:               				} else {
358:               					tmp_buff[(2 * index)] = reg_addr[index];
0056E0  90001E     MOV [W14+2], W0
0056E2  400000     ADD W0, W0, W0
0056E4  90116E     MOV [W14+44], W2
0056E6  90009E     MOV [W14+2], W1
0056E8  410081     ADD W2, W1, W1
0056EA  784091     MOV.B [W1], W1
0056EC  470000     ADD W14, W0, W0
0056EE  984041     MOV.B W1, [W0+4]
359:               				}
360:               				tmp_buff[(2 * index) + 1] = reg_data[index];
0056F0  90001E     MOV [W14+2], W0
0056F2  400000     ADD W0, W0, W0
0056F4  E80000     INC W0, W0
0056F6  90117E     MOV [W14+46], W2
0056F8  90009E     MOV [W14+2], W1
0056FA  410081     ADD W2, W1, W1
0056FC  784091     MOV.B [W1], W1
0056FE  470000     ADD W14, W0, W0
005700  984041     MOV.B W1, [W0+4]
361:               			}
362:               			/* Write the interleaved array */
363:               			if (rslt == BME680_OK) {
005712  78401E     MOV.B [W14], W0
005714  E00400     CP0.B W0
005716  3A001A     BRA NZ, .L8
005742  370004     BRA .L8
00574A  000000     NOP
364:               				dev->com_rslt = dev->write(dev->dev_id, tmp_buff[0], &tmp_buff[1], (2 * len) - 1);
005718  90181E     MOV [W14+50], W0
00571A  902230     MOV [W0+70], W4
00571C  90700E     MOV.B [W14+48], W0
00571E  FB8000     ZE W0, W0
005720  400000     ADD W0, W0, W0
005722  E90000     DEC W0, W0
005724  780180     MOV W0, W3
005726  9040CE     MOV.B [W14+4], W1
005728  90181E     MOV [W14+50], W0
00572A  904010     MOV.B [W0+1], W0
00572C  470164     ADD W14, #0x4, W2
00572E  E80102     INC W2, W2
005730  010004     CALL W4
005732  90189E     MOV [W14+50], W1
005734  98C8A0     MOV.B W0, [W1+74]
365:               				if (dev->com_rslt != 0)
005736  90181E     MOV [W14+50], W0
005738  90C820     MOV.B [W0+74], W0
00573A  E00400     CP0.B W0
00573C  320006     BRA Z, .L15
366:               					rslt = BME680_E_COM_FAIL;
00573E  B3CFE0     MOV.B #0xFE, W0
005740  784F00     MOV.B W0, [W14]
367:               			}
368:               		} else {
369:               			rslt = BME680_E_INVALID_LENGTH;
005744  B3CFC0     MOV.B #0xFC, W0
005746  784F00     MOV.B W0, [W14]
005748  370001     BRA .L8
370:               		}
371:               	}
372:               
373:               	return rslt;
00574C  78401E     MOV.B [W14], W0
374:               }
00574E  FA8000     ULNK
005750  060000     RETURN
375:               
376:               /*!
377:                * @brief This API performs the soft reset of the sensor.
378:                */
379:               int8_t bme680_soft_reset(struct bme680_dev *dev)
380:               {
005752  FA0006     LNK #0x6
005754  980720     MOV W0, [W14+4]
381:               	int8_t rslt;
382:               	uint8_t reg_addr = BME680_SOFT_RESET_ADDR;
005756  B3CE00     MOV.B #0xE0, W0
005758  984710     MOV.B W0, [W14+1]
383:               	/* 0xb6 is the soft reset command */
384:               	uint8_t soft_rst_cmd = BME680_SOFT_RESET_CMD;
00575A  B3CB60     MOV.B #0xB6, W0
00575C  984720     MOV.B W0, [W14+2]
385:               
386:               	/* Check for null pointer in the device structure*/
387:               	rslt = null_ptr_check(dev);
00575E  90002E     MOV [W14+4], W0
005760  070A94     RCALL _null_ptr_check, .LFE23, .LFB24
005762  784F00     MOV.B W0, [W14]
388:               	if (rslt == BME680_OK) {
005764  78401E     MOV.B [W14], W0
005766  E00400     CP0.B W0
005768  3A001F     BRA NZ, .L17
389:               		if (dev->intf == BME680_SPI_INTF)
00576A  90002E     MOV [W14+4], W0
00576C  900010     MOV [W0+2], W0
00576E  E00000     CP0 W0
005770  3A0003     BRA NZ, .L18
390:               			rslt = get_mem_page(dev);
005772  90002E     MOV [W14+4], W0
005774  070A3D     RCALL _get_mem_page, .LFE21, .LFB22
005776  784F00     MOV.B W0, [W14]
391:               
392:               		/* Reset the device */
393:               		if (rslt == BME680_OK) {
005778  78401E     MOV.B [W14], W0
00577A  E00400     CP0.B W0
00577C  3A0015     BRA NZ, .L17
394:               			rslt = bme680_set_regs(&reg_addr, &soft_rst_cmd, 1, dev);
00577E  E8808E     INC2 W14, W1
005780  E8000E     INC W14, W0
005782  9001AE     MOV [W14+4], W3
005784  B3C012     MOV.B #0x1, W2
005786  07FF80     RCALL bme680_set_regs
005788  784F00     MOV.B W0, [W14]
395:               			/* Wait for 5ms */
396:               			dev->delay_ms(BME680_RESET_PERIOD);
00578A  90002E     MOV [W14+4], W0
00578C  902140     MOV [W0+72], W2
00578E  2000A0     MOV #0xA, W0
005790  200001     MOV #0x0, W1
005792  010002     CALL W2
397:               
398:               			if (rslt == BME680_OK) {
005794  78401E     MOV.B [W14], W0
005796  E00400     CP0.B W0
005798  3A0007     BRA NZ, .L17
399:               				/* After reset get the memory page */
400:               				if (dev->intf == BME680_SPI_INTF)
00579A  90002E     MOV [W14+4], W0
00579C  900010     MOV [W0+2], W0
00579E  E00000     CP0 W0
0057A0  3A0003     BRA NZ, .L17
401:               					rslt = get_mem_page(dev);
0057A2  90002E     MOV [W14+4], W0
0057A4  070A25     RCALL _get_mem_page, .LFE21, .LFB22
0057A6  784F00     MOV.B W0, [W14]
402:               			}
403:               		}
404:               	}
405:               
406:               	return rslt;
0057A8  78401E     MOV.B [W14], W0
407:               }
0057AA  FA8000     ULNK
0057AC  060000     RETURN
408:               
409:               /*!
410:                * @brief This API is used to set the oversampling, filter and T,P,H, gas selection
411:                * settings in the sensor.
412:                */
413:               int8_t bme680_set_sensor_settings(uint16_t desired_settings, struct bme680_dev *dev)
414:               {
0057AE  FA0016     LNK #0x16
0057B0  980F10     MOV W0, [W14+18]
0057B2  980F21     MOV W1, [W14+20]
415:               	int8_t rslt;
416:               	uint8_t reg_addr;
417:               	uint8_t data = 0;
0057B4  EB4000     CLR.B W0
0057B6  984740     MOV.B W0, [W14+4]
418:               	uint8_t count = 0;
0057B8  EB4000     CLR.B W0
0057BA  984710     MOV.B W0, [W14+1]
419:               	uint8_t reg_array[BME680_REG_BUFFER_LENGTH] = { 0 };
0057BC  4700E5     ADD W14, #0x5, W1
0057BE  090005     REPEAT #0x5
0057C0  EB5880     CLR.B [W1++]
420:               	uint8_t data_array[BME680_REG_BUFFER_LENGTH] = { 0 };
0057C2  4700EB     ADD W14, #0xB, W1
0057C4  090005     REPEAT #0x5
0057C6  EB5880     CLR.B [W1++]
421:               	uint8_t intended_power_mode = dev->power_mode; /* Save intended power mode */
0057C8  90082E     MOV [W14+20], W0
0057CA  90C080     MOV.B [W0+64], W1
0057CC  984721     MOV.B W1, [W14+2]
422:               
423:               	/* Check for null pointer in the device structure*/
424:               	rslt = null_ptr_check(dev);
0057CE  90082E     MOV [W14+20], W0
0057D0  070A5C     RCALL _null_ptr_check, .LFE23, .LFB24
0057D2  784F00     MOV.B W0, [W14]
425:               	if (rslt == BME680_OK) {
0057D4  78401E     MOV.B [W14], W0
0057D6  E00400     CP0.B W0
0057D8  3A0139     BRA NZ, .L20
426:               		if (desired_settings & BME680_GAS_MEAS_SEL)
0057DA  90081E     MOV [W14+18], W0
0057DC  600068     AND W0, #0x8, W0
0057DE  E00000     CP0 W0
0057E0  320003     BRA Z, .L21
427:               			rslt = set_gas_config(dev);
0057E2  90082E     MOV [W14+20], W0
0057E4  0703C3     RCALL _set_gas_config, .LFE11, .LFB12
0057E6  784F00     MOV.B W0, [W14]
428:               
429:               		dev->power_mode = BME680_SLEEP_MODE;
0057E8  90082E     MOV [W14+20], W0
0057EA  EB4080     CLR.B W1
0057EC  98C001     MOV.B W1, [W0+64]
430:               		if (rslt == BME680_OK)
0057EE  78401E     MOV.B [W14], W0
0057F0  E00400     CP0.B W0
0057F2  3A0003     BRA NZ, .L22
431:               			rslt = bme680_set_sensor_mode(dev);
0057F4  90082E     MOV [W14+20], W0
0057F6  07018F     RCALL bme680_set_sensor_mode
0057F8  784F00     MOV.B W0, [W14]
432:               
433:               		/* Selecting the filter */
434:               		if (desired_settings & BME680_FILTER_SEL) {
0057FA  90081E     MOV [W14+18], W0
0057FC  600070     AND W0, #0x10, W0
0057FE  E00000     CP0 W0
005800  320030     BRA Z, .L23
435:               			rslt = boundary_check(&dev->tph_sett.filter, BME680_FILTER_SIZE_0, BME680_FILTER_SIZE_127, dev);
005802  90082E     MOV [W14+20], W0
005804  B00370     ADD #0x37, W0
005806  9009AE     MOV [W14+20], W3
005808  B3C072     MOV.B #0x7, W2
00580A  EB4080     CLR.B W1
00580C  070A12     RCALL _boundary_check, .LFE22, .LFB23
00580E  784F00     MOV.B W0, [W14]
436:               			reg_addr = BME680_CONF_ODR_FILT_ADDR;
005810  B3C750     MOV.B #0x75, W0
005812  984730     MOV.B W0, [W14+3]
437:               
438:               			if (rslt == BME680_OK)
005814  78401E     MOV.B [W14], W0
005816  E00400     CP0.B W0
005818  3A0007     BRA NZ, .L24
439:               				rslt = bme680_get_regs(reg_addr, &data, 1, dev);
00581A  470064     ADD W14, #0x4, W0
00581C  9009AE     MOV [W14+20], W3
00581E  200012     MOV #0x1, W2
005820  780080     MOV W0, W1
005822  90403E     MOV.B [W14+3], W0
005824  07FF05     RCALL bme680_get_regs
005826  784F00     MOV.B W0, [W14]
440:               
441:               			if (desired_settings & BME680_FILTER_SEL)
005828  90081E     MOV [W14+18], W0
00582A  600070     AND W0, #0x10, W0
00582C  E00000     CP0 W0
00582E  32000C     BRA Z, .L25
442:               				data = BME680_SET_BITS(data, BME680_FILTER, dev->tph_sett.filter);
005830  90404E     MOV.B [W14+4], W0
005832  784080     MOV.B W0, W1
005834  B3CE30     MOV.B #0xE3, W0
005836  60C080     AND.B W1, W0, W1
005838  90082E     MOV [W14+20], W0
00583A  907070     MOV.B [W0+55], W0
00583C  FB8000     ZE W0, W0
00583E  DD0042     SL W0, #2, W0
005840  784000     MOV.B W0, W0
005842  60407C     AND.B W0, #0x1C, W0
005844  70C000     IOR.B W1, W0, W0
005846  984740     MOV.B W0, [W14+4]
443:               
444:               			reg_array[count] = reg_addr; /* Append configuration */
005848  90401E     MOV.B [W14+1], W0
00584A  FB8000     ZE W0, W0
00584C  470000     ADD W14, W0, W0
00584E  9040BE     MOV.B [W14+3], W1
005850  984051     MOV.B W1, [W0+5]
445:               			data_array[count] = data;
005852  90401E     MOV.B [W14+1], W0
005854  FB8000     ZE W0, W0
005856  9040CE     MOV.B [W14+4], W1
005858  470000     ADD W14, W0, W0
00585A  984831     MOV.B W1, [W0+11]
446:               			count++;
00585C  90401E     MOV.B [W14+1], W0
00585E  E84000     INC.B W0, W0
005860  984710     MOV.B W0, [W14+1]
447:               		}
448:               
449:               		/* Selecting heater control for the sensor */
450:               		if (desired_settings & BME680_HCNTRL_SEL) {
005862  90089E     MOV [W14+18], W1
005864  200200     MOV #0x20, W0
005866  608000     AND W1, W0, W0
005868  E00000     CP0 W0
00586A  320028     BRA Z, .L26
451:               			rslt = boundary_check(&dev->gas_sett.heatr_ctrl, BME680_ENABLE_HEATER,
00586C  90082E     MOV [W14+20], W0
00586E  B00390     ADD #0x39, W0
005870  9009AE     MOV [W14+20], W3
005872  B3C082     MOV.B #0x8, W2
005874  EB4080     CLR.B W1
005876  0709DD     RCALL _boundary_check, .LFE22, .LFB23
005878  784F00     MOV.B W0, [W14]
452:               				BME680_DISABLE_HEATER, dev);
453:               			reg_addr = BME680_CONF_HEAT_CTRL_ADDR;
00587A  B3C700     MOV.B #0x70, W0
00587C  984730     MOV.B W0, [W14+3]
454:               
455:               			if (rslt == BME680_OK)
00587E  78401E     MOV.B [W14], W0
005880  E00400     CP0.B W0
005882  3A0007     BRA NZ, .L27
456:               				rslt = bme680_get_regs(reg_addr, &data, 1, dev);
005884  470064     ADD W14, #0x4, W0
005886  9009AE     MOV [W14+20], W3
005888  200012     MOV #0x1, W2
00588A  780080     MOV W0, W1
00588C  90403E     MOV.B [W14+3], W0
00588E  07FED0     RCALL bme680_get_regs
005890  784F00     MOV.B W0, [W14]
457:               			data = BME680_SET_BITS_POS_0(data, BME680_HCTRL, dev->gas_sett.heatr_ctrl);
005892  90404E     MOV.B [W14+4], W0
005894  784080     MOV.B W0, W1
005896  A13401     BCLR.B W1, #3
005898  90082E     MOV [W14+20], W0
00589A  907810     MOV.B [W0+57], W0
00589C  604068     AND.B W0, #0x8, W0
00589E  70C000     IOR.B W1, W0, W0
0058A0  984740     MOV.B W0, [W14+4]
458:               
459:               			reg_array[count] = reg_addr; /* Append configuration */
0058A2  90401E     MOV.B [W14+1], W0
0058A4  FB8000     ZE W0, W0
0058A6  470000     ADD W14, W0, W0
0058A8  9040BE     MOV.B [W14+3], W1
0058AA  984051     MOV.B W1, [W0+5]
460:               			data_array[count] = data;
0058AC  90401E     MOV.B [W14+1], W0
0058AE  FB8000     ZE W0, W0
0058B0  9040CE     MOV.B [W14+4], W1
0058B2  470000     ADD W14, W0, W0
0058B4  984831     MOV.B W1, [W0+11]
461:               			count++;
0058B6  90401E     MOV.B [W14+1], W0
0058B8  E84000     INC.B W0, W0
0058BA  984710     MOV.B W0, [W14+1]
462:               		}
463:               
464:               		/* Selecting heater T,P oversampling for the sensor */
465:               		if (desired_settings & (BME680_OST_SEL | BME680_OSP_SEL)) {
0058BC  90081E     MOV [W14+18], W0
0058BE  600063     AND W0, #0x3, W0
0058C0  E00000     CP0 W0
0058C2  32003E     BRA Z, .L28
466:               			rslt = boundary_check(&dev->tph_sett.os_temp, BME680_OS_NONE, BME680_OS_16X, dev);
0058C4  90082E     MOV [W14+20], W0
0058C6  B00350     ADD #0x35, W0
0058C8  9009AE     MOV [W14+20], W3
0058CA  B3C052     MOV.B #0x5, W2
0058CC  EB4080     CLR.B W1
0058CE  0709B1     RCALL _boundary_check, .LFE22, .LFB23
0058D0  784F00     MOV.B W0, [W14]
467:               			reg_addr = BME680_CONF_T_P_MODE_ADDR;
0058D2  B3C740     MOV.B #0x74, W0
0058D4  984730     MOV.B W0, [W14+3]
468:               
469:               			if (rslt == BME680_OK)
0058D6  78401E     MOV.B [W14], W0
0058D8  E00400     CP0.B W0
0058DA  3A0007     BRA NZ, .L29
470:               				rslt = bme680_get_regs(reg_addr, &data, 1, dev);
0058DC  470064     ADD W14, #0x4, W0
0058DE  9009AE     MOV [W14+20], W3
0058E0  200012     MOV #0x1, W2
0058E2  780080     MOV W0, W1
0058E4  90403E     MOV.B [W14+3], W0
0058E6  07FEA4     RCALL bme680_get_regs
0058E8  784F00     MOV.B W0, [W14]
471:               
472:               			if (desired_settings & BME680_OST_SEL)
0058EA  90081E     MOV [W14+18], W0
0058EC  600061     AND W0, #0x1, W0
0058EE  784000     MOV.B W0, W0
0058F0  E00400     CP0.B W0
0058F2  320009     BRA Z, .L30
473:               				data = BME680_SET_BITS(data, BME680_OST, dev->tph_sett.os_temp);
0058F4  90404E     MOV.B [W14+4], W0
0058F6  6040FF     AND.B W0, #0x1F, W1
0058F8  90082E     MOV [W14+20], W0
0058FA  907050     MOV.B [W0+53], W0
0058FC  FB8000     ZE W0, W0
0058FE  DD0045     SL W0, #5, W0
005900  784000     MOV.B W0, W0
005902  70C000     IOR.B W1, W0, W0
005904  984740     MOV.B W0, [W14+4]
474:               
475:               			if (desired_settings & BME680_OSP_SEL)
005906  90081E     MOV [W14+18], W0
005908  600062     AND W0, #0x2, W0
00590A  E00000     CP0 W0
00590C  32000C     BRA Z, .L31
476:               				data = BME680_SET_BITS(data, BME680_OSP, dev->tph_sett.os_pres);
00590E  90404E     MOV.B [W14+4], W0
005910  784080     MOV.B W0, W1
005912  B3CE30     MOV.B #0xE3, W0
005914  60C080     AND.B W1, W0, W1
005916  90082E     MOV [W14+20], W0
005918  907060     MOV.B [W0+54], W0
00591A  FB8000     ZE W0, W0
00591C  DD0042     SL W0, #2, W0
00591E  784000     MOV.B W0, W0
005920  60407C     AND.B W0, #0x1C, W0
005922  70C000     IOR.B W1, W0, W0
005924  984740     MOV.B W0, [W14+4]
477:               
478:               			reg_array[count] = reg_addr;
005926  90401E     MOV.B [W14+1], W0
005928  FB8000     ZE W0, W0
00592A  470000     ADD W14, W0, W0
00592C  9040BE     MOV.B [W14+3], W1
00592E  984051     MOV.B W1, [W0+5]
479:               			data_array[count] = data;
005930  90401E     MOV.B [W14+1], W0
005932  FB8000     ZE W0, W0
005934  9040CE     MOV.B [W14+4], W1
005936  470000     ADD W14, W0, W0
005938  984831     MOV.B W1, [W0+11]
480:               			count++;
00593A  90401E     MOV.B [W14+1], W0
00593C  E84000     INC.B W0, W0
00593E  984710     MOV.B W0, [W14+1]
481:               		}
482:               
483:               		/* Selecting humidity oversampling for the sensor */
484:               		if (desired_settings & BME680_OSH_SEL) {
005940  90081E     MOV [W14+18], W0
005942  600064     AND W0, #0x4, W0
005944  E00000     CP0 W0
005946  320029     BRA Z, .L32
485:               			rslt = boundary_check(&dev->tph_sett.os_hum, BME680_OS_NONE, BME680_OS_16X, dev);
005948  90082E     MOV [W14+20], W0
00594A  B00340     ADD #0x34, W0
00594C  9009AE     MOV [W14+20], W3
00594E  B3C052     MOV.B #0x5, W2
005950  EB4080     CLR.B W1
005952  07096F     RCALL _boundary_check, .LFE22, .LFB23
005954  784F00     MOV.B W0, [W14]
486:               			reg_addr = BME680_CONF_OS_H_ADDR;
005956  B3C720     MOV.B #0x72, W0
005958  984730     MOV.B W0, [W14+3]
487:               
488:               			if (rslt == BME680_OK)
00595A  78401E     MOV.B [W14], W0
00595C  E00400     CP0.B W0
00595E  3A0007     BRA NZ, .L33
489:               				rslt = bme680_get_regs(reg_addr, &data, 1, dev);
005960  470064     ADD W14, #0x4, W0
005962  9009AE     MOV [W14+20], W3
005964  200012     MOV #0x1, W2
005966  780080     MOV W0, W1
005968  90403E     MOV.B [W14+3], W0
00596A  07FE62     RCALL bme680_get_regs
00596C  784F00     MOV.B W0, [W14]
490:               			data = BME680_SET_BITS_POS_0(data, BME680_OSH, dev->tph_sett.os_hum);
00596E  90404E     MOV.B [W14+4], W0
005970  784080     MOV.B W0, W1
005972  B3CF80     MOV.B #0xF8, W0
005974  60C080     AND.B W1, W0, W1
005976  90082E     MOV [W14+20], W0
005978  907040     MOV.B [W0+52], W0
00597A  604067     AND.B W0, #0x7, W0
00597C  70C000     IOR.B W1, W0, W0
00597E  984740     MOV.B W0, [W14+4]
491:               
492:               			reg_array[count] = reg_addr; /* Append configuration */
005980  90401E     MOV.B [W14+1], W0
005982  FB8000     ZE W0, W0
005984  470000     ADD W14, W0, W0
005986  9040BE     MOV.B [W14+3], W1
005988  984051     MOV.B W1, [W0+5]
493:               			data_array[count] = data;
00598A  90401E     MOV.B [W14+1], W0
00598C  FB8000     ZE W0, W0
00598E  9040CE     MOV.B [W14+4], W1
005990  470000     ADD W14, W0, W0
005992  984831     MOV.B W1, [W0+11]
494:               			count++;
005994  90401E     MOV.B [W14+1], W0
005996  E84000     INC.B W0, W0
005998  984710     MOV.B W0, [W14+1]
495:               		}
496:               
497:               		/* Selecting the runGas and NB conversion settings for the sensor */
498:               		if (desired_settings & (BME680_RUN_GAS_SEL | BME680_NBCONV_SEL)) {
00599A  90089E     MOV [W14+18], W1
00599C  200C00     MOV #0xC0, W0
00599E  608000     AND W1, W0, W0
0059A0  E00000     CP0 W0
0059A2  320048     BRA Z, .L34
499:               			rslt = boundary_check(&dev->gas_sett.run_gas, BME680_RUN_GAS_DISABLE,
0059A4  90082E     MOV [W14+20], W0
0059A6  B003A0     ADD #0x3A, W0
0059A8  9009AE     MOV [W14+20], W3
0059AA  B3C012     MOV.B #0x1, W2
0059AC  EB4080     CLR.B W1
0059AE  070941     RCALL _boundary_check, .LFE22, .LFB23
0059B0  784F00     MOV.B W0, [W14]
500:               				BME680_RUN_GAS_ENABLE, dev);
501:               			if (rslt == BME680_OK) {
0059B2  78401E     MOV.B [W14], W0
0059B4  E00400     CP0.B W0
0059B6  3A0007     BRA NZ, .L35
502:               				/* Validate boundary conditions */
503:               				rslt = boundary_check(&dev->gas_sett.nb_conv, BME680_NBCONV_MIN,
0059B8  90082E     MOV [W14+20], W0
0059BA  B00380     ADD #0x38, W0
0059BC  9009AE     MOV [W14+20], W3
0059BE  B3C0A2     MOV.B #0xA, W2
0059C0  EB4080     CLR.B W1
0059C2  070937     RCALL _boundary_check, .LFE22, .LFB23
0059C4  784F00     MOV.B W0, [W14]
504:               					BME680_NBCONV_MAX, dev);
505:               			}
506:               
507:               			reg_addr = BME680_CONF_ODR_RUN_GAS_NBC_ADDR;
0059C6  B3C710     MOV.B #0x71, W0
0059C8  984730     MOV.B W0, [W14+3]
508:               
509:               			if (rslt == BME680_OK)
0059CA  78401E     MOV.B [W14], W0
0059CC  E00400     CP0.B W0
0059CE  3A0007     BRA NZ, .L36
510:               				rslt = bme680_get_regs(reg_addr, &data, 1, dev);
0059D0  470064     ADD W14, #0x4, W0
0059D2  9009AE     MOV [W14+20], W3
0059D4  200012     MOV #0x1, W2
0059D6  780080     MOV W0, W1
0059D8  90403E     MOV.B [W14+3], W0
0059DA  07FE2A     RCALL bme680_get_regs
0059DC  784F00     MOV.B W0, [W14]
511:               
512:               			if (desired_settings & BME680_RUN_GAS_SEL)
0059DE  90089E     MOV [W14+18], W1
0059E0  200400     MOV #0x40, W0
0059E2  608000     AND W1, W0, W0
0059E4  E00000     CP0 W0
0059E6  32000B     BRA Z, .L37
513:               				data = BME680_SET_BITS(data, BME680_RUN_GAS, dev->gas_sett.run_gas);
0059E8  90404E     MOV.B [W14+4], W0
0059EA  784080     MOV.B W0, W1
0059EC  A14401     BCLR.B W1, #4
0059EE  90082E     MOV [W14+20], W0
0059F0  907820     MOV.B [W0+58], W0
0059F2  FB8000     ZE W0, W0
0059F4  DD0044     SL W0, #4, W0
0059F6  784000     MOV.B W0, W0
0059F8  604070     AND.B W0, #0x10, W0
0059FA  70C000     IOR.B W1, W0, W0
0059FC  984740     MOV.B W0, [W14+4]
514:               
515:               			if (desired_settings & BME680_NBCONV_SEL)
0059FE  90089E     MOV [W14+18], W1
005A00  200800     MOV #0x80, W0
005A02  608000     AND W1, W0, W0
005A04  E00000     CP0 W0
005A06  320009     BRA Z, .L38
516:               				data = BME680_SET_BITS_POS_0(data, BME680_NBCONV, dev->gas_sett.nb_conv);
005A08  90404E     MOV.B [W14+4], W0
005A0A  784080     MOV.B W0, W1
005A0C  B3CF00     MOV.B #0xF0, W0
005A0E  60C080     AND.B W1, W0, W1
005A10  90082E     MOV [W14+20], W0
005A12  907800     MOV.B [W0+56], W0
005A14  60406F     AND.B W0, #0xF, W0
005A16  70C000     IOR.B W1, W0, W0
005A18  984740     MOV.B W0, [W14+4]
517:               
518:               			reg_array[count] = reg_addr; /* Append configuration */
005A1A  90401E     MOV.B [W14+1], W0
005A1C  FB8000     ZE W0, W0
005A1E  470000     ADD W14, W0, W0
005A20  9040BE     MOV.B [W14+3], W1
005A22  984051     MOV.B W1, [W0+5]
519:               			data_array[count] = data;
005A24  90401E     MOV.B [W14+1], W0
005A26  FB8000     ZE W0, W0
005A28  9040CE     MOV.B [W14+4], W1
005A2A  470000     ADD W14, W0, W0
005A2C  984831     MOV.B W1, [W0+11]
520:               			count++;
005A2E  90401E     MOV.B [W14+1], W0
005A30  E84000     INC.B W0, W0
005A32  984710     MOV.B W0, [W14+1]
521:               		}
522:               
523:               		if (rslt == BME680_OK)
005A34  78401E     MOV.B [W14], W0
005A36  E00400     CP0.B W0
005A38  3A0006     BRA NZ, .L39
524:               			rslt = bme680_set_regs(reg_array, data_array, count, dev);
005A3A  4700EB     ADD W14, #0xB, W1
005A3C  470065     ADD W14, #0x5, W0
005A3E  9009AE     MOV [W14+20], W3
005A40  90411E     MOV.B [W14+1], W2
005A42  07FE22     RCALL bme680_set_regs
005A44  784F00     MOV.B W0, [W14]
525:               
526:               		/* Restore previous intended power mode */
527:               		dev->power_mode = intended_power_mode;
005A46  90082E     MOV [W14+20], W0
005A48  9040AE     MOV.B [W14+2], W1
005A4A  98C001     MOV.B W1, [W0+64]
528:               	}
529:               
530:               	return rslt;
005A4C  78401E     MOV.B [W14], W0
531:               }
005A4E  FA8000     ULNK
005A50  060000     RETURN
532:               
533:               /*!
534:                * @brief This API is used to get the oversampling, filter and T,P,H, gas selection
535:                * settings in the sensor.
536:                */
537:               int8_t bme680_get_sensor_settings(uint16_t desired_settings, struct bme680_dev *dev)
538:               {
005A52  FA000C     LNK #0xC
005A54  980740     MOV W0, [W14+8]
005A56  980751     MOV W1, [W14+10]
539:               	int8_t rslt;
540:               	/* starting address of the register array for burst read*/
541:               	uint8_t reg_addr = BME680_CONF_HEAT_CTRL_ADDR;
005A58  B3C700     MOV.B #0x70, W0
005A5A  984710     MOV.B W0, [W14+1]
542:               	uint8_t data_array[BME680_REG_BUFFER_LENGTH] = { 0 };
005A5C  4700E2     ADD W14, #0x2, W1
005A5E  090002     REPEAT #0x2
005A60  EB1880     CLR [W1++]
543:               
544:               	/* Check for null pointer in the device structure*/
545:               	rslt = null_ptr_check(dev);
005A62  90005E     MOV [W14+10], W0
005A64  070912     RCALL _null_ptr_check, .LFE23, .LFB24
005A66  784F00     MOV.B W0, [W14]
546:               	if (rslt == BME680_OK) {
005A68  78401E     MOV.B [W14], W0
005A6A  E00400     CP0.B W0
005A6C  3A004F     BRA NZ, .L41
547:               		rslt = bme680_get_regs(reg_addr, data_array, BME680_REG_BUFFER_LENGTH, dev);
005A6E  E8800E     INC2 W14, W0
005A70  9001DE     MOV [W14+10], W3
005A72  200062     MOV #0x6, W2
005A74  780080     MOV W0, W1
005A76  90401E     MOV.B [W14+1], W0
005A78  07FDDB     RCALL bme680_get_regs
005A7A  784F00     MOV.B W0, [W14]
548:               
549:               		if (rslt == BME680_OK) {
005A7C  78401E     MOV.B [W14], W0
005A7E  E00400     CP0.B W0
005A80  3A0047     BRA NZ, .L42
550:               			if (desired_settings & BME680_GAS_MEAS_SEL)
005A82  90004E     MOV [W14+8], W0
005A84  600068     AND W0, #0x8, W0
005A86  E00000     CP0 W0
005A88  320003     BRA Z, .L43
551:               				rslt = get_gas_config(dev);
005A8A  90005E     MOV [W14+10], W0
005A8C  0702A0     RCALL _get_gas_config, .LFE12, .LFB13
005A8E  784F00     MOV.B W0, [W14]
552:               
553:               			/* get the T,P,H ,Filter,ODR settings here */
554:               			if (desired_settings & BME680_FILTER_SEL)
005A90  90004E     MOV [W14+8], W0
005A92  600070     AND W0, #0x10, W0
005A94  E00000     CP0 W0
005A96  320007     BRA Z, .L44
555:               				dev->tph_sett.filter = BME680_GET_BITS(data_array[BME680_REG_FILTER_INDEX],
005A98  90407E     MOV.B [W14+7], W0
005A9A  FB8000     ZE W0, W0
005A9C  60007C     AND W0, #0x1C, W0
005AA0  784080     MOV.B W0, W1
005AA2  90005E     MOV [W14+10], W0
005AA4  987071     MOV.B W1, [W0+55]
556:               					BME680_FILTER);
005A9E  DE8042     ASR W0, #2, W0
557:               
558:               			if (desired_settings & (BME680_OST_SEL | BME680_OSP_SEL)) {
005AA6  90004E     MOV [W14+8], W0
005AA8  600063     AND W0, #0x3, W0
005AAA  E00000     CP0 W0
005AAC  32000D     BRA Z, .L45
559:               				dev->tph_sett.os_temp = BME680_GET_BITS(data_array[BME680_REG_TEMP_INDEX], BME680_OST);
005AAE  90406E     MOV.B [W14+6], W0
005AB0  FB8000     ZE W0, W0
005AB2  DE0045     LSR W0, #5, W0
005AB4  784080     MOV.B W0, W1
005AB6  90005E     MOV [W14+10], W0
005AB8  987051     MOV.B W1, [W0+53]
560:               				dev->tph_sett.os_pres = BME680_GET_BITS(data_array[BME680_REG_PRES_INDEX], BME680_OSP);
005ABA  90406E     MOV.B [W14+6], W0
005ABC  FB8000     ZE W0, W0
005ABE  60007C     AND W0, #0x1C, W0
005AC0  DE8042     ASR W0, #2, W0
005AC2  784080     MOV.B W0, W1
005AC4  90005E     MOV [W14+10], W0
005AC6  987061     MOV.B W1, [W0+54]
561:               			}
562:               
563:               			if (desired_settings & BME680_OSH_SEL)
005AC8  90004E     MOV [W14+8], W0
005ACA  600064     AND W0, #0x4, W0
005ACC  E00000     CP0 W0
005ACE  320004     BRA Z, .L46
564:               				dev->tph_sett.os_hum = BME680_GET_BITS_POS_0(data_array[BME680_REG_HUM_INDEX],
005AD0  90404E     MOV.B [W14+4], W0
005AD2  6040E7     AND.B W0, #0x7, W1
005AD4  90005E     MOV [W14+10], W0
005AD6  987041     MOV.B W1, [W0+52]
565:               					BME680_OSH);
566:               
567:               			/* get the gas related settings */
568:               			if (desired_settings & BME680_HCNTRL_SEL)
005AD8  9000CE     MOV [W14+8], W1
005ADA  200200     MOV #0x20, W0
005ADC  608000     AND W1, W0, W0
005ADE  E00000     CP0 W0
005AE0  320004     BRA Z, .L47
569:               				dev->gas_sett.heatr_ctrl = BME680_GET_BITS_POS_0(data_array[BME680_REG_HCTRL_INDEX],
005AE2  90402E     MOV.B [W14+2], W0
005AE4  6040E8     AND.B W0, #0x8, W1
005AE6  90005E     MOV [W14+10], W0
005AE8  987811     MOV.B W1, [W0+57]
570:               					BME680_HCTRL);
571:               
572:               			if (desired_settings & (BME680_RUN_GAS_SEL | BME680_NBCONV_SEL)) {
005AEA  9000CE     MOV [W14+8], W1
005AEC  200C00     MOV #0xC0, W0
005AEE  608000     AND W1, W0, W0
005AF0  E00000     CP0 W0
005AF2  32000E     BRA Z, .L42
573:               				dev->gas_sett.nb_conv = BME680_GET_BITS_POS_0(data_array[BME680_REG_NBCONV_INDEX],
005AF4  90403E     MOV.B [W14+3], W0
005AF6  6040EF     AND.B W0, #0xF, W1
005AF8  90005E     MOV [W14+10], W0
005AFA  987801     MOV.B W1, [W0+56]
574:               					BME680_NBCONV);
575:               				dev->gas_sett.run_gas = BME680_GET_BITS(data_array[BME680_REG_RUN_GAS_INDEX],
005AFC  90403E     MOV.B [W14+3], W0
005AFE  FB8000     ZE W0, W0
005B00  600070     AND W0, #0x10, W0
005B04  784080     MOV.B W0, W1
005B06  90005E     MOV [W14+10], W0
005B08  987821     MOV.B W1, [W0+58]
005B0A  370002     BRA .L42
576:               					BME680_RUN_GAS);
005B02  DE8044     ASR W0, #4, W0
577:               			}
578:               		}
579:               	} else {
580:               		rslt = BME680_E_NULL_PTR;
005B0C  EBC000     SETM.B W0
005B0E  784F00     MOV.B W0, [W14]
581:               	}
582:               
583:               	return rslt;
005B10  78401E     MOV.B [W14], W0
584:               }
005B12  FA8000     ULNK
005B14  060000     RETURN
585:               
586:               /*!
587:                * @brief This API is used to set the power mode of the sensor.
588:                */
589:               int8_t bme680_set_sensor_mode(struct bme680_dev *dev)
590:               {
005B16  FA0006     LNK #0x6
005B18  980720     MOV W0, [W14+4]
591:               	int8_t rslt;
592:               	uint8_t tmp_pow_mode;
593:               	uint8_t pow_mode = 0;
005B1A  EB4000     CLR.B W0
005B1C  984710     MOV.B W0, [W14+1]
594:               	uint8_t reg_addr = BME680_CONF_T_P_MODE_ADDR;
005B1E  B3C740     MOV.B #0x74, W0
005B20  984730     MOV.B W0, [W14+3]
595:               
596:               	/* Check for null pointer in the device structure*/
597:               	rslt = null_ptr_check(dev);
005B22  90002E     MOV [W14+4], W0
005B24  0708B2     RCALL _null_ptr_check, .LFE23, .LFB24
005B26  784F00     MOV.B W0, [W14]
598:               	if (rslt == BME680_OK) {
005B28  78401E     MOV.B [W14], W0
005B2A  E00400     CP0.B W0
005B2C  3A0038     BRA NZ, .L49
599:               		/* Call repeatedly until in sleep */
600:               		do {
601:               			rslt = bme680_get_regs(BME680_CONF_T_P_MODE_ADDR, &tmp_pow_mode, 1, dev);
005B2E  E8800E     INC2 W14, W0
005B30  9001AE     MOV [W14+4], W3
005B32  200012     MOV #0x1, W2
005B34  780080     MOV W0, W1
005B36  B3C740     MOV.B #0x74, W0
005B38  07FD7B     RCALL bme680_get_regs
005B3A  784F00     MOV.B W0, [W14]
602:               			if (rslt == BME680_OK) {
005B3C  78401E     MOV.B [W14], W0
005B3E  E00400     CP0.B W0
005B40  3A0015     BRA NZ, .L50
603:               				/* Put to sleep before changing mode */
604:               				pow_mode = (tmp_pow_mode & BME680_MODE_MSK);
005B42  90402E     MOV.B [W14+2], W0
005B44  604063     AND.B W0, #0x3, W0
005B46  984710     MOV.B W0, [W14+1]
605:               
606:               				if (pow_mode != BME680_SLEEP_MODE) {
005B48  90401E     MOV.B [W14+1], W0
005B4A  E00400     CP0.B W0
005B4C  32000F     BRA Z, .L50
607:               					tmp_pow_mode = tmp_pow_mode & (~BME680_MODE_MSK); /* Set to sleep */
005B4E  9040AE     MOV.B [W14+2], W1
005B50  B3CFC0     MOV.B #0xFC, W0
005B52  60C000     AND.B W1, W0, W0
005B54  984720     MOV.B W0, [W14+2]
608:               					rslt = bme680_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
005B56  E8808E     INC2 W14, W1
005B58  470063     ADD W14, #0x3, W0
005B5A  9001AE     MOV [W14+4], W3
005B5C  B3C012     MOV.B #0x1, W2
005B5E  07FD94     RCALL bme680_set_regs
005B60  784F00     MOV.B W0, [W14]
609:               					dev->delay_ms(BME680_POLL_PERIOD_MS);
005B62  90002E     MOV [W14+4], W0
005B64  902140     MOV [W0+72], W2
005B66  2000A0     MOV #0xA, W0
005B68  200001     MOV #0x0, W1
005B6A  010002     CALL W2
610:               				}
611:               			}
612:               		} while (pow_mode != BME680_SLEEP_MODE);
005B6C  90401E     MOV.B [W14+1], W0
005B6E  E00400     CP0.B W0
005B70  3AFFDE     BRA NZ, .L51
613:               
614:               		/* Already in sleep */
615:               		if (dev->power_mode != BME680_SLEEP_MODE) {
005B72  90002E     MOV [W14+4], W0
005B74  90C000     MOV.B [W0+64], W0
005B76  E00400     CP0.B W0
005B78  320012     BRA Z, .L49
616:               			tmp_pow_mode = (tmp_pow_mode & ~BME680_MODE_MSK) | (dev->power_mode & BME680_MODE_MSK);
005B7A  90402E     MOV.B [W14+2], W0
005B7C  784080     MOV.B W0, W1
005B7E  B3CFC0     MOV.B #0xFC, W0
005B80  60C080     AND.B W1, W0, W1
005B82  90002E     MOV [W14+4], W0
005B84  90C000     MOV.B [W0+64], W0
005B86  604063     AND.B W0, #0x3, W0
005B88  70C000     IOR.B W1, W0, W0
005B8A  984720     MOV.B W0, [W14+2]
617:               			if (rslt == BME680_OK)
005B8C  78401E     MOV.B [W14], W0
005B8E  E00400     CP0.B W0
005B90  3A0006     BRA NZ, .L49
618:               				rslt = bme680_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
005B92  E8808E     INC2 W14, W1
005B94  470063     ADD W14, #0x3, W0
005B96  9001AE     MOV [W14+4], W3
005B98  B3C012     MOV.B #0x1, W2
005B9A  07FD76     RCALL bme680_set_regs
005B9C  784F00     MOV.B W0, [W14]
619:               		}
620:               	}
621:               
622:               	return rslt;
005B9E  78401E     MOV.B [W14], W0
623:               }
005BA0  FA8000     ULNK
005BA2  060000     RETURN
624:               
625:               /*!
626:                * @brief This API is used to get the power mode of the sensor.
627:                */
628:               int8_t bme680_get_sensor_mode(struct bme680_dev *dev)
629:               {
005BA4  FA0004     LNK #0x4
005BA6  980710     MOV W0, [W14+2]
630:               	int8_t rslt;
631:               	uint8_t mode;
632:               
633:               	/* Check for null pointer in the device structure*/
634:               	rslt = null_ptr_check(dev);
005BA8  90001E     MOV [W14+2], W0
005BAA  07086F     RCALL _null_ptr_check, .LFE23, .LFB24
005BAC  784F00     MOV.B W0, [W14]
635:               	if (rslt == BME680_OK) {
005BAE  78401E     MOV.B [W14], W0
005BB0  E00400     CP0.B W0
005BB2  3A000B     BRA NZ, .L53
636:               		rslt = bme680_get_regs(BME680_CONF_T_P_MODE_ADDR, &mode, 1, dev);
005BB4  E8000E     INC W14, W0
005BB6  90019E     MOV [W14+2], W3
005BB8  200012     MOV #0x1, W2
005BBA  780080     MOV W0, W1
005BBC  B3C740     MOV.B #0x74, W0
005BBE  07FD38     RCALL bme680_get_regs
005BC0  784F00     MOV.B W0, [W14]
637:               		/* Masking the other register bit info*/
638:               		dev->power_mode = mode & BME680_MODE_MSK;
005BC2  90401E     MOV.B [W14+1], W0
005BC4  6040E3     AND.B W0, #0x3, W1
005BC6  90001E     MOV [W14+2], W0
005BC8  98C001     MOV.B W1, [W0+64]
639:               	}
640:               
641:               	return rslt;
005BCA  78401E     MOV.B [W14], W0
642:               }
005BCC  FA8000     ULNK
005BCE  060000     RETURN
643:               
644:               /*!
645:                * @brief This API is used to set the profile duration of the sensor.
646:                */
647:               void bme680_set_profile_dur(uint16_t duration, struct bme680_dev *dev)
648:               {
005BD0  FA0012     LNK #0x12
005BD2  980770     MOV W0, [W14+14]
005BD4  980F01     MOV W1, [W14+16]
649:               	uint32_t tph_dur; /* Calculate in us */
650:               	uint32_t meas_cycles;
651:               	uint8_t os_to_meas_cycles[6] = {0, 1, 2, 4, 8, 16};
005BD6  4700E8     ADD W14, #0x8, W1
005BD8  2D5D62     MOV #0xD5D6, W2
005BDA  090005     REPEAT #0x5
005BDC  7858B2     MOV.B [W2++], [W1++]
652:               
653:               	meas_cycles = os_to_meas_cycles[dev->tph_sett.os_temp];
005BDE  90080E     MOV [W14+16], W0
005BE0  907050     MOV.B [W0+53], W0
005BE2  FB8000     ZE W0, W0
005BE4  470000     ADD W14, W0, W0
005BE6  904800     MOV.B [W0+8], W0
005BE8  FB8000     ZE W0, W0
005BEA  EB0080     CLR W1
005BEC  BE8F00     MOV.D W0, [W14]
654:               	meas_cycles += os_to_meas_cycles[dev->tph_sett.os_pres];
005BEE  90080E     MOV [W14+16], W0
005BF0  907060     MOV.B [W0+54], W0
005BF2  FB8000     ZE W0, W0
005BF4  470000     ADD W14, W0, W0
005BF6  904800     MOV.B [W0+8], W0
005BF8  FB8000     ZE W0, W0
005BFA  EB0080     CLR W1
005BFC  400F1E     ADD W0, [W14], [W14]
005BFE  48975E     ADDC W1, [++W14], [W14--]
655:               	meas_cycles += os_to_meas_cycles[dev->tph_sett.os_hum];
005C00  90080E     MOV [W14+16], W0
005C02  907040     MOV.B [W0+52], W0
005C04  FB8000     ZE W0, W0
005C06  470000     ADD W14, W0, W0
005C08  904800     MOV.B [W0+8], W0
005C0A  FB8000     ZE W0, W0
005C0C  EB0080     CLR W1
005C0E  400F1E     ADD W0, [W14], [W14]
005C10  48975E     ADDC W1, [++W14], [W14--]
656:               
657:               	/* TPH measurement duration */
658:               	tph_dur = meas_cycles * UINT32_C(1963);
005C12  90009E     MOV [W14+2], W1
005C14  207AB0     MOV #0x7AB, W0
005C16  B98800     MUL.SS W1, W0, W0
005C18  780100     MOV W0, W2
005C1A  78001E     MOV [W14], W0
005C1C  B90060     MUL.SU W0, #0, W0
005C1E  780000     MOV W0, W0
005C20  410100     ADD W2, W0, W2
005C22  78009E     MOV [W14], W1
005C24  207AB0     MOV #0x7AB, W0
005C26  B80800     MUL.UU W1, W0, W0
005C28  410101     ADD W2, W1, W2
005C2A  780082     MOV W2, W1
005C2C  980720     MOV W0, [W14+4]
005C2E  980731     MOV W1, [W14+6]
005C30  980720     MOV W0, [W14+4]
005C32  980731     MOV W1, [W14+6]
659:               	tph_dur += UINT32_C(477 * 4); /* TPH switching duration */
005C34  90012E     MOV [W14+4], W2
005C36  9001BE     MOV [W14+6], W3
005C38  207740     MOV #0x774, W0
005C3A  200001     MOV #0x0, W1
005C3C  400002     ADD W0, W2, W0
005C3E  488083     ADDC W1, W3, W1
005C40  980720     MOV W0, [W14+4]
005C42  980731     MOV W1, [W14+6]
660:               	tph_dur += UINT32_C(477 * 5); /* Gas measurement duration */
005C44  90012E     MOV [W14+4], W2
005C46  9001BE     MOV [W14+6], W3
005C48  209510     MOV #0x951, W0
005C4A  200001     MOV #0x0, W1
005C4C  400002     ADD W0, W2, W0
005C4E  488083     ADDC W1, W3, W1
005C50  980720     MOV W0, [W14+4]
005C52  980731     MOV W1, [W14+6]
661:               	tph_dur += UINT32_C(500); /* Get it to the closest whole number.*/
005C54  90002E     MOV [W14+4], W0
005C56  9000BE     MOV [W14+6], W1
005C58  B01F40     ADD #0x1F4, W0
005C5A  B08001     ADDC #0x0, W1
005C5C  980720     MOV W0, [W14+4]
005C5E  980731     MOV W1, [W14+6]
662:               	tph_dur /= UINT32_C(1000); /* Convert to ms */
005C60  90002E     MOV [W14+4], W0
005C62  9000BE     MOV [W14+6], W1
005C64  203E82     MOV #0x3E8, W2
005C66  200003     MOV #0x0, W3
005C68  07D59A     RCALL ___udivsi3
005C6A  980720     MOV W0, [W14+4]
005C6C  980731     MOV W1, [W14+6]
663:               
664:               	tph_dur += UINT32_C(1); /* Wake up duration of 1ms */
005C6E  90002E     MOV [W14+4], W0
005C70  9000BE     MOV [W14+6], W1
005C72  400061     ADD W0, #0x1, W0
005C74  4880E0     ADDC W1, #0x0, W1
005C76  980720     MOV W0, [W14+4]
005C78  980731     MOV W1, [W14+6]
665:               	/* The remaining time should be used for heating */
666:               	dev->gas_sett.heatr_dur = duration - (uint16_t) tph_dur;
005C7A  90002E     MOV [W14+4], W0
005C7C  9000FE     MOV [W14+14], W1
005C7E  508080     SUB W1, W0, W1
005C80  90080E     MOV [W14+16], W0
005C82  981871     MOV W1, [W0+62]
667:               }
005C84  FA8000     ULNK
005C86  060000     RETURN
668:               
669:               /*!
670:                * @brief This API is used to get the profile duration of the sensor.
671:                */
672:               void bme680_get_profile_dur(uint16_t *duration, const struct bme680_dev *dev)
673:               {
005C88  FA0012     LNK #0x12
005C8A  980770     MOV W0, [W14+14]
005C8C  980F01     MOV W1, [W14+16]
674:               	uint32_t tph_dur; /* Calculate in us */
675:               	uint32_t meas_cycles;
676:               	uint8_t os_to_meas_cycles[6] = {0, 1, 2, 4, 8, 16};
005C8E  4700E8     ADD W14, #0x8, W1
005C90  2D5D02     MOV #0xD5D0, W2
005C92  090005     REPEAT #0x5
005C94  7858B2     MOV.B [W2++], [W1++]
677:               
678:               	meas_cycles = os_to_meas_cycles[dev->tph_sett.os_temp];
005C96  90080E     MOV [W14+16], W0
005C98  907050     MOV.B [W0+53], W0
005C9A  FB8000     ZE W0, W0
005C9C  470000     ADD W14, W0, W0
005C9E  904800     MOV.B [W0+8], W0
005CA0  FB8000     ZE W0, W0
005CA2  EB0080     CLR W1
005CA4  BE8F00     MOV.D W0, [W14]
679:               	meas_cycles += os_to_meas_cycles[dev->tph_sett.os_pres];
005CA6  90080E     MOV [W14+16], W0
005CA8  907060     MOV.B [W0+54], W0
005CAA  FB8000     ZE W0, W0
005CAC  470000     ADD W14, W0, W0
005CAE  904800     MOV.B [W0+8], W0
005CB0  FB8000     ZE W0, W0
005CB2  EB0080     CLR W1
005CB4  400F1E     ADD W0, [W14], [W14]
005CB6  48975E     ADDC W1, [++W14], [W14--]
680:               	meas_cycles += os_to_meas_cycles[dev->tph_sett.os_hum];
005CB8  90080E     MOV [W14+16], W0
005CBA  907040     MOV.B [W0+52], W0
005CBC  FB8000     ZE W0, W0
005CBE  470000     ADD W14, W0, W0
005CC0  904800     MOV.B [W0+8], W0
005CC2  FB8000     ZE W0, W0
005CC4  EB0080     CLR W1
005CC6  400F1E     ADD W0, [W14], [W14]
005CC8  48975E     ADDC W1, [++W14], [W14--]
681:               
682:               	/* TPH measurement duration */
683:               	tph_dur = meas_cycles * UINT32_C(1963);
005CCA  90009E     MOV [W14+2], W1
005CCC  207AB0     MOV #0x7AB, W0
005CCE  B98800     MUL.SS W1, W0, W0
005CD0  780100     MOV W0, W2
005CD2  78001E     MOV [W14], W0
005CD4  B90060     MUL.SU W0, #0, W0
005CD6  780000     MOV W0, W0
005CD8  410100     ADD W2, W0, W2
005CDA  78009E     MOV [W14], W1
005CDC  207AB0     MOV #0x7AB, W0
005CDE  B80800     MUL.UU W1, W0, W0
005CE0  410101     ADD W2, W1, W2
005CE2  780082     MOV W2, W1
005CE4  980720     MOV W0, [W14+4]
005CE6  980731     MOV W1, [W14+6]
005CE8  980720     MOV W0, [W14+4]
005CEA  980731     MOV W1, [W14+6]
684:               	tph_dur += UINT32_C(477 * 4); /* TPH switching duration */
005CEC  90012E     MOV [W14+4], W2
005CEE  9001BE     MOV [W14+6], W3
005CF0  207740     MOV #0x774, W0
005CF2  200001     MOV #0x0, W1
005CF4  400002     ADD W0, W2, W0
005CF6  488083     ADDC W1, W3, W1
005CF8  980720     MOV W0, [W14+4]
005CFA  980731     MOV W1, [W14+6]
685:               	tph_dur += UINT32_C(477 * 5); /* Gas measurement duration */
005CFC  90012E     MOV [W14+4], W2
005CFE  9001BE     MOV [W14+6], W3
005D00  209510     MOV #0x951, W0
005D02  200001     MOV #0x0, W1
005D04  400002     ADD W0, W2, W0
005D06  488083     ADDC W1, W3, W1
005D08  980720     MOV W0, [W14+4]
005D0A  980731     MOV W1, [W14+6]
686:               	tph_dur += UINT32_C(500); /* Get it to the closest whole number.*/
005D0C  90002E     MOV [W14+4], W0
005D0E  9000BE     MOV [W14+6], W1
005D10  B01F40     ADD #0x1F4, W0
005D12  B08001     ADDC #0x0, W1
005D14  980720     MOV W0, [W14+4]
005D16  980731     MOV W1, [W14+6]
687:               	tph_dur /= UINT32_C(1000); /* Convert to ms */
005D18  90002E     MOV [W14+4], W0
005D1A  9000BE     MOV [W14+6], W1
005D1C  203E82     MOV #0x3E8, W2
005D1E  200003     MOV #0x0, W3
005D20  07D53E     RCALL ___udivsi3
005D22  980720     MOV W0, [W14+4]
005D24  980731     MOV W1, [W14+6]
688:               
689:               	tph_dur += UINT32_C(1); /* Wake up duration of 1ms */
005D26  90002E     MOV [W14+4], W0
005D28  9000BE     MOV [W14+6], W1
005D2A  400061     ADD W0, #0x1, W0
005D2C  4880E0     ADDC W1, #0x0, W1
005D2E  980720     MOV W0, [W14+4]
005D30  980731     MOV W1, [W14+6]
690:               
691:               	*duration = (uint16_t) tph_dur;
005D32  9000AE     MOV [W14+4], W1
005D34  90007E     MOV [W14+14], W0
005D36  780801     MOV W1, [W0]
692:               
693:               	/* Get the gas duration only when the run gas is enabled */
694:               	if (dev->gas_sett.run_gas) {
005D38  90080E     MOV [W14+16], W0
005D3A  907820     MOV.B [W0+58], W0
005D3C  E00400     CP0.B W0
005D3E  320007     BRA Z, .L55
695:               		/* The remaining time should be used for heating */
696:               		*duration += dev->gas_sett.heatr_dur;
005D40  90007E     MOV [W14+14], W0
005D42  780090     MOV [W0], W1
005D44  90080E     MOV [W14+16], W0
005D46  901870     MOV [W0+62], W0
005D48  408080     ADD W1, W0, W1
005D4A  90007E     MOV [W14+14], W0
005D4C  780801     MOV W1, [W0]
697:               	}
698:               }
005D4E  FA8000     ULNK
005D50  060000     RETURN
699:               
700:               /*!
701:                * @brief This API reads the pressure, temperature and humidity and gas data
702:                * from the sensor, compensates the data and store it in the bme680_data
703:                * structure instance passed by the user.
704:                */
705:               int8_t bme680_get_sensor_data(struct bme680_field_data *data, struct bme680_dev *dev)
706:               {
005D52  FA0006     LNK #0x6
005D54  980710     MOV W0, [W14+2]
005D56  980721     MOV W1, [W14+4]
707:               	int8_t rslt;
708:               
709:               	/* Check for null pointer in the device structure*/
710:               	rslt = null_ptr_check(dev);
005D58  90002E     MOV [W14+4], W0
005D5A  070797     RCALL _null_ptr_check, .LFE23, .LFB24
005D5C  784F00     MOV.B W0, [W14]
711:               	if (rslt == BME680_OK) {
005D5E  78401E     MOV.B [W14], W0
005D60  E00400     CP0.B W0
005D62  3A0012     BRA NZ, .L58
712:               		/* Reading the sensor data in forced mode only */
713:               		rslt = read_field_data(data, dev);
005D64  9000AE     MOV [W14+4], W1
005D66  90001E     MOV [W14+2], W0
005D68  07064C     RCALL _read_field_data, .LFE19, .LFB20
005D6A  784F00     MOV.B W0, [W14]
714:               		if (rslt == BME680_OK) {
005D6C  78401E     MOV.B [W14], W0
005D6E  E00400     CP0.B W0
005D70  3A000B     BRA NZ, .L58
715:               			if (data->status & BME680_NEW_DATA_MSK)
005D72  90001E     MOV [W14+2], W0
005D74  784010     MOV.B [W0], W0
005D76  E00400     CP0.B W0
005D78  3D0004     BRA GE, .L59
716:               				dev->new_fields = 1;
005D7A  90002E     MOV [W14+4], W0
005D7C  B3C011     MOV.B #0x1, W1
005D7E  98C011     MOV.B W1, [W0+65]
005D80  370003     BRA .L58
717:               			else
718:               				dev->new_fields = 0;
005D82  90002E     MOV [W14+4], W0
005D84  EB4080     CLR.B W1
005D86  98C011     MOV.B W1, [W0+65]
719:               		}
720:               	}
721:               
722:               	return rslt;
005D88  78401E     MOV.B [W14], W0
723:               }
005D8A  FA8000     ULNK
005D8C  060000     RETURN
724:               
725:               /*!
726:                * @brief This internal API is used to read the calibrated data from the sensor.
727:                */
728:               static int8_t get_calib_data(struct bme680_dev *dev)
729:               {
005D8E  FA002E     LNK #0x2E
005D90  981760     MOV W0, [W14+44]
730:               	int8_t rslt;
731:               	uint8_t coeff_array[BME680_COEFF_SIZE] = { 0 };
005D92  4700E1     ADD W14, #0x1, W1
005D94  090028     REPEAT #0x28
005D96  EB5880     CLR.B [W1++]
732:               	uint8_t temp_var = 0; /* Temporary variable */
005D98  EB4000     CLR.B W0
005D9A  986F20     MOV.B W0, [W14+42]
733:               
734:               	/* Check for null pointer in the device structure*/
735:               	rslt = null_ptr_check(dev);
005D9C  90106E     MOV [W14+44], W0
005D9E  070775     RCALL _null_ptr_check, .LFE23, .LFB24
005DA0  784F00     MOV.B W0, [W14]
736:               	if (rslt == BME680_OK) {
005DA2  78401E     MOV.B [W14], W0
005DA4  E00400     CP0.B W0
005DA6  3A00DF     BRA NZ, .L61
737:               		rslt = bme680_get_regs(BME680_COEFF_ADDR1, coeff_array, BME680_COEFF_ADDR1_LEN, dev);
005DA8  E8000E     INC W14, W0
005DAA  9011EE     MOV [W14+44], W3
005DAC  200192     MOV #0x19, W2
005DAE  780080     MOV W0, W1
005DB0  B3C890     MOV.B #0x89, W0
005DB2  07FC3E     RCALL bme680_get_regs
005DB4  784F00     MOV.B W0, [W14]
738:               		/* Append the second half in the same array */
739:               		if (rslt == BME680_OK)
005DB6  78401E     MOV.B [W14], W0
005DB8  E00400     CP0.B W0
005DBA  3A0008     BRA NZ, .L62
740:               			rslt = bme680_get_regs(BME680_COEFF_ADDR2, &coeff_array[BME680_COEFF_ADDR1_LEN]
005DBC  E8000E     INC W14, W0
005DBE  400079     ADD W0, #0x19, W0
005DC0  9011EE     MOV [W14+44], W3
005DC2  200102     MOV #0x10, W2
005DC4  780080     MOV W0, W1
005DC6  B3CE10     MOV.B #0xE1, W0
005DC8  07FC33     RCALL bme680_get_regs
005DCA  784F00     MOV.B W0, [W14]
741:               			, BME680_COEFF_ADDR2_LEN, dev);
742:               
743:               		/* Temperature related coefficients */
744:               		dev->calib.par_t1 = (uint16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_T1_MSB_REG],
005DCC  90603E     MOV.B [W14+35], W0
005DCE  FB8000     ZE W0, W0
005DD0  DD00C8     SL W0, #8, W1
005DD2  90602E     MOV.B [W14+34], W0
005DD4  FB8000     ZE W0, W0
005DD6  700081     IOR W0, W1, W1
005DD8  90106E     MOV [W14+44], W0
005DDA  980821     MOV W1, [W0+20]
745:               			coeff_array[BME680_T1_LSB_REG]));
746:               		dev->calib.par_t2 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_T2_MSB_REG],
005DDC  90403E     MOV.B [W14+3], W0
005DDE  FB8000     ZE W0, W0
005DE0  DD00C8     SL W0, #8, W1
005DE2  90402E     MOV.B [W14+2], W0
005DE4  FB8000     ZE W0, W0
005DE6  700001     IOR W0, W1, W0
005DE8  780080     MOV W0, W1
005DEA  90106E     MOV [W14+44], W0
005DEC  980831     MOV W1, [W0+22]
747:               			coeff_array[BME680_T2_LSB_REG]));
748:               		dev->calib.par_t3 = (int8_t) (coeff_array[BME680_T3_REG]);
005DEE  90404E     MOV.B [W14+4], W0
005DF0  784080     MOV.B W0, W1
005DF2  90106E     MOV [W14+44], W0
005DF4  985801     MOV.B W1, [W0+24]
749:               
750:               		/* Pressure related coefficients */
751:               		dev->calib.par_p1 = (uint16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P1_MSB_REG],
005DF6  90407E     MOV.B [W14+7], W0
005DF8  FB8000     ZE W0, W0
005DFA  DD00C8     SL W0, #8, W1
005DFC  90406E     MOV.B [W14+6], W0
005DFE  FB8000     ZE W0, W0
005E00  700081     IOR W0, W1, W1
005E02  90106E     MOV [W14+44], W0
005E04  980851     MOV W1, [W0+26]
752:               			coeff_array[BME680_P1_LSB_REG]));
753:               		dev->calib.par_p2 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P2_MSB_REG],
005E06  90481E     MOV.B [W14+9], W0
005E08  FB8000     ZE W0, W0
005E0A  DD00C8     SL W0, #8, W1
005E0C  90480E     MOV.B [W14+8], W0
005E0E  FB8000     ZE W0, W0
005E10  700001     IOR W0, W1, W0
005E12  780080     MOV W0, W1
005E14  90106E     MOV [W14+44], W0
005E16  980861     MOV W1, [W0+28]
754:               			coeff_array[BME680_P2_LSB_REG]));
755:               		dev->calib.par_p3 = (int8_t) coeff_array[BME680_P3_REG];
005E18  90482E     MOV.B [W14+10], W0
005E1A  784080     MOV.B W0, W1
005E1C  90106E     MOV [W14+44], W0
005E1E  985861     MOV.B W1, [W0+30]
756:               		dev->calib.par_p4 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P4_MSB_REG],
005E20  90485E     MOV.B [W14+13], W0
005E22  FB8000     ZE W0, W0
005E24  DD00C8     SL W0, #8, W1
005E26  90484E     MOV.B [W14+12], W0
005E28  FB8000     ZE W0, W0
005E2A  700001     IOR W0, W1, W0
005E2C  780080     MOV W0, W1
005E2E  90106E     MOV [W14+44], W0
005E30  981001     MOV W1, [W0+32]
757:               			coeff_array[BME680_P4_LSB_REG]));
758:               		dev->calib.par_p5 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P5_MSB_REG],
005E32  90487E     MOV.B [W14+15], W0
005E34  FB8000     ZE W0, W0
005E36  DD00C8     SL W0, #8, W1
005E38  90486E     MOV.B [W14+14], W0
005E3A  FB8000     ZE W0, W0
005E3C  700001     IOR W0, W1, W0
005E3E  780080     MOV W0, W1
005E40  90106E     MOV [W14+44], W0
005E42  981011     MOV W1, [W0+34]
759:               			coeff_array[BME680_P5_LSB_REG]));
760:               		dev->calib.par_p6 = (int8_t) (coeff_array[BME680_P6_REG]);
005E44  90501E     MOV.B [W14+17], W0
005E46  784080     MOV.B W0, W1
005E48  90106E     MOV [W14+44], W0
005E4A  986041     MOV.B W1, [W0+36]
761:               		dev->calib.par_p7 = (int8_t) (coeff_array[BME680_P7_REG]);
005E4C  90500E     MOV.B [W14+16], W0
005E4E  784080     MOV.B W0, W1
005E50  90106E     MOV [W14+44], W0
005E52  986051     MOV.B W1, [W0+37]
762:               		dev->calib.par_p8 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P8_MSB_REG],
005E54  90505E     MOV.B [W14+21], W0
005E56  FB8000     ZE W0, W0
005E58  DD00C8     SL W0, #8, W1
005E5A  90504E     MOV.B [W14+20], W0
005E5C  FB8000     ZE W0, W0
005E5E  700001     IOR W0, W1, W0
005E60  780080     MOV W0, W1
005E62  90106E     MOV [W14+44], W0
005E64  981031     MOV W1, [W0+38]
763:               			coeff_array[BME680_P8_LSB_REG]));
764:               		dev->calib.par_p9 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P9_MSB_REG],
005E66  90507E     MOV.B [W14+23], W0
005E68  FB8000     ZE W0, W0
005E6A  DD00C8     SL W0, #8, W1
005E6C  90506E     MOV.B [W14+22], W0
005E6E  FB8000     ZE W0, W0
005E70  700001     IOR W0, W1, W0
005E72  780080     MOV W0, W1
005E74  90106E     MOV [W14+44], W0
005E76  981041     MOV W1, [W0+40]
765:               			coeff_array[BME680_P9_LSB_REG]));
766:               		dev->calib.par_p10 = (uint8_t) (coeff_array[BME680_P10_REG]);
005E78  90588E     MOV.B [W14+24], W1
005E7A  90106E     MOV [W14+44], W0
005E7C  986821     MOV.B W1, [W0+42]
767:               
768:               		/* Humidity related coefficients */
769:               		dev->calib.par_h1 = (uint16_t) (((uint16_t) coeff_array[BME680_H1_MSB_REG] << BME680_HUM_REG_SHIFT_VAL)
005E7E  90584E     MOV.B [W14+28], W0
005E80  FB8000     ZE W0, W0
005E82  DD00C4     SL W0, #4, W1
005E86  FB8000     ZE W0, W0
005E88  60006F     AND W0, #0xF, W0
005E8A  700081     IOR W0, W1, W1
005E8C  90106E     MOV [W14+44], W0
005E8E  980031     MOV W1, [W0+6]
770:               			| (coeff_array[BME680_H1_LSB_REG] & BME680_BIT_H1_DATA_MSK));
005E84  90583E     MOV.B [W14+27], W0
771:               		dev->calib.par_h2 = (uint16_t) (((uint16_t) coeff_array[BME680_H2_MSB_REG] << BME680_HUM_REG_SHIFT_VAL)
005E90  90582E     MOV.B [W14+26], W0
005E92  FB8000     ZE W0, W0
005E94  DD00C4     SL W0, #4, W1
005E98  FB8000     ZE W0, W0
005E9A  DE0044     LSR W0, #4, W0
005E9C  784000     MOV.B W0, W0
005E9E  FB8000     ZE W0, W0
005EA0  700081     IOR W0, W1, W1
005EA2  90106E     MOV [W14+44], W0
005EA4  980041     MOV W1, [W0+8]
772:               			| ((coeff_array[BME680_H2_LSB_REG]) >> BME680_HUM_REG_SHIFT_VAL));
005E96  90583E     MOV.B [W14+27], W0
773:               		dev->calib.par_h3 = (int8_t) coeff_array[BME680_H3_REG];
005EA6  90585E     MOV.B [W14+29], W0
005EA8  784080     MOV.B W0, W1
005EAA  90106E     MOV [W14+44], W0
005EAC  984821     MOV.B W1, [W0+10]
774:               		dev->calib.par_h4 = (int8_t) coeff_array[BME680_H4_REG];
005EAE  90586E     MOV.B [W14+30], W0
005EB0  784080     MOV.B W0, W1
005EB2  90106E     MOV [W14+44], W0
005EB4  984831     MOV.B W1, [W0+11]
775:               		dev->calib.par_h5 = (int8_t) coeff_array[BME680_H5_REG];
005EB6  90587E     MOV.B [W14+31], W0
005EB8  784080     MOV.B W0, W1
005EBA  90106E     MOV [W14+44], W0
005EBC  984841     MOV.B W1, [W0+12]
776:               		dev->calib.par_h6 = (uint8_t) coeff_array[BME680_H6_REG];
005EBE  90608E     MOV.B [W14+32], W1
005EC0  90106E     MOV [W14+44], W0
005EC2  984851     MOV.B W1, [W0+13]
777:               		dev->calib.par_h7 = (int8_t) coeff_array[BME680_H7_REG];
005EC4  90601E     MOV.B [W14+33], W0
005EC6  784080     MOV.B W0, W1
005EC8  90106E     MOV [W14+44], W0
005ECA  984861     MOV.B W1, [W0+14]
778:               
779:               		/* Gas heater related coefficients */
780:               		dev->calib.par_gh1 = (int8_t) coeff_array[BME680_GH1_REG];
005ECC  90606E     MOV.B [W14+38], W0
005ECE  784080     MOV.B W0, W1
005ED0  90106E     MOV [W14+44], W0
005ED2  984871     MOV.B W1, [W0+15]
781:               		dev->calib.par_gh2 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_GH2_MSB_REG],
005ED4  90605E     MOV.B [W14+37], W0
005ED6  FB8000     ZE W0, W0
005ED8  DD00C8     SL W0, #8, W1
005EDA  90604E     MOV.B [W14+36], W0
005EDC  FB8000     ZE W0, W0
005EDE  700001     IOR W0, W1, W0
005EE0  780080     MOV W0, W1
005EE2  90106E     MOV [W14+44], W0
005EE4  980801     MOV W1, [W0+16]
782:               			coeff_array[BME680_GH2_LSB_REG]));
783:               		dev->calib.par_gh3 = (int8_t) coeff_array[BME680_GH3_REG];
005EE6  90607E     MOV.B [W14+39], W0
005EE8  784080     MOV.B W0, W1
005EEA  90106E     MOV [W14+44], W0
005EEC  985021     MOV.B W1, [W0+18]
784:               
785:               		/* Other coefficients */
786:               		if (rslt == BME680_OK) {
005EEE  78401E     MOV.B [W14], W0
005EF0  E00400     CP0.B W0
005EF2  3A002D     BRA NZ, .L63
787:               			rslt = bme680_get_regs(BME680_ADDR_RES_HEAT_RANGE_ADDR, &temp_var, 1, dev);
005EF4  2002A0     MOV #0x2A, W0
005EF6  40000E     ADD W0, W14, W0
005EF8  9011EE     MOV [W14+44], W3
005EFA  200012     MOV #0x1, W2
005EFC  780080     MOV W0, W1
005EFE  B3C020     MOV.B #0x2, W0
005F00  07FB97     RCALL bme680_get_regs
005F02  784F00     MOV.B W0, [W14]
788:               
789:               			dev->calib.res_heat_range = ((temp_var & BME680_RHRANGE_MSK) / 16);
005F04  90682E     MOV.B [W14+42], W0
005F06  FB8080     ZE W0, W1
005F08  200300     MOV #0x30, W0
005F0A  608000     AND W1, W0, W0
005F0C  E00000     CP0 W0
005F0E  3D0001     BRA GE, .L64
005F10  40006F     ADD W0, #0xF, W0
005F12  DE8044     ASR W0, #4, W0
005F14  784080     MOV.B W0, W1
005F16  90106E     MOV [W14+44], W0
005F18  987001     MOV.B W1, [W0+48]
790:               			if (rslt == BME680_OK) {
005F1A  78401E     MOV.B [W14], W0
005F1C  E00400     CP0.B W0
005F1E  3A0017     BRA NZ, .L63
791:               				rslt = bme680_get_regs(BME680_ADDR_RES_HEAT_VAL_ADDR, &temp_var, 1, dev);
005F20  2002A0     MOV #0x2A, W0
005F22  40000E     ADD W0, W14, W0
005F24  9011EE     MOV [W14+44], W3
005F26  200012     MOV #0x1, W2
005F28  780080     MOV W0, W1
005F2A  EB4000     CLR.B W0
005F2C  07FB81     RCALL bme680_get_regs
005F2E  784F00     MOV.B W0, [W14]
792:               
793:               				dev->calib.res_heat_val = (int8_t) temp_var;
005F30  90682E     MOV.B [W14+42], W0
005F32  784080     MOV.B W0, W1
005F34  90106E     MOV [W14+44], W0
005F36  987011     MOV.B W1, [W0+49]
794:               				if (rslt == BME680_OK)
005F38  78401E     MOV.B [W14], W0
005F3A  E00400     CP0.B W0
005F3C  3A0008     BRA NZ, .L63
795:               					rslt = bme680_get_regs(BME680_ADDR_RANGE_SW_ERR_ADDR, &temp_var, 1, dev);
005F3E  2002A0     MOV #0x2A, W0
005F40  40000E     ADD W0, W14, W0
005F42  9011EE     MOV [W14+44], W3
005F44  200012     MOV #0x1, W2
005F46  780080     MOV W0, W1
005F48  B3C040     MOV.B #0x4, W0
005F4A  07FB72     RCALL bme680_get_regs
005F4C  784F00     MOV.B W0, [W14]
796:               			}
797:               		}
798:               		dev->calib.range_sw_err = ((int8_t) temp_var & (int8_t) BME680_RSERROR_MSK) / 16;
005F4E  90682E     MOV.B [W14+42], W0
005F50  784080     MOV.B W0, W1
005F52  B3CF00     MOV.B #0xF0, W0
005F54  60C000     AND.B W1, W0, W0
005F56  FB0000     SE W0, W0
005F58  E00000     CP0 W0
005F5A  3D0001     BRA GE, .L65
005F5C  40006F     ADD W0, #0xF, W0
005F5E  DE8044     ASR W0, #4, W0
005F60  784080     MOV.B W0, W1
005F62  90106E     MOV [W14+44], W0
005F64  987021     MOV.B W1, [W0+50]
799:               	}
800:               
801:               	return rslt;
005F66  78401E     MOV.B [W14], W0
802:               }
005F68  FA8000     ULNK
005F6A  060000     RETURN
803:               
804:               /*!
805:                * @brief This internal API is used to set the gas configuration of the sensor.
806:                */
807:               static int8_t set_gas_config(struct bme680_dev *dev)
808:               {
005F6C  FA0008     LNK #0x8
005F6E  980730     MOV W0, [W14+6]
809:               	int8_t rslt;
810:               
811:               	/* Check for null pointer in the device structure*/
812:               	rslt = null_ptr_check(dev);
005F70  90003E     MOV [W14+6], W0
005F72  07068B     RCALL _null_ptr_check, .LFE23, .LFB24
005F74  784F00     MOV.B W0, [W14]
813:               	if (rslt == BME680_OK) {
005F76  78401E     MOV.B [W14], W0
005F78  E00400     CP0.B W0
005F7A  3A0026     BRA NZ, .L67, .LBE2
814:               
815:               		uint8_t reg_addr[2] = {0};
005F7C  4700E1     ADD W14, #0x1, W1
005F7E  090001     REPEAT #0x1
005F80  EB5880     CLR.B [W1++]
816:               		uint8_t reg_data[2] = {0};
005F82  4700E3     ADD W14, #0x3, W1
005F84  090001     REPEAT #0x1
005F86  EB5880     CLR.B [W1++]
817:               
818:               		if (dev->power_mode == BME680_FORCED_MODE) {
005F88  90003E     MOV [W14+6], W0
005F8A  90C000     MOV.B [W0+64], W0
005F8C  504FE1     SUB.B W0, #0x1, [W15]
005F8E  3A0011     BRA NZ, .L68
819:               			reg_addr[0] = BME680_RES_HEAT0_ADDR;
005F90  B3C5A0     MOV.B #0x5A, W0
005F92  984710     MOV.B W0, [W14+1]
820:               			reg_data[0] = calc_heater_res(dev->gas_sett.heatr_temp, dev);
005F94  90003E     MOV [W14+6], W0
005F96  901860     MOV [W0+60], W0
005F98  9000BE     MOV [W14+6], W1
005F9A  070477     RCALL _calc_heater_res, .LFE17, .LFB18
005F9C  984730     MOV.B W0, [W14+3]
821:               			reg_addr[1] = BME680_GAS_WAIT0_ADDR;
005F9E  B3C640     MOV.B #0x64, W0
005FA0  984720     MOV.B W0, [W14+2]
822:               			reg_data[1] = calc_heater_dur(dev->gas_sett.heatr_dur);
005FA2  90003E     MOV [W14+6], W0
005FA4  901870     MOV [W0+62], W0
005FA6  070510     RCALL _calc_heater_dur, .LFE18, .LFB19
005FA8  984740     MOV.B W0, [W14+4]
823:               			dev->gas_sett.nb_conv = 0;
005FAA  90003E     MOV [W14+6], W0
005FAC  EB4080     CLR.B W1
005FAE  987801     MOV.B W1, [W0+56]
005FB0  370002     BRA .L69
824:               		} else {
825:               			rslt = BME680_W_DEFINE_PWR_MODE;
005FB2  B3C010     MOV.B #0x1, W0
005FB4  784F00     MOV.B W0, [W14]
826:               		}
827:               		if (rslt == BME680_OK)
005FB6  78401E     MOV.B [W14], W0
005FB8  E00400     CP0.B W0
005FBA  3A0006     BRA NZ, .L67, .LBE2
828:               			rslt = bme680_set_regs(reg_addr, reg_data, 2, dev);
005FBC  4700E3     ADD W14, #0x3, W1
005FBE  E8000E     INC W14, W0
005FC0  9001BE     MOV [W14+6], W3
005FC2  B3C022     MOV.B #0x2, W2
005FC4  07FB61     RCALL bme680_set_regs
005FC6  784F00     MOV.B W0, [W14]
829:               	}
830:               
831:               	return rslt;
005FC8  78401E     MOV.B [W14], W0
832:               }
005FCA  FA8000     ULNK
005FCC  060000     RETURN
833:               
834:               /*!
835:                * @brief This internal API is used to get the gas configuration of the sensor.
836:                * @note heatr_temp and heatr_dur values are currently register data
837:                * and not the actual values set
838:                */
839:               static int8_t get_gas_config(struct bme680_dev *dev)
840:               {
005FCE  FA0006     LNK #0x6
005FD0  980720     MOV W0, [W14+4]
841:               	int8_t rslt;
842:               	/* starting address of the register array for burst read*/
843:               	uint8_t reg_addr1 = BME680_ADDR_SENS_CONF_START;
005FD2  B3C5A0     MOV.B #0x5A, W0
005FD4  984710     MOV.B W0, [W14+1]
844:               	uint8_t reg_addr2 = BME680_ADDR_GAS_CONF_START;
005FD6  B3C640     MOV.B #0x64, W0
005FD8  984720     MOV.B W0, [W14+2]
845:               	uint8_t reg_data = 0;
005FDA  EB4000     CLR.B W0
005FDC  984730     MOV.B W0, [W14+3]
846:               
847:               	/* Check for null pointer in the device structure*/
848:               	rslt = null_ptr_check(dev);
005FDE  90002E     MOV [W14+4], W0
005FE0  070654     RCALL _null_ptr_check, .LFE23, .LFB24
005FE2  784F00     MOV.B W0, [W14]
849:               	if (rslt == BME680_OK) {
005FE4  78401E     MOV.B [W14], W0
005FE6  E00400     CP0.B W0
005FE8  3A0027     BRA NZ, .L71
850:               		if (BME680_SPI_INTF == dev->intf) {
005FEA  90002E     MOV [W14+4], W0
005FEC  900010     MOV [W0+2], W0
005FEE  E00000     CP0 W0
005FF0  3A0004     BRA NZ, .L72
851:               			/* Memory page switch the SPI address*/
852:               			rslt = set_mem_page(reg_addr1, dev);
005FF2  9000AE     MOV [W14+4], W1
005FF4  90401E     MOV.B [W14+1], W0
005FF6  0705B2     RCALL _set_mem_page, .LFE20, .LFB21
005FF8  784F00     MOV.B W0, [W14]
853:               		}
854:               
855:               		if (rslt == BME680_OK) {
005FFA  78401E     MOV.B [W14], W0
005FFC  E00400     CP0.B W0
005FFE  3A001C     BRA NZ, .L71
856:               			rslt = bme680_get_regs(reg_addr1, &reg_data, 1, dev);
006000  470063     ADD W14, #0x3, W0
006002  9001AE     MOV [W14+4], W3
006004  200012     MOV #0x1, W2
006006  780080     MOV W0, W1
006008  90401E     MOV.B [W14+1], W0
00600A  07FB12     RCALL bme680_get_regs
00600C  784F00     MOV.B W0, [W14]
857:               			if (rslt == BME680_OK) {
00600E  78401E     MOV.B [W14], W0
006010  E00400     CP0.B W0
006012  3A0012     BRA NZ, .L71
858:               				dev->gas_sett.heatr_temp = reg_data;
006014  90403E     MOV.B [W14+3], W0
006016  FB8080     ZE W0, W1
006018  90002E     MOV [W14+4], W0
00601A  981861     MOV W1, [W0+60]
859:               				rslt = bme680_get_regs(reg_addr2, &reg_data, 1, dev);
00601C  470063     ADD W14, #0x3, W0
00601E  9001AE     MOV [W14+4], W3
006020  200012     MOV #0x1, W2
006022  780080     MOV W0, W1
006024  90402E     MOV.B [W14+2], W0
006026  07FB04     RCALL bme680_get_regs
006028  784F00     MOV.B W0, [W14]
860:               				if (rslt == BME680_OK) {
00602A  78401E     MOV.B [W14], W0
00602C  E00400     CP0.B W0
00602E  3A0004     BRA NZ, .L71
861:               					/* Heating duration register value */
862:               					dev->gas_sett.heatr_dur = reg_data;
006030  90403E     MOV.B [W14+3], W0
006032  FB8080     ZE W0, W1
006034  90002E     MOV [W14+4], W0
006036  981871     MOV W1, [W0+62]
863:               				}
864:               			}
865:               		}
866:               	}
867:               
868:               	return rslt;
006038  78401E     MOV.B [W14], W0
869:               }
00603A  FA8000     ULNK
00603C  060000     RETURN
870:               
871:               #ifndef BME680_FLOAT_POINT_COMPENSATION
872:               
873:               /*!
874:                * @brief This internal API is used to calculate the temperature value.
875:                */
876:               static int16_t calc_temperature(uint32_t temp_adc, struct bme680_dev *dev)
877:               {
00603E  FA0020     LNK #0x20
006040  BE9F88     MOV.D W8, [W15++]
006042  BE9F8A     MOV.D W10, [W15++]
006044  BE9F8C     MOV.D W12, [W15++]
006046  980F50     MOV W0, [W14+26]
006048  980F61     MOV W1, [W14+28]
00604A  980F72     MOV W2, [W14+30]
878:               	int64_t var1;
879:               	int64_t var2;
880:               	int64_t var3;
881:               	int16_t calc_temp;
882:               
883:               	var1 = ((int32_t) temp_adc >> 3) - ((int32_t) dev->calib.par_t1 << 1);
00604C  90085E     MOV [W14+26], W0
00604E  9008EE     MOV [W14+28], W1
006050  DD094D     SL W1, #13, W2
006052  DE0243     LSR W0, #3, W4
006054  710204     IOR W2, W4, W4
006056  DE8AC3     ASR W1, #3, W5
006058  90087E     MOV [W14+30], W0
00605A  900820     MOV [W0+20], W0
00605C  EB0080     CLR W1
00605E  400000     ADD W0, W0, W0
006060  488081     ADDC W1, W1, W1
006062  520000     SUB W4, W0, W0
006064  5A8081     SUBB W5, W1, W1
006066  DE894F     ASR W1, #15, W2
006068  780182     MOV W2, W3
00606A  BE9F00     MOV.D W0, [W14++]
00606C  BE9702     MOV.D W2, [W14--]
884:               	var2 = (var1 * (int32_t) dev->calib.par_t2) >> 11;
00606E  90087E     MOV [W14+30], W0
006070  900830     MOV [W0+22], W0
006072  DE80CF     ASR W0, #15, W1
006074  B90961     MUL.SU W1, #1, W2
006076  BE023E     MOV.D [W14++], W4
006078  BE032E     MOV.D [W14--], W6
00607A  07D4A3     RCALL ___muldi3
00607C  DE004B     LSR W0, #11, W0
00607E  DD0A45     SL W1, #5, W4
006080  720000     IOR W4, W0, W0
006082  DE08CB     LSR W1, #11, W1
006084  DD1245     SL W2, #5, W4
006086  720081     IOR W4, W1, W1
006088  DE114B     LSR W2, #11, W2
00608A  DD1A45     SL W3, #5, W4
00608C  720102     IOR W4, W2, W2
00608E  DE99CB     ASR W3, #11, W3
006090  980740     MOV W0, [W14+8]
006092  980751     MOV W1, [W14+10]
006094  980762     MOV W2, [W14+12]
006096  980773     MOV W3, [W14+14]
885:               	var3 = ((var1 >> 1) * (var1 >> 1)) >> 12;
006098  BE003E     MOV.D [W14++], W0
00609A  BE012E     MOV.D [W14--], W2
00609C  D18583     ASR W3, W11
00609E  D38502     RRC W2, W10
0060A0  D38481     RRC W1, W9
0060A2  D38400     RRC W0, W8
0060A4  BE003E     MOV.D [W14++], W0
0060A6  BE012E     MOV.D [W14--], W2
0060A8  D18183     ASR W3, W3
0060AA  D38102     RRC W2, W2
0060AC  D38081     RRC W1, W1
0060AE  D38000     RRC W0, W0
0060B0  BE0302     MOV.D W2, W6
0060B2  BE0200     MOV.D W0, W4
0060B4  BE0008     MOV.D W8, W0
0060B6  BE010A     MOV.D W10, W2
0060B8  07D484     RCALL ___muldi3
0060BA  DE004C     LSR W0, #12, W0
0060BC  DD0A44     SL W1, #4, W4
0060BE  720000     IOR W4, W0, W0
0060C0  DE08CC     LSR W1, #12, W1
0060C2  DD1244     SL W2, #4, W4
0060C4  720081     IOR W4, W1, W1
0060C6  DE114C     LSR W2, #12, W2
0060C8  DD1A44     SL W3, #4, W4
0060CA  720102     IOR W4, W2, W2
0060CC  DE99CC     ASR W3, #12, W3
0060CE  980F00     MOV W0, [W14+16]
0060D0  980F11     MOV W1, [W14+18]
0060D2  980F22     MOV W2, [W14+20]
0060D4  980F33     MOV W3, [W14+22]
886:               	var3 = ((var3) * ((int32_t) dev->calib.par_t3 << 4)) >> 14;
0060D6  90087E     MOV [W14+30], W0
0060D8  905800     MOV.B [W0+24], W0
0060DA  FB0100     SE W0, W2
0060DC  DE91CF     ASR W2, #15, W3
0060DE  DD1844     SL W3, #4, W0
0060E0  DE10CC     LSR W2, #12, W1
0060E2  700081     IOR W0, W1, W1
0060E4  DD1044     SL W2, #4, W0
0060E6  DE894F     ASR W1, #15, W2
0060E8  780182     MOV W2, W3
0060EA  900A0E     MOV [W14+16], W4
0060EC  900A9E     MOV [W14+18], W5
0060EE  900B2E     MOV [W14+20], W6
0060F0  900BBE     MOV [W14+22], W7
0060F2  07D467     RCALL ___muldi3
0060F4  DE004E     LSR W0, #14, W0
0060F6  DD0A42     SL W1, #2, W4
0060F8  720000     IOR W4, W0, W0
0060FA  DE08CE     LSR W1, #14, W1
0060FC  DD1242     SL W2, #2, W4
0060FE  720081     IOR W4, W1, W1
006100  DE114E     LSR W2, #14, W2
006102  DD1A42     SL W3, #2, W4
006104  720102     IOR W4, W2, W2
006106  DE99CE     ASR W3, #14, W3
006108  980F00     MOV W0, [W14+16]
00610A  980F11     MOV W1, [W14+18]
00610C  980F22     MOV W2, [W14+20]
00610E  980F33     MOV W3, [W14+22]
887:               	dev->calib.t_fine = (int32_t) (var2 + var3);
006110  90014E     MOV [W14+8], W2
006112  9001DE     MOV [W14+10], W3
006114  90080E     MOV [W14+16], W0
006116  90089E     MOV [W14+18], W1
006118  400002     ADD W0, W2, W0
00611A  488083     ADDC W1, W3, W1
00611C  90097E     MOV [W14+30], W2
00611E  981160     MOV W0, [W2+44]
006120  981171     MOV W1, [W2+46]
888:               	calc_temp = (int16_t) (((dev->calib.t_fine * 5) + 128) >> 8);
006122  90087E     MOV [W14+30], W0
006124  9010F0     MOV [W0+46], W1
006126  901060     MOV [W0+44], W0
006128  B90965     MUL.SU W1, #5, W2
00612A  780102     MOV W2, W2
00612C  B90260     MUL.SU W0, #0, W4
00612E  780184     MOV W4, W3
006130  410103     ADD W2, W3, W2
006132  200053     MOV #0x5, W3
006134  B80003     MUL.UU W0, W3, W0
006136  410101     ADD W2, W1, W2
006138  780082     MOV W2, W1
00613A  B00800     ADD #0x80, W0
00613C  B08001     ADDC #0x0, W1
00613E  DD0948     SL W1, #8, W2
006140  DE0648     LSR W0, #8, W12
006142  71060C     IOR W2, W12, W12
006144  DE8EC8     ASR W1, #8, W13
006146  980F4C     MOV W12, [W14+24]
889:               
890:               	return calc_temp;
006148  90084E     MOV [W14+24], W0
891:               }
00614A  BE064F     MOV.D [--W15], W12
00614C  BE054F     MOV.D [--W15], W10
00614E  BE044F     MOV.D [--W15], W8
006150  FA8000     ULNK
006152  060000     RETURN
892:               
893:               /*!
894:                * @brief This internal API is used to calculate the pressure value.
895:                */
896:               static uint32_t calc_pressure(uint32_t pres_adc, const struct bme680_dev *dev)
897:               {
006154  FA005E     LNK #0x5E
006156  BE9F88     MOV.D W8, [W15++]
006158  BE9F8A     MOV.D W10, [W15++]
00615A  BE9F8C     MOV.D W12, [W15++]
00615C  980F00     MOV W0, [W14+16]
00615E  980F11     MOV W1, [W14+18]
006160  980F22     MOV W2, [W14+20]
898:               	int32_t var1;
899:               	int32_t var2;
900:               	int32_t var3;
901:               	int32_t pressure_comp;
902:               
903:               	var1 = (((int32_t)dev->calib.t_fine) >> 1) - 64000;
006162  90082E     MOV [W14+20], W0
006164  9010F0     MOV [W0+46], W1
006166  901060     MOV [W0+44], W0
006168  D18181     ASR W1, W3
00616A  D38100     RRC W0, W2
00616C  206000     MOV #0x600, W0
00616E  2FFFF1     MOV #0xFFFF, W1
006170  400002     ADD W0, W2, W0
006172  488083     ADDC W1, W3, W1
006174  980720     MOV W0, [W14+4]
006176  980731     MOV W1, [W14+6]
904:               	var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) *
006178  90002E     MOV [W14+4], W0
00617A  9000BE     MOV [W14+6], W1
00617C  DD094E     SL W1, #14, W2
00617E  DE0342     LSR W0, #2, W6
006180  710306     IOR W2, W6, W6
006182  DE8BC2     ASR W1, #2, W7
006184  90002E     MOV [W14+4], W0
006186  9000BE     MOV [W14+6], W1
006188  DD09CE     SL W1, #14, W3
00618A  DE0242     LSR W0, #2, W4
00618C  718204     IOR W3, W4, W4
00618E  DE8AC2     ASR W1, #2, W5
006190  B9B804     MUL.SS W7, W4, W0
006192  780100     MOV W0, W2
006194  B9A806     MUL.SS W5, W6, W0
006196  780000     MOV W0, W0
006198  410100     ADD W2, W0, W2
00619A  B83004     MUL.UU W6, W4, W0
00619C  410101     ADD W2, W1, W2
00619E  780082     MOV W2, W1
0061A0  DD0A45     SL W1, #5, W4
0061A2  DE044B     LSR W0, #11, W8
0061A4  720408     IOR W4, W8, W8
0061A6  DE8CCB     ASR W1, #11, W9
0061B0  B9C802     MUL.SS W9, W2, W0
0061B2  780200     MOV W0, W4
0061B4  B99808     MUL.SS W3, W8, W0
0061B6  780000     MOV W0, W0
0061B8  420200     ADD W4, W0, W4
0061BA  B84002     MUL.UU W8, W2, W0
0061BC  420201     ADD W4, W1, W4
0061BE  780084     MOV W4, W1
0061C0  DD0B4E     SL W1, #14, W6
0061C2  DE02C2     LSR W0, #2, W5
0061C4  730285     IOR W6, W5, W5
0061C6  982735     MOV W5, [W14+70]
0061C8  DE8942     ASR W1, #2, W2
0061CA  982742     MOV W2, [W14+72]
0061CC  90223E     MOV [W14+70], W4
0061CE  9022CE     MOV [W14+72], W5
0061D0  980744     MOV W4, [W14+8]
0061D2  980755     MOV W5, [W14+10]
905:               		(int32_t)dev->calib.par_p6) >> 2;
0061A8  90082E     MOV [W14+20], W0
0061AA  906040     MOV.B [W0+36], W0
0061AC  FB0100     SE W0, W2
0061AE  DE91CF     ASR W2, #15, W3
906:               	var2 = var2 + ((var1 * (int32_t)dev->calib.par_p5) << 1);
0061D4  90082E     MOV [W14+20], W0
0061D6  901010     MOV [W0+34], W0
0061D8  B90161     MUL.SU W0, #1, W2
0061DA  90002E     MOV [W14+4], W0
0061DC  B98003     MUL.SS W0, W3, W0
0061DE  780200     MOV W0, W4
0061E0  90003E     MOV [W14+6], W0
0061E2  B98002     MUL.SS W0, W2, W0
0061E4  780000     MOV W0, W0
0061E6  420200     ADD W4, W0, W4
0061E8  90002E     MOV [W14+4], W0
0061EA  B80002     MUL.UU W0, W2, W0
0061EC  420201     ADD W4, W1, W4
0061EE  780084     MOV W4, W1
0061F0  400100     ADD W0, W0, W2
0061F2  488181     ADDC W1, W1, W3
0061F4  90004E     MOV [W14+8], W0
0061F6  9000DE     MOV [W14+10], W1
0061F8  410000     ADD W2, W0, W0
0061FA  498081     ADDC W3, W1, W1
0061FC  980740     MOV W0, [W14+8]
0061FE  980751     MOV W1, [W14+10]
907:               	var2 = (var2 >> 2) + ((int32_t)dev->calib.par_p4 << 16);
006200  90004E     MOV [W14+8], W0
006202  9000DE     MOV [W14+10], W1
006204  DD0B4E     SL W1, #14, W6
006206  DE02C2     LSR W0, #2, W5
006208  730285     IOR W6, W5, W5
00620A  980F35     MOV W5, [W14+22]
00620C  DE8942     ASR W1, #2, W2
00620E  980F42     MOV W2, [W14+24]
006210  90082E     MOV [W14+20], W0
006212  901000     MOV [W0+32], W0
006214  DE80CF     ASR W0, #15, W1
006216  DD00C0     SL W0, #0, W1
006218  200000     MOV #0x0, W0
00621A  900A3E     MOV [W14+22], W4
00621C  900ACE     MOV [W14+24], W5
00621E  400004     ADD W0, W4, W0
006220  488085     ADDC W1, W5, W1
006222  980740     MOV W0, [W14+8]
006224  980751     MOV W1, [W14+10]
908:               	var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) *
006226  90002E     MOV [W14+4], W0
006228  9000BE     MOV [W14+6], W1
00622A  DD0ACE     SL W1, #14, W5
00622C  DE0642     LSR W0, #2, W12
00622E  72860C     IOR W5, W12, W12
006230  DE8EC2     ASR W1, #2, W13
006232  90002E     MOV [W14+4], W0
006234  9000BE     MOV [W14+6], W1
006236  DD0B4E     SL W1, #14, W6
006238  DE0542     LSR W0, #2, W10
00623A  73050A     IOR W6, W10, W10
00623C  DE8DC2     ASR W1, #2, W11
00623E  B9E80A     MUL.SS W13, W10, W0
006240  780100     MOV W0, W2
006242  B9D80C     MUL.SS W11, W12, W0
006244  780000     MOV W0, W0
006246  410100     ADD W2, W0, W2
006248  B8600A     MUL.UU W12, W10, W0
00624A  410101     ADD W2, W1, W2
00624C  780082     MOV W2, W1
00624E  DD09C3     SL W1, #3, W3
006250  DE014D     LSR W0, #13, W2
006252  718102     IOR W3, W2, W2
006254  980F52     MOV W2, [W14+26]
006256  DE8A4D     ASR W1, #13, W4
006258  980F64     MOV W4, [W14+28]
00626A  900AEE     MOV [W14+28], W5
00626C  B9A802     MUL.SS W5, W2, W0
00626E  780200     MOV W0, W4
006270  900B5E     MOV [W14+26], W6
006272  B99806     MUL.SS W3, W6, W0
006274  780000     MOV W0, W0
006276  420200     ADD W4, W0, W4
006278  900ADE     MOV [W14+26], W5
00627A  B82802     MUL.UU W5, W2, W0
00627C  420201     ADD W4, W1, W4
00627E  780084     MOV W4, W1
0062AC  900A7E     MOV [W14+30], W4
0062AE  90128E     MOV [W14+32], W5
0062B0  400004     ADD W0, W4, W0
0062B2  488085     ADDC W1, W5, W1
0062B4  980720     MOV W0, [W14+4]
0062B6  980731     MOV W1, [W14+6]
909:               		((int32_t)dev->calib.par_p3 << 5)) >> 3) +
00625A  90082E     MOV [W14+20], W0
00625C  905860     MOV.B [W0+30], W0
00625E  FB0000     SE W0, W0
006260  DE80CF     ASR W0, #15, W1
006262  DD0945     SL W1, #5, W2
006264  DE01CB     LSR W0, #11, W3
006266  710183     IOR W2, W3, W3
006268  DD0145     SL W0, #5, W2
006280  DD094D     SL W1, #13, W2
006282  DE0343     LSR W0, #3, W6
006284  710306     IOR W2, W6, W6
006286  980F76     MOV W6, [W14+30]
006288  DE89C3     ASR W1, #3, W3
00628A  981703     MOV W3, [W14+32]
910:               		(((int32_t)dev->calib.par_p2 * var1) >> 1);
00628C  90082E     MOV [W14+20], W0
00628E  900860     MOV [W0+28], W0
006290  B90161     MUL.SU W0, #1, W2
006292  90002E     MOV [W14+4], W0
006294  B98003     MUL.SS W0, W3, W0
006296  780200     MOV W0, W4
006298  90003E     MOV [W14+6], W0
00629A  B98002     MUL.SS W0, W2, W0
00629C  780000     MOV W0, W0
00629E  420200     ADD W4, W0, W4
0062A0  90002E     MOV [W14+4], W0
0062A2  B80002     MUL.UU W0, W2, W0
0062A4  420201     ADD W4, W1, W4
0062A6  780084     MOV W4, W1
0062A8  D18081     ASR W1, W1
0062AA  D38000     RRC W0, W0
911:               	var1 = var1 >> 18;
0062B8  90002E     MOV [W14+4], W0
0062BA  9000BE     MOV [W14+6], W1
0062BC  DE8AC2     ASR W1, #2, W5
0062BE  982755     MOV W5, [W14+74]
0062C0  DE8B4F     ASR W1, #15, W6
0062C2  982766     MOV W6, [W14+76]
0062C4  90215E     MOV [W14+74], W2
0062C6  9021EE     MOV [W14+76], W3
0062C8  980722     MOV W2, [W14+4]
0062CA  980733     MOV W3, [W14+6]
912:               	var1 = ((32768 + var1) * (int32_t)dev->calib.par_p1) >> 15;
0062CC  90012E     MOV [W14+4], W2
0062CE  9001BE     MOV [W14+6], W3
0062D0  280000     MOV #0x8000, W0
0062D2  200001     MOV #0x0, W1
0062D4  400202     ADD W0, W2, W4
0062D6  488283     ADDC W1, W3, W5
0062D8  90082E     MOV [W14+20], W0
0062DA  900850     MOV [W0+26], W0
0062DC  B80161     MUL.UU W0, #1, W2
0062DE  B9A802     MUL.SS W5, W2, W0
0062E0  780300     MOV W0, W6
0062E2  B99804     MUL.SS W3, W4, W0
0062E4  780000     MOV W0, W0
0062E6  430300     ADD W6, W0, W6
0062E8  B82002     MUL.UU W4, W2, W0
0062EA  430301     ADD W6, W1, W6
0062EC  780086     MOV W6, W1
0062EE  DD0A41     SL W1, #1, W4
0062F0  DE01CF     LSR W0, #15, W3
0062F2  720183     IOR W4, W3, W3
0062F4  982773     MOV W3, [W14+78]
0062F6  DE8ACF     ASR W1, #15, W5
0062F8  982F05     MOV W5, [W14+80]
0062FA  90217E     MOV [W14+78], W2
0062FC  90298E     MOV [W14+80], W3
0062FE  980722     MOV W2, [W14+4]
006300  980733     MOV W3, [W14+6]
913:               	pressure_comp = 1048576 - pres_adc;
006302  200002     MOV #0x0, W2
006304  200103     MOV #0x10, W3
006306  90080E     MOV [W14+16], W0
006308  90089E     MOV [W14+18], W1
00630A  510000     SUB W2, W0, W0
00630C  598081     SUBB W3, W1, W1
00630E  BE8F00     MOV.D W0, [W14]
914:               	pressure_comp = (int32_t)((pressure_comp - (var2 >> 12)) * ((uint32_t)3125));
006310  90004E     MOV [W14+8], W0
006312  9000DE     MOV [W14+10], W1
006314  DD0A44     SL W1, #4, W4
006316  DE01CC     LSR W0, #12, W3
006318  720183     IOR W4, W3, W3
00631A  981713     MOV W3, [W14+34]
00631C  DE8ACC     ASR W1, #12, W5
00631E  981725     MOV W5, [W14+36]
006320  90111E     MOV [W14+34], W2
006322  9011AE     MOV [W14+36], W3
006324  11003E     SUBR W2, [W14++], W0
006326  1980AE     SUBBR W3, [W14--], W1
006328  BE0100     MOV.D W0, W2
00632A  20C350     MOV #0xC35, W0
00632C  B99800     MUL.SS W3, W0, W0
00632E  780200     MOV W0, W4
006330  B91060     MUL.SU W2, #0, W0
006332  780000     MOV W0, W0
006334  420200     ADD W4, W0, W4
006336  20C350     MOV #0xC35, W0
006338  B81000     MUL.UU W2, W0, W0
00633A  420201     ADD W4, W1, W4
00633C  780084     MOV W4, W1
00633E  BE8F00     MOV.D W0, [W14]
915:               	if (pressure_comp >= BME680_MAX_OVERFLOW_VAL)
006340  2FFFF2     MOV #0xFFFF, W2
006342  23FFF3     MOV #0x3FFF, W3
006344  BE001E     MOV.D [W14], W0
006346  500F82     SUB W0, W2, [W15]
006348  588F83     SUBB W1, W3, [W15]
00634A  340008     BRA LE, .L75
916:               		pressure_comp = ((pressure_comp / var1) << 1);
00634C  90012E     MOV [W14+4], W2
00634E  9001BE     MOV [W14+6], W3
006350  BE001E     MOV.D [W14], W0
006352  07D0E3     RCALL ___divsi3
006354  400000     ADD W0, W0, W0
006356  488081     ADDC W1, W1, W1
006358  BE8F00     MOV.D W0, [W14]
00635A  370007     BRA .L76
917:               	else
918:               		pressure_comp = ((pressure_comp << 1) / var1);
00635C  BE001E     MOV.D [W14], W0
00635E  400000     ADD W0, W0, W0
006360  488081     ADDC W1, W1, W1
006362  90012E     MOV [W14+4], W2
006364  9001BE     MOV [W14+6], W3
006366  07D0D9     RCALL ___divsi3
006368  BE8F00     MOV.D W0, [W14]
919:               	var1 = ((int32_t)dev->calib.par_p9 * (int32_t)(((pressure_comp >> 3) *
00636A  90082E     MOV [W14+20], W0
00636C  901040     MOV [W0+40], W0
00636E  B90261     MUL.SU W0, #1, W4
006370  BE001E     MOV.D [W14], W0
006372  DD0B4D     SL W1, #13, W6
006374  DE01C3     LSR W0, #3, W3
006376  730183     IOR W6, W3, W3
006378  981733     MOV W3, [W14+38]
00637A  DE8943     ASR W1, #3, W2
00637C  981742     MOV W2, [W14+40]
00638C  9011CE     MOV [W14+40], W3
00638E  90135E     MOV [W14+42], W6
006390  B99806     MUL.SS W3, W6, W0
006392  780100     MOV W0, W2
006394  9011EE     MOV [W14+44], W3
006396  90133E     MOV [W14+38], W6
006398  B99806     MUL.SS W3, W6, W0
00639A  780000     MOV W0, W0
00639C  410100     ADD W2, W0, W2
00639E  9011BE     MOV [W14+38], W3
0063A0  90135E     MOV [W14+42], W6
0063A2  B81806     MUL.UU W3, W6, W0
0063A4  410101     ADD W2, W1, W2
0063A6  780082     MOV W2, W1
0063A8  DD09C3     SL W1, #3, W3
0063AA  DE014D     LSR W0, #13, W2
0063AC  718102     IOR W3, W2, W2
0063AE  981772     MOV W2, [W14+46]
0063B0  DE8B4D     ASR W1, #13, W6
0063B2  981F06     MOV W6, [W14+48]
0063B4  90117E     MOV [W14+46], W2
0063B6  B9A802     MUL.SS W5, W2, W0
0063B8  780100     MOV W0, W2
0063BA  90198E     MOV [W14+48], W3
0063BC  B99804     MUL.SS W3, W4, W0
0063BE  780000     MOV W0, W0
0063C0  410100     ADD W2, W0, W2
0063C2  90137E     MOV [W14+46], W6
0063C4  B82006     MUL.UU W4, W6, W0
0063C6  410101     ADD W2, W1, W2
0063C8  780082     MOV W2, W1
0063CA  DD09C4     SL W1, #4, W3
0063CC  DE014C     LSR W0, #12, W2
0063CE  718102     IOR W3, W2, W2
0063D0  982F12     MOV W2, [W14+82]
0063D2  DE8A4C     ASR W1, #12, W4
0063D4  982F24     MOV W4, [W14+84]
0063D6  90291E     MOV [W14+82], W2
0063D8  9029AE     MOV [W14+84], W3
0063DA  980722     MOV W2, [W14+4]
0063DC  980733     MOV W3, [W14+6]
920:               		(pressure_comp >> 3)) >> 13)) >> 12;
00637E  BE001E     MOV.D [W14], W0
006380  DD0B4D     SL W1, #13, W6
006382  DE01C3     LSR W0, #3, W3
006384  730183     IOR W6, W3, W3
006386  981753     MOV W3, [W14+42]
006388  DE8943     ASR W1, #3, W2
00638A  981762     MOV W2, [W14+44]
921:               	var2 = ((int32_t)(pressure_comp >> 2) *
0063DE  BE001E     MOV.D [W14], W0
0063E0  DD0A4E     SL W1, #14, W4
0063E2  DE01C2     LSR W0, #2, W3
0063E4  720183     IOR W4, W3, W3
0063E6  981F13     MOV W3, [W14+50]
0063E8  DE8AC2     ASR W1, #2, W5
0063EA  981F25     MOV W5, [W14+52]
0063F2  901B2E     MOV [W14+52], W6
0063F4  B9B002     MUL.SS W6, W2, W0
0063F6  780200     MOV W0, W4
0063F8  901A9E     MOV [W14+50], W5
0063FA  B99805     MUL.SS W3, W5, W0
0063FC  780000     MOV W0, W0
0063FE  420200     ADD W4, W0, W4
006400  901B1E     MOV [W14+50], W6
006402  B83002     MUL.UU W6, W2, W0
006404  420201     ADD W4, W1, W4
006406  780084     MOV W4, W1
006408  DD09C3     SL W1, #3, W3
00640A  DE014D     LSR W0, #13, W2
00640C  718102     IOR W3, W2, W2
00640E  982F32     MOV W2, [W14+86]
006410  DE8A4D     ASR W1, #13, W4
006412  982F44     MOV W4, [W14+88]
006414  90293E     MOV [W14+86], W2
006416  9029CE     MOV [W14+88], W3
006418  980742     MOV W2, [W14+8]
00641A  980753     MOV W3, [W14+10]
922:               		(int32_t)dev->calib.par_p8) >> 13;
0063EC  90082E     MOV [W14+20], W0
0063EE  901030     MOV [W0+38], W0
0063F0  B90161     MUL.SU W0, #1, W2
923:               	var3 = ((int32_t)(pressure_comp >> 8) * (int32_t)(pressure_comp >> 8) *
00641C  BE001E     MOV.D [W14], W0
00641E  DD0A48     SL W1, #8, W4
006420  DE01C8     LSR W0, #8, W3
006422  720183     IOR W4, W3, W3
006424  981F33     MOV W3, [W14+54]
006426  DE8AC8     ASR W1, #8, W5
006428  981F45     MOV W5, [W14+56]
00642A  BE001E     MOV.D [W14], W0
00642C  DD0948     SL W1, #8, W2
00642E  DE0348     LSR W0, #8, W6
006430  710306     IOR W2, W6, W6
006432  981F56     MOV W6, [W14+58]
006434  DE89C8     ASR W1, #8, W3
006436  981F63     MOV W3, [W14+60]
006438  901A4E     MOV [W14+56], W4
00643A  901ADE     MOV [W14+58], W5
00643C  B9A005     MUL.SS W4, W5, W0
00643E  780100     MOV W0, W2
006440  901B6E     MOV [W14+60], W6
006442  9019BE     MOV [W14+54], W3
006444  B9B003     MUL.SS W6, W3, W0
006446  780000     MOV W0, W0
006448  410100     ADD W2, W0, W2
00644A  901A3E     MOV [W14+54], W4
00644C  901ADE     MOV [W14+58], W5
00644E  B82005     MUL.UU W4, W5, W0
006450  410101     ADD W2, W1, W2
006452  780082     MOV W2, W1
006462  901B7E     MOV [W14+62], W6
006464  B98906     MUL.SS W1, W6, W2
006466  780102     MOV W2, W2
006468  90218E     MOV [W14+64], W3
00646A  B99A00     MUL.SS W3, W0, W4
00646C  780184     MOV W4, W3
00646E  410103     ADD W2, W3, W2
006470  901A7E     MOV [W14+62], W4
006472  B80004     MUL.UU W0, W4, W0
006474  410101     ADD W2, W1, W2
006476  780082     MOV W2, W1
006490  D18281     ASR W1, W5
006492  982F55     MOV W5, [W14+90]
006494  DE8B4F     ASR W1, #15, W6
006496  982F66     MOV W6, [W14+92]
006498  90295E     MOV [W14+90], W2
00649A  9029EE     MOV [W14+92], W3
00649C  980762     MOV W2, [W14+12]
00649E  980773     MOV W3, [W14+14]
924:               		(int32_t)(pressure_comp >> 8) *
006454  BE011E     MOV.D [W14], W2
006456  DD1A48     SL W3, #8, W4
006458  DE1348     LSR W2, #8, W6
00645A  720306     IOR W4, W6, W6
00645C  981F76     MOV W6, [W14+62]
00645E  DE9AC8     ASR W3, #8, W5
006460  982705     MOV W5, [W14+64]
006480  B98A02     MUL.SS W1, W2, W4
006482  780204     MOV W4, W4
006484  B99B00     MUL.SS W3, W0, W6
006486  780286     MOV W6, W5
006488  420205     ADD W4, W5, W4
00648A  B80002     MUL.UU W0, W2, W0
00648C  420201     ADD W4, W1, W4
00648E  780084     MOV W4, W1
925:               		(int32_t)dev->calib.par_p10) >> 17;
006478  90092E     MOV [W14+20], W2
00647A  906922     MOV.B [W2+42], W2
00647C  FB8102     ZE W2, W2
00647E  EB0180     CLR W3
926:               
927:               	pressure_comp = (int32_t)(pressure_comp) + ((var1 + var2 + var3 +
0064A0  90012E     MOV [W14+4], W2
0064A2  9001BE     MOV [W14+6], W3
0064A4  90004E     MOV [W14+8], W0
0064A6  9000DE     MOV [W14+10], W1
0064A8  400102     ADD W0, W2, W2
0064AA  488183     ADDC W1, W3, W3
0064AC  90006E     MOV [W14+12], W0
0064AE  9000FE     MOV [W14+14], W1
0064B0  400102     ADD W0, W2, W2
0064B2  488183     ADDC W1, W3, W3
0064C4  400002     ADD W0, W2, W0
0064C6  488083     ADDC W1, W3, W1
0064D4  90211E     MOV [W14+66], W2
0064D6  9021AE     MOV [W14+68], W3
0064D8  410F1E     ADD W2, [W14], [W14]
0064DA  49975E     ADDC W3, [++W14], [W14--]
928:               		((int32_t)dev->calib.par_p7 << 7)) >> 4);
0064B4  90082E     MOV [W14+20], W0
0064B6  906050     MOV.B [W0+37], W0
0064B8  FB0200     SE W0, W4
0064BA  DEA2CF     ASR W4, #15, W5
0064BC  DD2847     SL W5, #7, W0
0064BE  DE20C9     LSR W4, #9, W1
0064C0  700081     IOR W0, W1, W1
0064C2  DD2047     SL W4, #7, W0
0064C8  DD0A4C     SL W1, #12, W4
0064CA  DE01C4     LSR W0, #4, W3
0064CC  720183     IOR W4, W3, W3
0064CE  982713     MOV W3, [W14+66]
0064D0  DE8AC4     ASR W1, #4, W5
0064D2  982725     MOV W5, [W14+68]
929:               
930:               	return (uint32_t)pressure_comp;
0064DC  BE001E     MOV.D [W14], W0
931:               
932:               }
0064DE  BE064F     MOV.D [--W15], W12
0064E0  BE054F     MOV.D [--W15], W10
0064E2  BE044F     MOV.D [--W15], W8
0064E4  FA8000     ULNK
0064E6  060000     RETURN
933:               
934:               /*!
935:                * @brief This internal API is used to calculate the humidity value.
936:                */
937:               static uint32_t calc_humidity(uint16_t hum_adc, const struct bme680_dev *dev)
938:               {
0064E8  FA0040     LNK #0x40
0064EA  BE9F88     MOV.D W8, [W15++]
0064EC  BE9F8A     MOV.D W10, [W15++]
0064EE  BE9F8C     MOV.D W12, [W15++]
0064F0  981700     MOV W0, [W14+32]
0064F2  981711     MOV W1, [W14+34]
939:               	int32_t var1;
940:               	int32_t var2;
941:               	int32_t var3;
942:               	int32_t var4;
943:               	int32_t var5;
944:               	int32_t var6;
945:               	int32_t temp_scaled;
946:               	int32_t calc_hum;
947:               
948:               	temp_scaled = (((int32_t) dev->calib.t_fine * 5) + 128) >> 8;
0064F4  90101E     MOV [W14+34], W0
0064F6  901160     MOV [W0+44], W2
0064F8  9011F0     MOV [W0+46], W3
0064FA  B91865     MUL.SU W3, #5, W0
0064FC  780200     MOV W0, W4
0064FE  B91060     MUL.SU W2, #0, W0
006500  780000     MOV W0, W0
006502  420200     ADD W4, W0, W4
006504  200050     MOV #0x5, W0
006506  B81000     MUL.UU W2, W0, W0
006508  420201     ADD W4, W1, W4
00650A  780084     MOV W4, W1
00650C  B00800     ADD #0x80, W0
00650E  B08001     ADDC #0x0, W1
006510  DD0948     SL W1, #8, W2
006512  DE0348     LSR W0, #8, W6
006514  710306     IOR W2, W6, W6
006516  DE8BC8     ASR W1, #8, W7
006518  980726     MOV W6, [W14+4]
00651A  980737     MOV W7, [W14+6]
949:               	var1 = (int32_t) (hum_adc - ((int32_t) ((int32_t) dev->calib.par_h1 * 16)))
00651C  90100E     MOV [W14+32], W0
00651E  B80361     MUL.UU W0, #1, W6
006520  90101E     MOV [W14+34], W0
006522  900030     MOV [W0+6], W0
006524  B80161     MUL.UU W0, #1, W2
006526  2FFF00     MOV #0xFFF0, W0
006528  B99800     MUL.SS W3, W0, W0
00652A  780200     MOV W0, W4
00652C  EB8000     SETM W0
00652E  B99000     MUL.SS W2, W0, W0
006530  780000     MOV W0, W0
006532  420200     ADD W4, W0, W4
006534  2FFF00     MOV #0xFFF0, W0
006536  B81000     MUL.UU W2, W0, W0
006538  420201     ADD W4, W1, W4
00653A  780084     MOV W4, W1
00653C  400406     ADD W0, W6, W8
00653E  488487     ADDC W1, W7, W9
006568  540000     SUB W8, W0, W0
00656A  5C8081     SUBB W9, W1, W1
00656C  980740     MOV W0, [W14+8]
00656E  980751     MOV W1, [W14+10]
950:               		- (((temp_scaled * (int32_t) dev->calib.par_h3) / ((int32_t) 100)) >> 1);
006540  90101E     MOV [W14+34], W0
006542  904820     MOV.B [W0+10], W0
006544  FB0100     SE W0, W2
006546  DE91CF     ASR W2, #15, W3
006548  90002E     MOV [W14+4], W0
00654A  B98003     MUL.SS W0, W3, W0
00654C  780200     MOV W0, W4
00654E  90003E     MOV [W14+6], W0
006550  B98002     MUL.SS W0, W2, W0
006552  780000     MOV W0, W0
006554  420200     ADD W4, W0, W4
006556  90002E     MOV [W14+4], W0
006558  B80002     MUL.UU W0, W2, W0
00655A  420201     ADD W4, W1, W4
00655C  780084     MOV W4, W1
00655E  200642     MOV #0x64, W2
006560  200003     MOV #0x0, W3
006562  07CFDB     RCALL ___divsi3
006564  D18081     ASR W1, W1
006566  D38000     RRC W0, W0
951:               	var2 = ((int32_t) dev->calib.par_h2
006570  90101E     MOV [W14+34], W0
006572  900040     MOV [W0+8], W0
006574  B80461     MUL.UU W0, #1, W8
00660A  DD0A46     SL W1, #6, W4
00660C  DE01CA     LSR W0, #10, W3
00660E  720183     IOR W4, W3, W3
006610  981F03     MOV W3, [W14+48]
006612  DE894A     ASR W1, #10, W2
006614  981F12     MOV W2, [W14+50]
006616  90190E     MOV [W14+48], W2
006618  90199E     MOV [W14+50], W3
00661A  980762     MOV W2, [W14+12]
00661C  980773     MOV W3, [W14+14]
952:               		* (((temp_scaled * (int32_t) dev->calib.par_h4) / ((int32_t) 100))
006576  90101E     MOV [W14+34], W0
006578  904830     MOV.B [W0+11], W0
00657A  FB0100     SE W0, W2
00657C  DE91CF     ASR W2, #15, W3
00657E  90002E     MOV [W14+4], W0
006580  B98003     MUL.SS W0, W3, W0
006582  780200     MOV W0, W4
006584  90003E     MOV [W14+6], W0
006586  B98002     MUL.SS W0, W2, W0
006588  780000     MOV W0, W0
00658A  420200     ADD W4, W0, W4
00658C  90002E     MOV [W14+4], W0
00658E  B80002     MUL.UU W0, W2, W0
006590  420201     ADD W4, W1, W4
006592  780084     MOV W4, W1
006594  200642     MOV #0x64, W2
006596  200003     MOV #0x0, W3
006598  07CFC0     RCALL ___divsi3
00659A  BE0500     MOV.D W0, W10
0065FA  B9C802     MUL.SS W9, W2, W0
0065FC  780200     MOV W0, W4
0065FE  B99808     MUL.SS W3, W8, W0
006600  780000     MOV W0, W0
006602  420200     ADD W4, W0, W4
006604  B84002     MUL.UU W8, W2, W0
006606  420201     ADD W4, W1, W4
006608  780084     MOV W4, W1
953:               			+ (((temp_scaled * ((temp_scaled * (int32_t) dev->calib.par_h5) / ((int32_t) 100))) >> 6)
00659C  90101E     MOV [W14+34], W0
00659E  904840     MOV.B [W0+12], W0
0065A0  FB0100     SE W0, W2
0065A2  DE91CF     ASR W2, #15, W3
0065A4  90002E     MOV [W14+4], W0
0065A6  B98003     MUL.SS W0, W3, W0
0065A8  780200     MOV W0, W4
0065AA  90003E     MOV [W14+6], W0
0065AC  B98002     MUL.SS W0, W2, W0
0065AE  780000     MOV W0, W0
0065B0  420200     ADD W4, W0, W4
0065B2  90002E     MOV [W14+4], W0
0065B4  B80002     MUL.UU W0, W2, W0
0065B6  420201     ADD W4, W1, W4
0065B8  780084     MOV W4, W1
0065BA  200642     MOV #0x64, W2
0065BC  200003     MOV #0x0, W3
0065BE  07CFAD     RCALL ___divsi3
0065C0  BE0100     MOV.D W0, W2
0065C2  90002E     MOV [W14+4], W0
0065C4  B98003     MUL.SS W0, W3, W0
0065C6  780200     MOV W0, W4
0065C8  90003E     MOV [W14+6], W0
0065CA  B98002     MUL.SS W0, W2, W0
0065CC  780000     MOV W0, W0
0065CE  420200     ADD W4, W0, W4
0065D0  90002E     MOV [W14+4], W0
0065D2  B80002     MUL.UU W0, W2, W0
0065D4  420201     ADD W4, W1, W4
0065D6  780084     MOV W4, W1
0065D8  DD0A4A     SL W1, #10, W4
0065DA  DE01C6     LSR W0, #6, W3
0065DC  720183     IOR W4, W3, W3
0065DE  981723     MOV W3, [W14+36]
0065E0  DE8946     ASR W1, #6, W2
0065E2  981732     MOV W2, [W14+38]
0065EE  40010A     ADD W0, W10, W2
0065F0  48818B     ADDC W1, W11, W3
954:               				/ ((int32_t) 100)) + (int32_t) (1 << 14))) >> 10;
0065E4  200642     MOV #0x64, W2
0065E6  200003     MOV #0x0, W3
0065E8  90102E     MOV [W14+36], W0
0065EA  9010BE     MOV [W14+38], W1
0065EC  07CF96     RCALL ___divsi3
0065F2  240000     MOV #0x4000, W0
0065F4  200001     MOV #0x0, W1
0065F6  400102     ADD W0, W2, W2
0065F8  488183     ADDC W1, W3, W3
955:               	var3 = var1 * var2;
00661E  9000DE     MOV [W14+10], W1
006620  90006E     MOV [W14+12], W0
006622  B98800     MUL.SS W1, W0, W0
006624  780100     MOV W0, W2
006626  9000FE     MOV [W14+14], W1
006628  90004E     MOV [W14+8], W0
00662A  B98800     MUL.SS W1, W0, W0
00662C  780000     MOV W0, W0
00662E  410100     ADD W2, W0, W2
006630  9000CE     MOV [W14+8], W1
006632  90006E     MOV [W14+12], W0
006634  B80800     MUL.UU W1, W0, W0
006636  410101     ADD W2, W1, W2
006638  780082     MOV W2, W1
00663A  980F00     MOV W0, [W14+16]
00663C  980F11     MOV W1, [W14+18]
00663E  980F00     MOV W0, [W14+16]
006640  980F11     MOV W1, [W14+18]
956:               	var4 = (int32_t) dev->calib.par_h6 << 7;
006642  90101E     MOV [W14+34], W0
006644  904850     MOV.B [W0+13], W0
006646  FB8100     ZE W0, W2
006648  EB0180     CLR W3
00664A  DD1847     SL W3, #7, W0
00664C  DE10C9     LSR W2, #9, W1
00664E  700081     IOR W0, W1, W1
006650  DD1047     SL W2, #7, W0
006652  980F20     MOV W0, [W14+20]
006654  980F31     MOV W1, [W14+22]
957:               	var4 = ((var4) + ((temp_scaled * (int32_t) dev->calib.par_h7) / ((int32_t) 100))) >> 4;
006656  90101E     MOV [W14+34], W0
006658  904860     MOV.B [W0+14], W0
00665A  FB0100     SE W0, W2
00665C  DE91CF     ASR W2, #15, W3
00665E  90002E     MOV [W14+4], W0
006660  B98003     MUL.SS W0, W3, W0
006662  780200     MOV W0, W4
006664  90003E     MOV [W14+6], W0
006666  B98002     MUL.SS W0, W2, W0
006668  780000     MOV W0, W0
00666A  420200     ADD W4, W0, W4
00666C  90002E     MOV [W14+4], W0
00666E  B80002     MUL.UU W0, W2, W0
006670  420201     ADD W4, W1, W4
006672  780084     MOV W4, W1
006674  200642     MOV #0x64, W2
006676  200003     MOV #0x0, W3
006678  07CF50     RCALL ___divsi3
00667A  BE0100     MOV.D W0, W2
00667C  90082E     MOV [W14+20], W0
00667E  9008BE     MOV [W14+22], W1
006680  400002     ADD W0, W2, W0
006682  488083     ADDC W1, W3, W1
006684  DD0A4C     SL W1, #12, W4
006686  DE01C4     LSR W0, #4, W3
006688  720183     IOR W4, W3, W3
00668A  981F23     MOV W3, [W14+52]
00668C  DE8944     ASR W1, #4, W2
00668E  981F32     MOV W2, [W14+54]
006690  90192E     MOV [W14+52], W2
006692  9019BE     MOV [W14+54], W3
006694  980F22     MOV W2, [W14+20]
006696  980F33     MOV W3, [W14+22]
958:               	var5 = ((var3 >> 14) * (var3 >> 14)) >> 10;
006698  90080E     MOV [W14+16], W0
00669A  90089E     MOV [W14+18], W1
00669C  DD0A42     SL W1, #2, W4
00669E  DE01CE     LSR W0, #14, W3
0066A0  720183     IOR W4, W3, W3
0066A2  981743     MOV W3, [W14+40]
0066A4  DE894E     ASR W1, #14, W2
0066A6  981752     MOV W2, [W14+42]
0066A8  90080E     MOV [W14+16], W0
0066AA  90089E     MOV [W14+18], W1
0066AC  DD0A42     SL W1, #2, W4
0066AE  DE01CE     LSR W0, #14, W3
0066B0  720183     IOR W4, W3, W3
0066B2  981763     MOV W3, [W14+44]
0066B4  DE894E     ASR W1, #14, W2
0066B6  981772     MOV W2, [W14+46]
0066B8  9011DE     MOV [W14+42], W3
0066BA  90126E     MOV [W14+44], W4
0066BC  B99804     MUL.SS W3, W4, W0
0066BE  780100     MOV W0, W2
0066C0  9011FE     MOV [W14+46], W3
0066C2  90124E     MOV [W14+40], W4
0066C4  B99804     MUL.SS W3, W4, W0
0066C6  780000     MOV W0, W0
0066C8  410100     ADD W2, W0, W2
0066CA  9011CE     MOV [W14+40], W3
0066CC  90126E     MOV [W14+44], W4
0066CE  B81804     MUL.UU W3, W4, W0
0066D0  410101     ADD W2, W1, W2
0066D2  780082     MOV W2, W1
0066D4  DD09C6     SL W1, #6, W3
0066D6  DE014A     LSR W0, #10, W2
0066D8  718102     IOR W3, W2, W2
0066DA  981F42     MOV W2, [W14+56]
0066DC  DE8A4A     ASR W1, #10, W4
0066DE  981F54     MOV W4, [W14+58]
0066E0  90194E     MOV [W14+56], W2
0066E2  9019DE     MOV [W14+58], W3
0066E4  980F42     MOV W2, [W14+24]
0066E6  980F53     MOV W3, [W14+26]
959:               	var6 = (var4 * var5) >> 1;
0066E8  9008BE     MOV [W14+22], W1
0066EA  90084E     MOV [W14+24], W0
0066EC  B98800     MUL.SS W1, W0, W0
0066EE  780100     MOV W0, W2
0066F0  9008DE     MOV [W14+26], W1
0066F2  90082E     MOV [W14+20], W0
0066F4  B98800     MUL.SS W1, W0, W0
0066F6  780000     MOV W0, W0
0066F8  410100     ADD W2, W0, W2
0066FA  9008AE     MOV [W14+20], W1
0066FC  90084E     MOV [W14+24], W0
0066FE  B80800     MUL.UU W1, W0, W0
006700  410101     ADD W2, W1, W2
006702  780082     MOV W2, W1
006704  D18081     ASR W1, W1
006706  D38000     RRC W0, W0
006708  980F60     MOV W0, [W14+28]
00670A  980F71     MOV W1, [W14+30]
960:               	calc_hum = (((var3 + var6) >> 10) * ((int32_t) 1000)) >> 12;
00670C  90090E     MOV [W14+16], W2
00670E  90099E     MOV [W14+18], W3
006710  90086E     MOV [W14+28], W0
006712  9008FE     MOV [W14+30], W1
006714  400002     ADD W0, W2, W0
006716  488083     ADDC W1, W3, W1
006718  DD09C6     SL W1, #6, W3
00671A  DE064A     LSR W0, #10, W12
00671C  71860C     IOR W3, W12, W12
00671E  DE8ECA     ASR W1, #10, W13
006720  203E80     MOV #0x3E8, W0
006722  B9E800     MUL.SS W13, W0, W0
006724  780100     MOV W0, W2
006726  B96060     MUL.SU W12, #0, W0
006728  780000     MOV W0, W0
00672A  410100     ADD W2, W0, W2
00672C  203E80     MOV #0x3E8, W0
00672E  B86000     MUL.UU W12, W0, W0
006730  410101     ADD W2, W1, W2
006732  780082     MOV W2, W1
006734  DD0944     SL W1, #4, W2
006736  DE024C     LSR W0, #12, W4
006738  710204     IOR W2, W4, W4
00673A  981F64     MOV W4, [W14+60]
00673C  DE89CC     ASR W1, #12, W3
00673E  981F73     MOV W3, [W14+62]
006740  90196E     MOV [W14+60], W2
006742  9019FE     MOV [W14+62], W3
006744  BE8F02     MOV.D W2, [W14]
961:               
962:               	if (calc_hum > 100000) /* Cap at 100%rH */
006746  286A00     MOV #0x86A0, W0
006748  200011     MOV #0x1, W1
00674A  BE011E     MOV.D [W14], W2
00674C  510F80     SUB W2, W0, [W15]
00674E  598F81     SUBB W3, W1, [W15]
006750  340004     BRA LE, .L78
963:               		calc_hum = 100000;
006752  286A00     MOV #0x86A0, W0
006754  200011     MOV #0x1, W1
006756  BE8F00     MOV.D W0, [W14]
006758  370006     BRA .L79
964:               	else if (calc_hum < 0)
00675A  BE001E     MOV.D [W14], W0
00675C  500FE0     SUB W0, #0x0, [W15]
00675E  588FE0     SUBB W1, #0x0, [W15]
006760  3D0002     BRA GE, .L79
965:               		calc_hum = 0;
006762  B80060     MUL.UU W0, #0, W0
006764  BE8F00     MOV.D W0, [W14]
966:               
967:               	return (uint32_t) calc_hum;
006766  BE001E     MOV.D [W14], W0
968:               }
006768  BE064F     MOV.D [--W15], W12
00676A  BE054F     MOV.D [--W15], W10
00676C  BE044F     MOV.D [--W15], W8
00676E  FA8000     ULNK
006770  060000     RETURN
969:               
970:               /*!
971:                * @brief This internal API is used to calculate the Gas Resistance value.
972:                */
973:               static uint32_t calc_gas_resistance(uint16_t gas_res_adc, uint8_t gas_range, const struct bme680_dev *dev)
974:               {
006772  FA00A2     LNK #0xA2
006774  BE9F88     MOV.D W8, [W15++]
006776  BE9F8A     MOV.D W10, [W15++]
006778  988F60     MOV W0, [W14+156]
00677A  995F61     MOV.B W1, [W14+158]
00677C  989702     MOV W2, [W14+160]
975:               	int64_t var1;
976:               	uint64_t var2;
977:               	int64_t var3;
978:               	uint32_t calc_gas_res;
979:               	/**Look up table 1 for the possible gas range values */
980:               	uint32_t lookupTable1[16] = { UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647),
00677E  4700FC     ADD W14, #0x1C, W1
006780  2D5502     MOV #0xD550, W2
006782  09001F     REPEAT #0x1F
006784  7818B2     MOV [W2++], [W1++]
981:               		UINT32_C(2147483647), UINT32_C(2126008810), UINT32_C(2147483647), UINT32_C(2130303777),
982:               		UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2143188679), UINT32_C(2136746228),
983:               		UINT32_C(2147483647), UINT32_C(2126008810), UINT32_C(2147483647), UINT32_C(2147483647) };
984:               	/**Look up table 2 for the possible gas range values */
985:               	uint32_t lookupTable2[16] = { UINT32_C(4096000000), UINT32_C(2048000000), UINT32_C(1024000000), UINT32_C(512000000),
006786  2005C4     MOV #0x5C, W4
006788  470204     ADD W14, W4, W4
00678A  2D5901     MOV #0xD590, W1
00678C  09001F     REPEAT #0x1F
00678E  781A31     MOV [W1++], [W4++]
986:               		UINT32_C(255744255), UINT32_C(127110228), UINT32_C(64000000), UINT32_C(32258064), UINT32_C(16016016),
987:               		UINT32_C(8000000), UINT32_C(4000000), UINT32_C(2000000), UINT32_C(1000000), UINT32_C(500000),
988:               		UINT32_C(250000), UINT32_C(125000) };
989:               
990:               	var1 = (int64_t) ((1340 + (5 * (int64_t) dev->calib.range_sw_err)) *
006790  90900E     MOV [W14+160], W0
006792  907020     MOV.B [W0+50], W0
006794  FB0000     SE W0, W0
006796  DE80CF     ASR W0, #15, W1
006798  B90961     MUL.SU W1, #1, W2
00679A  200054     MOV #0x5, W4
00679C  200005     MOV #0x0, W5
00679E  B83360     MUL.UU W6, #0, W6
0067A0  07D110     RCALL ___muldi3
0067A2  BE0302     MOV.D W2, W6
0067A4  BE0200     MOV.D W0, W4
0067A6  2053C0     MOV #0x53C, W0
0067A8  200001     MOV #0x0, W1
0067AA  B81160     MUL.UU W2, #0, W2
0067AC  420400     ADD W4, W0, W8
0067AE  4A8481     ADDC W5, W1, W9
0067B0  4B0502     ADDC W6, W2, W10
0067B2  4B8583     ADDC W7, W3, W11
0067C2  BE0302     MOV.D W2, W6
0067C4  BE0200     MOV.D W0, W4
0067C6  BE0008     MOV.D W8, W0
0067C8  BE010A     MOV.D W10, W2
0067CA  07D0FB     RCALL ___muldi3
0067CC  780001     MOV W1, W0
0067CE  780082     MOV W2, W1
0067D0  B91961     MUL.SU W3, #1, W2
0067D2  BE9F00     MOV.D W0, [W14++]
0067D4  BE9702     MOV.D W2, [W14--]
991:               		((int64_t) lookupTable1[gas_range])) >> 16;
0067B4  91586E     MOV.B [W14+158], W0
0067B6  FB8000     ZE W0, W0
0067B8  DD0042     SL W0, #2, W0
0067BA  4700FC     ADD W14, #0x1C, W1
0067BC  408000     ADD W1, W0, W0
0067BE  BE0010     MOV.D [W0], W0
0067C0  B81160     MUL.UU W2, #0, W2
992:               	var2 = (((int64_t) ((int64_t) gas_res_adc << 15) - (int64_t) (16777216)) + var1);
0067D6  90886E     MOV [W14+156], W0
0067D8  EB0080     CLR W1
0067DA  B81160     MUL.UU W2, #0, W2
0067DC  BE0502     MOV.D W2, W10
0067DE  BE0400     MOV.D W0, W8
0067E0  DD5DCF     SL W11, #15, W11
0067E2  DE5241     LSR W10, #1, W4
0067E4  72058B     IOR W4, W11, W11
0067E6  DD554F     SL W10, #15, W10
0067E8  DE4A41     LSR W9, #1, W4
0067EA  72050A     IOR W4, W10, W10
0067EC  DD4CCF     SL W9, #15, W9
0067EE  DE4241     LSR W8, #1, W4
0067F0  720489     IOR W4, W9, W9
0067F2  DD444F     SL W8, #15, W8
0067F4  200000     MOV #0x0, W0
0067F6  2FF001     MOV #0xFF00, W1
0067F8  2FFFF2     MOV #0xFFFF, W2
0067FA  2FFFF3     MOV #0xFFFF, W3
0067FC  440200     ADD W8, W0, W4
0067FE  4C8281     ADDC W9, W1, W5
006800  4D0302     ADDC W10, W2, W6
006802  4D8383     ADDC W11, W3, W7
006804  42003E     ADD W4, [W14++], W0
006806  4A80BE     ADDC W5, [W14++], W1
006808  4B013E     ADDC W6, [W14++], W2
00680A  4B819E     ADDC W7, [W14], W3
00680C  B1006E     SUB #0x6, W14
00680E  980740     MOV W0, [W14+8]
006810  980751     MOV W1, [W14+10]
006812  980762     MOV W2, [W14+12]
006814  980773     MOV W3, [W14+14]
993:               	var3 = (((int64_t) lookupTable2[gas_range] * (int64_t) var1) >> 9);
006816  91586E     MOV.B [W14+158], W0
006818  FB8000     ZE W0, W0
00681A  DD0042     SL W0, #2, W0
00681C  2005C1     MOV #0x5C, W1
00681E  40808E     ADD W1, W14, W1
006820  408000     ADD W1, W0, W0
006822  BE0010     MOV.D [W0], W0
006824  B81160     MUL.UU W2, #0, W2
006826  BE023E     MOV.D [W14++], W4
006828  BE032E     MOV.D [W14--], W6
00682A  07D0CB     RCALL ___muldi3
00682C  DE0049     LSR W0, #9, W0
00682E  DD0A47     SL W1, #7, W4
006830  720000     IOR W4, W0, W0
006832  DE08C9     LSR W1, #9, W1
006834  DD1247     SL W2, #7, W4
006836  720081     IOR W4, W1, W1
006838  DE1149     LSR W2, #9, W2
00683A  DD1A47     SL W3, #7, W4
00683C  720102     IOR W4, W2, W2
00683E  DE99C9     ASR W3, #9, W3
006840  980F00     MOV W0, [W14+16]
006842  980F11     MOV W1, [W14+18]
006844  980F22     MOV W2, [W14+20]
006846  980F33     MOV W3, [W14+22]
994:               	calc_gas_res = (uint32_t) ((var3 + ((int64_t) var2 >> 1)) / (int64_t) var2);
006848  90004E     MOV [W14+8], W0
00684A  9000DE     MOV [W14+10], W1
00684C  90016E     MOV [W14+12], W2
00684E  9001FE     MOV [W14+14], W3
006850  D18383     ASR W3, W7
006852  D38302     RRC W2, W6
006854  D38281     RRC W1, W5
006856  D38200     RRC W0, W4
006858  90080E     MOV [W14+16], W0
00685A  90089E     MOV [W14+18], W1
00685C  90092E     MOV [W14+20], W2
00685E  9009BE     MOV [W14+22], W3
006860  420400     ADD W4, W0, W8
006862  4A8481     ADDC W5, W1, W9
006864  4B0502     ADDC W6, W2, W10
006866  4B8583     ADDC W7, W3, W11
006868  90004E     MOV [W14+8], W0
00686A  9000DE     MOV [W14+10], W1
00686C  90016E     MOV [W14+12], W2
00686E  9001FE     MOV [W14+14], W3
006870  BE0302     MOV.D W2, W6
006872  BE0200     MOV.D W0, W4
006874  BE0008     MOV.D W8, W0
006876  BE010A     MOV.D W10, W2
006878  07D046     RCALL ___divdi3
00687A  980F40     MOV W0, [W14+24]
00687C  980F51     MOV W1, [W14+26]
995:               
996:               	return calc_gas_res;
00687E  90084E     MOV [W14+24], W0
006880  9008DE     MOV [W14+26], W1
997:               }
006882  BE054F     MOV.D [--W15], W10
006884  BE044F     MOV.D [--W15], W8
006886  FA8000     ULNK
006888  060000     RETURN
998:               
999:               /*!
1000:               * @brief This internal API is used to calculate the Heat Resistance value.
1001:               */
1002:              static uint8_t calc_heater_res(uint16_t temp, const struct bme680_dev *dev)
1003:              {
00688A  FA001E     LNK #0x1E
00688C  BE9F88     MOV.D W8, [W15++]
00688E  980F50     MOV W0, [W14+26]
006890  980F61     MOV W1, [W14+28]
1004:              	uint8_t heatr_res;
1005:              	int32_t var1;
1006:              	int32_t var2;
1007:              	int32_t var3;
1008:              	int32_t var4;
1009:              	int32_t var5;
1010:              	int32_t heatr_res_x100;
1011:              
1012:              	if (temp > 400) /* Cap temperature */
006892  9008DE     MOV [W14+26], W1
006894  201900     MOV #0x190, W0
006896  508F80     SUB W1, W0, [W15]
006898  360002     BRA LEU, .L82
1013:              		temp = 400;
00689A  201900     MOV #0x190, W0
00689C  980F50     MOV W0, [W14+26]
1014:              
1015:              	var1 = (((int32_t) dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
00689E  90086E     MOV [W14+28], W0
0068A0  904050     MOV.B [W0+5], W0
0068A2  FB0100     SE W0, W2
0068A4  DE91CF     ASR W2, #15, W3
0068A6  90086E     MOV [W14+28], W0
0068A8  905020     MOV.B [W0+18], W0
0068AA  FB0000     SE W0, W0
0068AC  DE80CF     ASR W0, #15, W1
0068AE  B99A00     MUL.SS W3, W0, W4
0068B0  780204     MOV W4, W4
0068B2  B98B02     MUL.SS W1, W2, W6
0068B4  780286     MOV W6, W5
0068B6  420205     ADD W4, W5, W4
0068B8  B81000     MUL.UU W2, W0, W0
0068BA  420201     ADD W4, W1, W4
0068BC  780084     MOV W4, W1
0068BE  203E82     MOV #0x3E8, W2
0068C0  200003     MOV #0x0, W3
0068C2  07CE2B     RCALL ___divsi3
0068C4  BE0100     MOV.D W0, W2
0068C6  DD1848     SL W3, #8, W0
0068C8  DE10C8     LSR W2, #8, W1
0068CA  700081     IOR W0, W1, W1
0068CC  DD1048     SL W2, #8, W0
0068CE  BE8F00     MOV.D W0, [W14]
1016:              	var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
0068D0  90086E     MOV [W14+28], W0
0068D2  904870     MOV.B [W0+15], W0
0068D4  FB0000     SE W0, W0
0068D6  B03100     ADD #0x310, W0
0068D8  B90461     MUL.SU W0, #1, W8
0068DA  90086E     MOV [W14+28], W0
0068DC  900800     MOV [W0+16], W0
0068DE  DE80CF     ASR W0, #15, W1
0068E0  B90965     MUL.SU W1, #5, W2
0068E2  780102     MOV W2, W2
0068E4  B90260     MUL.SU W0, #0, W4
0068E6  780184     MOV W4, W3
0068E8  410103     ADD W2, W3, W2
0068EA  200053     MOV #0x5, W3
0068EC  B80003     MUL.UU W0, W3, W0
0068EE  410101     ADD W2, W1, W2
0068F0  780082     MOV W2, W1
0068F2  2BFFD2     MOV #0xBFFD, W2
0068F4  2000B3     MOV #0xB, W3
0068F6  410100     ADD W2, W0, W2
0068F8  498181     ADDC W3, W1, W3
0068FA  90085E     MOV [W14+26], W0
0068FC  EB0080     CLR W1
0068FE  B99A00     MUL.SS W3, W0, W4
006900  780204     MOV W4, W4
006902  B98B02     MUL.SS W1, W2, W6
006904  780286     MOV W6, W5
006906  420205     ADD W4, W5, W4
006908  B81000     MUL.UU W2, W0, W0
00690A  420201     ADD W4, W1, W4
00690C  780084     MOV W4, W1
00690E  200642     MOV #0x64, W2
006910  200003     MOV #0x0, W3
006912  07CE03     RCALL ___divsi3
006914  BE0100     MOV.D W0, W2
006916  200000     MOV #0x0, W0
006918  200321     MOV #0x32, W1
00691A  400002     ADD W0, W2, W0
00691C  488083     ADDC W1, W3, W1
00691E  2000A2     MOV #0xA, W2
006920  200003     MOV #0x0, W3
006922  07CDFB     RCALL ___divsi3
006924  B9C900     MUL.SS W9, W0, W2
006926  780102     MOV W2, W2
006928  B98A08     MUL.SS W1, W8, W4
00692A  780184     MOV W4, W3
00692C  410103     ADD W2, W3, W2
00692E  B84000     MUL.UU W8, W0, W0
006930  410101     ADD W2, W1, W2
006932  780082     MOV W2, W1
006934  980720     MOV W0, [W14+4]
006936  980731     MOV W1, [W14+6]
006938  980720     MOV W0, [W14+4]
00693A  980731     MOV W1, [W14+6]
1017:              	var3 = var1 + (var2 / 2);
00693C  90002E     MOV [W14+4], W0
00693E  9000BE     MOV [W14+6], W1
006940  DE094F     LSR W1, #15, W2
006942  EB0180     CLR W3
006944  400002     ADD W0, W2, W0
006946  488083     ADDC W1, W3, W1
006948  D18081     ASR W1, W1
00694A  D38000     RRC W0, W0
00694C  40013E     ADD W0, [W14++], W2
00694E  4881AE     ADDC W1, [W14--], W3
006950  BE0002     MOV.D W2, W0
006952  980740     MOV W0, [W14+8]
006954  980751     MOV W1, [W14+10]
1018:              	var4 = (var3 / (dev->calib.res_heat_range + 4));
006956  90086E     MOV [W14+28], W0
006958  907000     MOV.B [W0+48], W0
00695A  FB8000     ZE W0, W0
00695C  400064     ADD W0, #0x4, W0
00695E  DE80CF     ASR W0, #15, W1
006960  BE0100     MOV.D W0, W2
006962  90004E     MOV [W14+8], W0
006964  9000DE     MOV [W14+10], W1
006966  07CDD9     RCALL ___divsi3
006968  980760     MOV W0, [W14+12]
00696A  980771     MOV W1, [W14+14]
1019:              	var5 = (131 * dev->calib.res_heat_val) + 65536;
00696C  90086E     MOV [W14+28], W0
00696E  907010     MOV.B [W0+49], W0
006970  FB0080     SE W0, W1
006972  200830     MOV #0x83, W0
006974  B98800     MUL.SS W1, W0, W0
006976  780000     MOV W0, W0
006978  B90161     MUL.SU W0, #1, W2
00697A  200000     MOV #0x0, W0
00697C  200011     MOV #0x1, W1
00697E  400002     ADD W0, W2, W0
006980  488083     ADDC W1, W3, W1
006982  980F00     MOV W0, [W14+16]
006984  980F11     MOV W1, [W14+18]
1020:              	heatr_res_x100 = (int32_t) (((var4 / var5) - 250) * 34);
006986  90090E     MOV [W14+16], W2
006988  90099E     MOV [W14+18], W3
00698A  90006E     MOV [W14+12], W0
00698C  9000FE     MOV [W14+14], W1
00698E  07CDC5     RCALL ___divsi3
006990  200222     MOV #0x22, W2
006992  B98902     MUL.SS W1, W2, W2
006994  780102     MOV W2, W2
006996  B90260     MUL.SU W0, #0, W4
006998  780184     MOV W4, W3
00699A  410103     ADD W2, W3, W2
00699C  200223     MOV #0x22, W3
00699E  B80003     MUL.UU W0, W3, W0
0069A0  410101     ADD W2, W1, W2
0069A2  780082     MOV W2, W1
0069A4  2DECC2     MOV #0xDECC, W2
0069A6  2FFFF3     MOV #0xFFFF, W3
0069A8  410000     ADD W2, W0, W0
0069AA  498081     ADDC W3, W1, W1
0069AC  980F20     MOV W0, [W14+20]
0069AE  980F31     MOV W1, [W14+22]
1021:              	heatr_res = (uint8_t) ((heatr_res_x100 + 50) / 100);
0069B0  90082E     MOV [W14+20], W0
0069B2  9008BE     MOV [W14+22], W1
0069B4  B00320     ADD #0x32, W0
0069B6  B08001     ADDC #0x0, W1
0069B8  200642     MOV #0x64, W2
0069BA  200003     MOV #0x0, W3
0069BC  07CDAE     RCALL ___divsi3
0069BE  985F00     MOV.B W0, [W14+24]
1022:              
1023:              	return heatr_res;
0069C0  90580E     MOV.B [W14+24], W0
1024:              }
0069C2  BE044F     MOV.D [--W15], W8
0069C4  FA8000     ULNK
0069C6  060000     RETURN
1025:              
1026:              #else
1027:              
1028:              
1029:              /*!
1030:               * @brief This internal API is used to calculate the
1031:               * temperature value in float format
1032:               */
1033:              static float calc_temperature(uint32_t temp_adc, struct bme680_dev *dev)
1034:              {
1035:              	float var1 = 0;
1036:              	float var2 = 0;
1037:              	float calc_temp = 0;
1038:              
1039:              	/* calculate var1 data */
1040:              	var1  = ((((float)temp_adc / 16384.0f) - ((float)dev->calib.par_t1 / 1024.0f))
1041:              			* ((float)dev->calib.par_t2));
1042:              
1043:              	/* calculate var2 data */
1044:              	var2  = (((((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f)) *
1045:              		(((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f))) *
1046:              		((float)dev->calib.par_t3 * 16.0f));
1047:              
1048:              	/* t_fine value*/
1049:              	dev->calib.t_fine = (var1 + var2);
1050:              
1051:              	/* compensated temperature data*/
1052:              	calc_temp  = ((dev->calib.t_fine) / 5120.0f);
1053:              
1054:              	return calc_temp;
1055:              }
1056:              
1057:              /*!
1058:               * @brief This internal API is used to calculate the
1059:               * pressure value in float format
1060:               */
1061:              static float calc_pressure(uint32_t pres_adc, const struct bme680_dev *dev)
1062:              {
1063:              	float var1 = 0;
1064:              	float var2 = 0;
1065:              	float var3 = 0;
1066:              	float calc_pres = 0;
1067:              
1068:              	var1 = (((float)dev->calib.t_fine / 2.0f) - 64000.0f);
1069:              	var2 = var1 * var1 * (((float)dev->calib.par_p6) / (131072.0f));
1070:              	var2 = var2 + (var1 * ((float)dev->calib.par_p5) * 2.0f);
1071:              	var2 = (var2 / 4.0f) + (((float)dev->calib.par_p4) * 65536.0f);
1072:              	var1 = (((((float)dev->calib.par_p3 * var1 * var1) / 16384.0f)
1073:              		+ ((float)dev->calib.par_p2 * var1)) / 524288.0f);
1074:              	var1 = ((1.0f + (var1 / 32768.0f)) * ((float)dev->calib.par_p1));
1075:              	calc_pres = (1048576.0f - ((float)pres_adc));
1076:              
1077:              	/* Avoid exception caused by division by zero */
1078:              	if ((int)var1 != 0) {
1079:              		calc_pres = (((calc_pres - (var2 / 4096.0f)) * 6250.0f) / var1);
1080:              		var1 = (((float)dev->calib.par_p9) * calc_pres * calc_pres) / 2147483648.0f;
1081:              		var2 = calc_pres * (((float)dev->calib.par_p8) / 32768.0f);
1082:              		var3 = ((calc_pres / 256.0f) * (calc_pres / 256.0f) * (calc_pres / 256.0f)
1083:              			* (dev->calib.par_p10 / 131072.0f));
1084:              		calc_pres = (calc_pres + (var1 + var2 + var3 + ((float)dev->calib.par_p7 * 128.0f)) / 16.0f);
1085:              	} else {
1086:              		calc_pres = 0;
1087:              	}
1088:              
1089:              	return calc_pres;
1090:              }
1091:              
1092:              /*!
1093:               * @brief This internal API is used to calculate the
1094:               * humidity value in float format
1095:               */
1096:              static float calc_humidity(uint16_t hum_adc, const struct bme680_dev *dev)
1097:              {
1098:              	float calc_hum = 0;
1099:              	float var1 = 0;
1100:              	float var2 = 0;
1101:              	float var3 = 0;
1102:              	float var4 = 0;
1103:              	float temp_comp;
1104:              
1105:              	/* compensated temperature data*/
1106:              	temp_comp  = ((dev->calib.t_fine) / 5120.0f);
1107:              
1108:              	var1 = (float)((float)hum_adc) - (((float)dev->calib.par_h1 * 16.0f) + (((float)dev->calib.par_h3 / 2.0f)
1109:              		* temp_comp));
1110:              
1111:              	var2 = var1 * ((float)(((float) dev->calib.par_h2 / 262144.0f) * (1.0f + (((float)dev->calib.par_h4 / 16384.0f)
1112:              		* temp_comp) + (((float)dev->calib.par_h5 / 1048576.0f) * temp_comp * temp_comp))));
1113:              
1114:              	var3 = (float) dev->calib.par_h6 / 16384.0f;
1115:              
1116:              	var4 = (float) dev->calib.par_h7 / 2097152.0f;
1117:              
1118:              	calc_hum = var2 + ((var3 + (var4 * temp_comp)) * var2 * var2);
1119:              
1120:              	if (calc_hum > 100.0f)
1121:              		calc_hum = 100.0f;
1122:              	else if (calc_hum < 0.0f)
1123:              		calc_hum = 0.0f;
1124:              
1125:              	return calc_hum;
1126:              }
1127:              
1128:              /*!
1129:               * @brief This internal API is used to calculate the
1130:               * gas resistance value in float format
1131:               */
1132:              static float calc_gas_resistance(uint16_t gas_res_adc, uint8_t gas_range, const struct bme680_dev *dev)
1133:              {
1134:              	float calc_gas_res;
1135:              	float var1 = 0;
1136:              	float var2 = 0;
1137:              	float var3 = 0;
1138:              
1139:              	const float lookup_k1_range[16] = {
1140:              	0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, -0.8,
1141:              	0.0, 0.0, -0.2, -0.5, 0.0, -1.0, 0.0, 0.0};
1142:              	const float lookup_k2_range[16] = {
1143:              	0.0, 0.0, 0.0, 0.0, 0.1, 0.7, 0.0, -0.8,
1144:              	-0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
1145:              
1146:              	var1 = (1340.0f + (5.0f * dev->calib.range_sw_err));
1147:              	var2 = (var1) * (1.0f + lookup_k1_range[gas_range]/100.0f);
1148:              	var3 = 1.0f + (lookup_k2_range[gas_range]/100.0f);
1149:              
1150:              	calc_gas_res = 1.0f / (float)(var3 * (0.000000125f) * (float)(1 << gas_range) * (((((float)gas_res_adc)
1151:              		- 512.0f)/var2) + 1.0f));
1152:              
1153:              	return calc_gas_res;
1154:              }
1155:              
1156:              /*!
1157:               * @brief This internal API is used to calculate the
1158:               * heater resistance value in float format
1159:               */
1160:              static float calc_heater_res(uint16_t temp, const struct bme680_dev *dev)
1161:              {
1162:              	float var1 = 0;
1163:              	float var2 = 0;
1164:              	float var3 = 0;
1165:              	float var4 = 0;
1166:              	float var5 = 0;
1167:              	float res_heat = 0;
1168:              
1169:              	if (temp > 400) /* Cap temperature */
1170:              		temp = 400;
1171:              
1172:              	var1 = (((float)dev->calib.par_gh1 / (16.0f)) + 49.0f);
1173:              	var2 = ((((float)dev->calib.par_gh2 / (32768.0f)) * (0.0005f)) + 0.00235f);
1174:              	var3 = ((float)dev->calib.par_gh3 / (1024.0f));
1175:              	var4 = (var1 * (1.0f + (var2 * (float)temp)));
1176:              	var5 = (var4 + (var3 * (float)dev->amb_temp));
1177:              	res_heat = (uint8_t)(3.4f * ((var5 * (4 / (4 + (float)dev->calib.res_heat_range)) *
1178:              		(1/(1 + ((float) dev->calib.res_heat_val * 0.002f)))) - 25));
1179:              
1180:              	return res_heat;
1181:              }
1182:              
1183:              #endif
1184:              
1185:              /*!
1186:               * @brief This internal API is used to calculate the Heat duration value.
1187:               */
1188:              static uint8_t calc_heater_dur(uint16_t dur)
1189:              {
0069C8  FA0004     LNK #0x4
0069CA  980710     MOV W0, [W14+2]
1190:              	uint8_t factor = 0;
0069CC  EB4000     CLR.B W0
0069CE  784F00     MOV.B W0, [W14]
1191:              	uint8_t durval;
1192:              
1193:              	if (dur >= 0xfc0) {
0069D0  90009E     MOV [W14+2], W1
0069D2  20FBF0     MOV #0xFBF, W0
0069D4  508F80     SUB W1, W0, [W15]
0069D6  360007     BRA LEU, .L86
1194:              		durval = 0xff; /* Max duration*/
0069D8  EBC000     SETM.B W0
0069DA  984710     MOV.B W0, [W14+1]
0069DC  37000F     BRA .L85
1195:              	} else {
1196:              		while (dur > 0x3F) {
0069E6  90009E     MOV [W14+2], W1
0069E8  2003F0     MOV #0x3F, W0
0069EA  508F80     SUB W1, W0, [W15]
0069EC  3EFFF8     BRA GTU, .L87
1197:              			dur = dur / 4;
0069DE  90001E     MOV [W14+2], W0
0069E0  DE0042     LSR W0, #2, W0
0069E2  980710     MOV W0, [W14+2]
1198:              			factor += 1;
0069E4  E84F1E     INC.B [W14], [W14]
1199:              		}
1200:              		durval = (uint8_t) (dur + (factor * 64));
0069EE  90001E     MOV [W14+2], W0
0069F0  784080     MOV.B W0, W1
0069F2  78411E     MOV.B [W14], W2
0069F4  200060     MOV #0x6, W0
0069F6  DD1000     SL W2, W0, W0
0069F8  40C000     ADD.B W1, W0, W0
0069FA  984710     MOV.B W0, [W14+1]
1201:              	}
1202:              
1203:              	return durval;
0069FC  90401E     MOV.B [W14+1], W0
1204:              }
0069FE  FA8000     ULNK
006A00  060000     RETURN
1205:              
1206:              /*!
1207:               * @brief This internal API is used to calculate the field data of sensor.
1208:               */
1209:              static int8_t read_field_data(struct bme680_field_data *data, struct bme680_dev *dev)
1210:              {
006A02  FA0022     LNK #0x22
006A04  980F70     MOV W0, [W14+30]
006A06  981701     MOV W1, [W14+32]
1211:              	int8_t rslt;
1212:              	uint8_t buff[BME680_FIELD_LENGTH] = { 0 };
006A08  4700EF     ADD W14, #0xF, W1
006A0A  09000E     REPEAT #0xE
006A0C  EB5880     CLR.B [W1++]
1213:              	uint8_t gas_range;
1214:              	uint32_t adc_temp;
1215:              	uint32_t adc_pres;
1216:              	uint16_t adc_hum;
1217:              	uint16_t adc_gas_res;
1218:              	uint8_t tries = 10;
006A0E  B3C0A0     MOV.B #0xA, W0
006A10  984710     MOV.B W0, [W14+1]
1219:              
1220:              	/* Check for null pointer in the device structure*/
1221:              	rslt = null_ptr_check(dev);
006A12  90100E     MOV [W14+32], W0
006A14  07013A     RCALL _null_ptr_check, .LFE23, .LFB24
006A16  784F00     MOV.B W0, [W14]
1222:              	do {
1223:              		if (rslt == BME680_OK) {
006A18  78401E     MOV.B [W14], W0
006A1A  E00400     CP0.B W0
006A1C  3A0091     BRA NZ, .L89
1224:              			rslt = bme680_get_regs(((uint8_t) (BME680_FIELD0_ADDR)), buff, (uint16_t) BME680_FIELD_LENGTH,
006A1E  47006F     ADD W14, #0xF, W0
006A20  90118E     MOV [W14+32], W3
006A22  2000F2     MOV #0xF, W2
006A24  780080     MOV W0, W1
006A26  B3C1D0     MOV.B #0x1D, W0
006A28  07F603     RCALL bme680_get_regs
006A2A  784F00     MOV.B W0, [W14]
1225:              				dev);
1226:              
1227:              			data->status = buff[0] & BME680_NEW_DATA_MSK;
006A2C  9048FE     MOV.B [W14+15], W1
006A2E  B3C800     MOV.B #0x80, W0
006A30  60C080     AND.B W1, W0, W1
006A32  90087E     MOV [W14+30], W0
006A34  784801     MOV.B W1, [W0]
1228:              			data->gas_index = buff[0] & BME680_GAS_INDEX_MSK;
006A36  90487E     MOV.B [W14+15], W0
006A38  6040EF     AND.B W0, #0xF, W1
006A3A  90087E     MOV [W14+30], W0
006A3C  984011     MOV.B W1, [W0+1]
1229:              			data->meas_index = buff[1];
006A3E  90508E     MOV.B [W14+16], W1
006A40  90087E     MOV [W14+30], W0
006A42  984021     MOV.B W1, [W0+2]
1230:              
1231:              			/* read the raw data from the sensor */
1232:              			adc_pres = (uint32_t) (((uint32_t) buff[2] * 4096) | ((uint32_t) buff[3] * 16)
006A44  90501E     MOV.B [W14+17], W0
006A46  FB8000     ZE W0, W0
006A48  EB0080     CLR W1
006A4A  DD094C     SL W1, #12, W2
006A4C  DE01C4     LSR W0, #4, W3
006A4E  710183     IOR W2, W3, W3
006A50  DD014C     SL W0, #12, W2
006A52  90502E     MOV.B [W14+18], W0
006A54  FB8200     ZE W0, W4
006A56  EB0280     CLR W5
006A58  DD2844     SL W5, #4, W0
006A5A  DE20CC     LSR W4, #12, W1
006A5C  700081     IOR W0, W1, W1
006A5E  DD2044     SL W4, #4, W0
006A60  710100     IOR W2, W0, W2
006A62  718181     IOR W3, W1, W3
006A70  710000     IOR W2, W0, W0
006A72  718081     IOR W3, W1, W1
006A74  980710     MOV W0, [W14+2]
006A76  980721     MOV W1, [W14+4]
1233:              				| ((uint32_t) buff[4] / 16));
006A64  90503E     MOV.B [W14+19], W0
006A66  FB8000     ZE W0, W0
006A68  DE0044     LSR W0, #4, W0
006A6A  784000     MOV.B W0, W0
006A6C  FB8000     ZE W0, W0
006A6E  EB0080     CLR W1
1234:              			adc_temp = (uint32_t) (((uint32_t) buff[5] * 4096) | ((uint32_t) buff[6] * 16)
006A78  90504E     MOV.B [W14+20], W0
006A7A  FB8000     ZE W0, W0
006A7C  EB0080     CLR W1
006A7E  DD094C     SL W1, #12, W2
006A80  DE01C4     LSR W0, #4, W3
006A82  710183     IOR W2, W3, W3
006A84  DD014C     SL W0, #12, W2
006A86  90505E     MOV.B [W14+21], W0
006A88  FB8200     ZE W0, W4
006A8A  EB0280     CLR W5
006A8C  DD2844     SL W5, #4, W0
006A8E  DE20CC     LSR W4, #12, W1
006A90  700081     IOR W0, W1, W1
006A92  DD2044     SL W4, #4, W0
006A94  710100     IOR W2, W0, W2
006A96  718181     IOR W3, W1, W3
006AA4  710000     IOR W2, W0, W0
006AA6  718081     IOR W3, W1, W1
006AA8  980730     MOV W0, [W14+6]
006AAA  980741     MOV W1, [W14+8]
1235:              				| ((uint32_t) buff[7] / 16));
006A98  90506E     MOV.B [W14+22], W0
006A9A  FB8000     ZE W0, W0
006A9C  DE0044     LSR W0, #4, W0
006A9E  784000     MOV.B W0, W0
006AA0  FB8000     ZE W0, W0
006AA2  EB0080     CLR W1
1236:              			adc_hum = (uint16_t) (((uint32_t) buff[8] * 256) | (uint32_t) buff[9]);
006AAC  90507E     MOV.B [W14+23], W0
006AAE  FB8000     ZE W0, W0
006AB0  DD00C8     SL W0, #8, W1
006AB2  90580E     MOV.B [W14+24], W0
006AB4  FB8000     ZE W0, W0
006AB6  700001     IOR W0, W1, W0
006AB8  980750     MOV W0, [W14+10]
1237:              			adc_gas_res = (uint16_t) ((uint32_t) buff[13] * 4 | (((uint32_t) buff[14]) / 64));
006ABA  90584E     MOV.B [W14+28], W0
006ABC  FB8000     ZE W0, W0
006ABE  DD00C2     SL W0, #2, W1
006AC0  90585E     MOV.B [W14+29], W0
006AC2  FB8000     ZE W0, W0
006AC4  DE0046     LSR W0, #6, W0
006AC6  784000     MOV.B W0, W0
006AC8  FB8000     ZE W0, W0
006ACA  700001     IOR W0, W1, W0
006ACC  980760     MOV W0, [W14+12]
1238:              			gas_range = buff[14] & BME680_GAS_RANGE_MSK;
006ACE  90585E     MOV.B [W14+29], W0
006AD0  60406F     AND.B W0, #0xF, W0
006AD2  984F60     MOV.B W0, [W14+14]
1239:              
1240:              			data->status |= buff[14] & BME680_GASM_VALID_MSK;
006AD4  90087E     MOV [W14+30], W0
006AD6  784010     MOV.B [W0], W0
006AD8  784080     MOV.B W0, W1
006ADA  90585E     MOV.B [W14+29], W0
006ADC  B24200     AND.B #0x20, W0
006ADE  70C000     IOR.B W1, W0, W0
006AE0  784080     MOV.B W0, W1
006AE2  90087E     MOV [W14+30], W0
006AE4  784801     MOV.B W1, [W0]
1241:              			data->status |= buff[14] & BME680_HEAT_STAB_MSK;
006AE6  90087E     MOV [W14+30], W0
006AE8  784010     MOV.B [W0], W0
006AEA  784080     MOV.B W0, W1
006AEC  90585E     MOV.B [W14+29], W0
006AEE  604070     AND.B W0, #0x10, W0
006AF0  70C000     IOR.B W1, W0, W0
006AF2  784080     MOV.B W0, W1
006AF4  90087E     MOV [W14+30], W0
006AF6  784801     MOV.B W1, [W0]
1242:              
1243:              			if (data->status & BME680_NEW_DATA_MSK) {
006AF8  90087E     MOV [W14+30], W0
006AFA  784010     MOV.B [W0], W0
006AFC  E00400     CP0.B W0
006AFE  3D001B     BRA GE, .L90
1244:              				data->temperature = calc_temperature(adc_temp, dev);
006B00  90110E     MOV [W14+32], W2
006B02  90003E     MOV [W14+6], W0
006B04  9000CE     MOV [W14+8], W1
006B06  07FA9B     RCALL _calc_temperature, .LFE13, .LFB14
006B08  9008FE     MOV [W14+30], W1
006B0A  9800A0     MOV W0, [W1+4]
1245:              				data->pressure = calc_pressure(adc_pres, dev);
006B0C  90110E     MOV [W14+32], W2
006B0E  90001E     MOV [W14+2], W0
006B10  9000AE     MOV [W14+4], W1
006B12  07FB20     RCALL _calc_pressure, .LFE14, .LFB15
006B14  90097E     MOV [W14+30], W2
006B16  980130     MOV W0, [W2+6]
006B18  980141     MOV W1, [W2+8]
1246:              				data->humidity = calc_humidity(adc_hum, dev);
006B1A  90108E     MOV [W14+32], W1
006B1C  90005E     MOV [W14+10], W0
006B1E  07FCE4     RCALL _calc_humidity, .LFE15, .LFB16
006B20  90097E     MOV [W14+30], W2
006B22  980150     MOV W0, [W2+10]
006B24  980161     MOV W1, [W2+12]
1247:              				data->gas_resistance = calc_gas_resistance(adc_gas_res, gas_range, dev);
006B26  90110E     MOV [W14+32], W2
006B28  9048EE     MOV.B [W14+14], W1
006B2A  90006E     MOV [W14+12], W0
006B2C  07FE22     RCALL _calc_gas_resistance, .LFE16, .LFB17
006B2E  90097E     MOV [W14+30], W2
006B30  980170     MOV W0, [W2+14]
006B32  980901     MOV W1, [W2+16]
1248:              				break;
006B34  37000B     BRA .L91
1249:              			}
1250:              			/* Delay to poll the data */
1251:              			dev->delay_ms(BME680_POLL_PERIOD_MS);
006B36  90100E     MOV [W14+32], W0
006B38  902140     MOV [W0+72], W2
006B3A  2000A0     MOV #0xA, W0
006B3C  200001     MOV #0x0, W1
006B3E  010002     CALL W2
1252:              		}
1253:              		tries--;
006B40  90401E     MOV.B [W14+1], W0
006B42  E94000     DEC.B W0, W0
006B44  984710     MOV.B W0, [W14+1]
1254:              	} while (tries);
006B46  90401E     MOV.B [W14+1], W0
006B48  E00400     CP0.B W0
006B4A  3AFF66     BRA NZ, .L92
1255:              
1256:              	if (!tries)
006B4C  90401E     MOV.B [W14+1], W0
006B4E  E00400     CP0.B W0
006B50  3A0002     BRA NZ, .L93
1257:              		rslt = BME680_W_NO_NEW_DATA;
006B52  B3C020     MOV.B #0x2, W0
006B54  784F00     MOV.B W0, [W14]
1258:              
1259:              	return rslt;
006B56  78401E     MOV.B [W14], W0
1260:              }
006B58  FA8000     ULNK
006B5A  060000     RETURN
1261:              
1262:              /*!
1263:               * @brief This internal API is used to set the memory page based on register address.
1264:               */
1265:              static int8_t set_mem_page(uint8_t reg_addr, struct bme680_dev *dev)
1266:              {
006B5C  FA0008     LNK #0x8
006B5E  984740     MOV.B W0, [W14+4]
006B60  980731     MOV W1, [W14+6]
1267:              	int8_t rslt;
1268:              	uint8_t reg;
1269:              	uint8_t mem_page;
1270:              
1271:              	/* Check for null pointers in the device structure*/
1272:              	rslt = null_ptr_check(dev);
006B62  90003E     MOV [W14+6], W0
006B64  070092     RCALL _null_ptr_check, .LFE23, .LFB24
006B66  784F00     MOV.B W0, [W14]
1273:              	if (rslt == BME680_OK) {
006B68  78401E     MOV.B [W14], W0
006B6A  E00400     CP0.B W0
006B6C  3A003E     BRA NZ, .L95
1274:              		if (reg_addr > 0x7f)
006B6E  90404E     MOV.B [W14+4], W0
006B70  E00400     CP0.B W0
006B72  3D0003     BRA GE, .L96
1275:              			mem_page = BME680_MEM_PAGE1;
006B74  EB4000     CLR.B W0
006B76  984710     MOV.B W0, [W14+1]
006B78  370002     BRA .L97
1276:              		else
1277:              			mem_page = BME680_MEM_PAGE0;
006B7A  B3C100     MOV.B #0x10, W0
006B7C  984710     MOV.B W0, [W14+1]
1278:              
1279:              		if (mem_page != dev->mem_page) {
006B7E  90003E     MOV [W14+6], W0
006B80  9040C0     MOV.B [W0+4], W1
006B82  90401E     MOV.B [W14+1], W0
006B84  50CF80     SUB.B W1, W0, [W15]
006B86  320031     BRA Z, .L95
1280:              			dev->mem_page = mem_page;
006B88  90003E     MOV [W14+6], W0
006B8A  90409E     MOV.B [W14+1], W1
006B8C  984041     MOV.B W1, [W0+4]
1281:              
1282:              			dev->com_rslt = dev->read(dev->dev_id, BME680_MEM_PAGE_ADDR | BME680_SPI_RD_MSK, &reg, 1);
006B8E  90003E     MOV [W14+6], W0
006B90  902220     MOV [W0+68], W4
006B92  90003E     MOV [W14+6], W0
006B94  904010     MOV.B [W0+1], W0
006B96  E8808E     INC2 W14, W1
006B98  200013     MOV #0x1, W3
006B9A  780101     MOV W1, W2
006B9C  B3CF31     MOV.B #0xF3, W1
006B9E  010004     CALL W4
006BA0  9000BE     MOV [W14+6], W1
006BA2  98C8A0     MOV.B W0, [W1+74]
1283:              			if (dev->com_rslt != 0)
006BA4  90003E     MOV [W14+6], W0
006BA6  90C820     MOV.B [W0+74], W0
006BA8  E00400     CP0.B W0
006BAA  320002     BRA Z, .L98
1284:              				rslt = BME680_E_COM_FAIL;
006BAC  B3CFE0     MOV.B #0xFE, W0
006BAE  784F00     MOV.B W0, [W14]
1285:              
1286:              			if (rslt == BME680_OK) {
006BB0  78401E     MOV.B [W14], W0
006BB2  E00400     CP0.B W0
006BB4  3A001A     BRA NZ, .L95
1287:              				reg = reg & (~BME680_MEM_PAGE_MSK);
006BB6  90402E     MOV.B [W14+2], W0
006BB8  A14400     BCLR.B W0, #4
006BBA  984720     MOV.B W0, [W14+2]
1288:              				reg = reg | (dev->mem_page & BME680_MEM_PAGE_MSK);
006BBC  90003E     MOV [W14+6], W0
006BBE  904040     MOV.B [W0+4], W0
006BC0  6040F0     AND.B W0, #0x10, W1
006BC2  90402E     MOV.B [W14+2], W0
006BC4  70C000     IOR.B W1, W0, W0
006BC6  984720     MOV.B W0, [W14+2]
1289:              
1290:              				dev->com_rslt = dev->write(dev->dev_id, BME680_MEM_PAGE_ADDR & BME680_SPI_WR_MSK,
006BC8  90003E     MOV [W14+6], W0
006BCA  902230     MOV [W0+70], W4
006BCC  90003E     MOV [W14+6], W0
006BCE  904010     MOV.B [W0+1], W0
006BD0  E8808E     INC2 W14, W1
006BD2  200013     MOV #0x1, W3
006BD4  780101     MOV W1, W2
006BD6  B3C731     MOV.B #0x73, W1
006BD8  010004     CALL W4
006BDA  9000BE     MOV [W14+6], W1
006BDC  98C8A0     MOV.B W0, [W1+74]
1291:              					&reg, 1);
1292:              				if (dev->com_rslt != 0)
006BDE  90003E     MOV [W14+6], W0
006BE0  90C820     MOV.B [W0+74], W0
006BE2  E00400     CP0.B W0
006BE4  320002     BRA Z, .L95
1293:              					rslt = BME680_E_COM_FAIL;
006BE6  B3CFE0     MOV.B #0xFE, W0
006BE8  784F00     MOV.B W0, [W14]
1294:              			}
1295:              		}
1296:              	}
1297:              
1298:              	return rslt;
006BEA  78401E     MOV.B [W14], W0
1299:              }
006BEC  FA8000     ULNK
006BEE  060000     RETURN
1300:              
1301:              /*!
1302:               * @brief This internal API is used to get the memory page based on register address.
1303:               */
1304:              static int8_t get_mem_page(struct bme680_dev *dev)
1305:              {
006BF0  FA0004     LNK #0x4
006BF2  980710     MOV W0, [W14+2]
1306:              	int8_t rslt;
1307:              	uint8_t reg;
1308:              
1309:              	/* Check for null pointer in the device structure*/
1310:              	rslt = null_ptr_check(dev);
006BF4  90001E     MOV [W14+2], W0
006BF6  070049     RCALL _null_ptr_check, .LFE23, .LFB24
006BF8  784F00     MOV.B W0, [W14]
1311:              	if (rslt == BME680_OK) {
006BFA  78401E     MOV.B [W14], W0
006BFC  E00400     CP0.B W0
006BFE  3A0016     BRA NZ, .L100
1312:              		dev->com_rslt = dev->read(dev->dev_id, BME680_MEM_PAGE_ADDR | BME680_SPI_RD_MSK, &reg, 1);
006C00  90001E     MOV [W14+2], W0
006C02  902220     MOV [W0+68], W4
006C04  90001E     MOV [W14+2], W0
006C06  904010     MOV.B [W0+1], W0
006C08  E8008E     INC W14, W1
006C0A  200013     MOV #0x1, W3
006C0C  780101     MOV W1, W2
006C0E  B3CF31     MOV.B #0xF3, W1
006C10  010004     CALL W4
006C12  90009E     MOV [W14+2], W1
006C14  98C8A0     MOV.B W0, [W1+74]
1313:              		if (dev->com_rslt != 0)
006C16  90001E     MOV [W14+2], W0
006C18  90C820     MOV.B [W0+74], W0
006C1A  E00400     CP0.B W0
006C1C  320003     BRA Z, .L101
1314:              			rslt = BME680_E_COM_FAIL;
006C1E  B3CFE0     MOV.B #0xFE, W0
006C20  784F00     MOV.B W0, [W14]
006C22  370004     BRA .L100
1315:              		else
1316:              			dev->mem_page = reg & BME680_MEM_PAGE_MSK;
006C24  90401E     MOV.B [W14+1], W0
006C26  6040F0     AND.B W0, #0x10, W1
006C28  90001E     MOV [W14+2], W0
006C2A  984041     MOV.B W1, [W0+4]
1317:              	}
1318:              
1319:              	return rslt;
006C2C  78401E     MOV.B [W14], W0
1320:              }
006C2E  FA8000     ULNK
006C30  060000     RETURN
1321:              
1322:              /*!
1323:               * @brief This internal API is used to validate the boundary
1324:               * conditions.
1325:               */
1326:              static int8_t boundary_check(uint8_t *value, uint8_t min, uint8_t max, struct bme680_dev *dev)
1327:              {
006C32  FA0008     LNK #0x8
006C34  980710     MOV W0, [W14+2]
006C36  984741     MOV.B W1, [W14+4]
006C38  984752     MOV.B W2, [W14+5]
006C3A  980733     MOV W3, [W14+6]
1328:              	int8_t rslt = BME680_OK;
006C3C  EB4000     CLR.B W0
006C3E  784F00     MOV.B W0, [W14]
1329:              
1330:              	if (value != NULL) {
006C40  90001E     MOV [W14+2], W0
006C42  E00000     CP0 W0
006C44  32001D     BRA Z, .L103
1331:              		/* Check if value is below minimum value */
1332:              		if (*value < min) {
006C46  90001E     MOV [W14+2], W0
006C48  784090     MOV.B [W0], W1
006C4A  90404E     MOV.B [W14+4], W0
006C4C  50CF80     SUB.B W1, W0, [W15]
006C4E  310009     BRA C, .L104
1333:              			/* Auto correct the invalid value to minimum value */
1334:              			*value = min;
006C50  90001E     MOV [W14+2], W0
006C52  9040CE     MOV.B [W14+4], W1
006C54  784801     MOV.B W1, [W0]
1335:              			dev->info_msg |= BME680_I_MIN_CORRECTION;
006C56  90003E     MOV [W14+6], W0
006C58  90C020     MOV.B [W0+66], W0
006C5A  784080     MOV.B W0, W1
006C5C  A00401     BSET.B W1, #0
006C5E  90003E     MOV [W14+6], W0
006C60  98C021     MOV.B W1, [W0+66]
1336:              		}
1337:              		/* Check if value is above maximum value */
1338:              		if (*value > max) {
006C62  90001E     MOV [W14+2], W0
006C64  784090     MOV.B [W0], W1
006C66  90405E     MOV.B [W14+5], W0
006C68  50CF80     SUB.B W1, W0, [W15]
006C6A  36000C     BRA LEU, .L105
1339:              			/* Auto correct the invalid value to maximum value */
1340:              			*value = max;
006C6C  90001E     MOV [W14+2], W0
006C6E  9040DE     MOV.B [W14+5], W1
006C70  784801     MOV.B W1, [W0]
1341:              			dev->info_msg |= BME680_I_MAX_CORRECTION;
006C72  90003E     MOV [W14+6], W0
006C74  90C020     MOV.B [W0+66], W0
006C76  784080     MOV.B W0, W1
006C78  A01401     BSET.B W1, #1
006C7A  90003E     MOV [W14+6], W0
006C7C  98C021     MOV.B W1, [W0+66]
006C7E  370002     BRA .L105
1342:              		}
1343:              	} else {
1344:              		rslt = BME680_E_NULL_PTR;
006C80  EBC000     SETM.B W0
006C82  784F00     MOV.B W0, [W14]
1345:              	}
1346:              
1347:              	return rslt;
006C84  78401E     MOV.B [W14], W0
1348:              }
006C86  FA8000     ULNK
006C88  060000     RETURN
1349:              
1350:              /*!
1351:               * @brief This internal API is used to validate the device structure pointer for
1352:               * null conditions.
1353:               */
1354:              static int8_t null_ptr_check(const struct bme680_dev *dev)
1355:              {
006C8A  FA0004     LNK #0x4
006C8C  980710     MOV W0, [W14+2]
1356:              	int8_t rslt;
1357:              
1358:              	if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_ms == NULL)) {
006C8E  90001E     MOV [W14+2], W0
006C90  E00000     CP0 W0
006C92  32000C     BRA Z, .L107
006C94  90001E     MOV [W14+2], W0
006C96  902020     MOV [W0+68], W0
006C98  E00000     CP0 W0
006C9A  320008     BRA Z, .L107
006C9C  90001E     MOV [W14+2], W0
006C9E  902030     MOV [W0+70], W0
006CA0  E00000     CP0 W0
006CA2  320004     BRA Z, .L107
006CA4  90001E     MOV [W14+2], W0
006CA6  902040     MOV [W0+72], W0
006CA8  E00000     CP0 W0
006CAA  3A0003     BRA NZ, .L108
1359:              		/* Device structure pointer is not valid */
1360:              		rslt = BME680_E_NULL_PTR;
006CAC  EBC000     SETM.B W0
006CAE  784F00     MOV.B W0, [W14]
006CB0  370002     BRA .L109
1361:              	} else {
1362:              		/* Device structure is fine */
1363:              		rslt = BME680_OK;
006CB2  EB4000     CLR.B W0
006CB4  784F00     MOV.B W0, [W14]
1364:              	}
1365:              
1366:              	return rslt;
006CB6  78401E     MOV.B [W14], W0
1367:              }
006CB8  FA8000     ULNK
006CBA  060000     RETURN
